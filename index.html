<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Adam & Helena's Lists</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        @font-face {
            font-family: "Geist Sans";
            font-weight: 600;
            src: url("/fonts/Geist-SemiBold.woff2") format("woff2"),
        }

        .staticrypt-form {
            font-family: "Geist Sans";
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-toggle-password-visibility {
            display: none;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            border-radius: 10px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            border: 1px solid black;
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #ffcc33;
            border: 1px solid black !important;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #000;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffcc33;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #ffcc33;
            /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #ffcc33, #8dc26f);
            background: -moz-linear-gradient(right, #ffcc33, #ffcc33);
            background: -o-linear-gradient(right, #ffcc33, #ffcc33);
            background: linear-gradient(to left, #ffcc33, #ffcc33);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
            font-weight: 500;
        }

        .staticrypt-footer {
            position: fixed;
            height: 20px;
            font-size: 16px;
            padding: 2px;
            bottom: 0;
            left: 0;
            right: 0;
            margin-bottom: 0;
        }

        .staticrypt-footer p {
            margin: 2px;
            text-align: center;
            float: right;
        }

        .staticrypt-footer a {
            text-decoration: none;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <h1 style="font-size: 35px; font-weight: 600;" class="staticrypt-title">Adam & Helena's Lists</h1>
                    <p></p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password" placeholder="Password"
                            autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="template_toggle_show"
                            title="template_toggle_show"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator =
            ((function () {
                const exports = {};
                const cryptoEngine = ((function () {
                    const exports = {};
                    const { subtle } = crypto;

                    const IV_BITS = 16 * 8;
                    const HEX_BITS = 4;
                    const ENCRYPTION_ALGO = "AES-CBC";

                    /**
                     * Translates between utf8 encoded hexadecimal strings
                     * and Uint8Array bytes.
                     */
                    const HexEncoder = {
                        /**
                         * hex string -> bytes
                         * @param {string} hexString
                         * @returns {Uint8Array}
                         */
                        parse: function (hexString) {
                            if (hexString.length % 2 !== 0) throw "Invalid hexString";
                            const arrayBuffer = new Uint8Array(hexString.length / 2);

                            for (let i = 0; i < hexString.length; i += 2) {
                                const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                                if (isNaN(byteValue)) {
                                    throw "Invalid hexString";
                                }
                                arrayBuffer[i / 2] = byteValue;
                            }
                            return arrayBuffer;
                        },

                        /**
                         * bytes -> hex string
                         * @param {Uint8Array} bytes
                         * @returns {string}
                         */
                        stringify: function (bytes) {
                            const hexBytes = [];

                            for (let i = 0; i < bytes.length; ++i) {
                                let byteString = bytes[i].toString(16);
                                if (byteString.length < 2) {
                                    byteString = "0" + byteString;
                                }
                                hexBytes.push(byteString);
                            }
                            return hexBytes.join("");
                        },
                    };

                    /**
                     * Translates between utf8 strings and Uint8Array bytes.
                     */
                    const UTF8Encoder = {
                        parse: function (str) {
                            return new TextEncoder().encode(str);
                        },

                        stringify: function (bytes) {
                            return new TextDecoder().decode(bytes);
                        },
                    };

                    /**
                     * Salt and encrypt a msg with a password.
                     */
                    async function encrypt(msg, hashedPassword) {
                        // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                        const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                        const encrypted = await subtle.encrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            UTF8Encoder.parse(msg)
                        );

                        // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                        return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
                    }
                    exports.encrypt = encrypt;

                    /**
                     * Decrypt a salted msg using a password.
                     *
                     * @param {string} encryptedMsg
                     * @param {string} hashedPassword
                     * @returns {Promise<string>}
                     */
                    async function decrypt(encryptedMsg, hashedPassword) {
                        const ivLength = IV_BITS / HEX_BITS;
                        const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                        const encrypted = encryptedMsg.substring(ivLength);

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                        const outBuffer = await subtle.decrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            HexEncoder.parse(encrypted)
                        );

                        return UTF8Encoder.stringify(new Uint8Array(outBuffer));
                    }
                    exports.decrypt = decrypt;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    async function hashPassword(password, salt) {
                        // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                        // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                        let hashedPassword = await hashLegacyRound(password, salt);

                        hashedPassword = await hashSecondRound(hashedPassword, salt);

                        return hashThirdRound(hashedPassword, salt);
                    }
                    exports.hashPassword = hashPassword;

                    /**
                     * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
                     * compatibility.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    function hashLegacyRound(password, salt) {
                        return pbkdf2(password, salt, 1000, "SHA-1");
                    }
                    exports.hashLegacyRound = hashLegacyRound;

                    /**
                     * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
                     * remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashSecondRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
                    }
                    exports.hashSecondRound = hashSecondRound;

                    /**
                     * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
                     * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashThirdRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
                    }
                    exports.hashThirdRound = hashThirdRound;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @param {int} iterations
                     * @param {string} hashAlgorithm
                     * @returns {Promise<string>}
                     */
                    async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                        const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                        const keyBytes = await subtle.deriveBits(
                            {
                                name: "PBKDF2",
                                hash: hashAlgorithm,
                                iterations,
                                salt: UTF8Encoder.parse(salt),
                            },
                            key,
                            256
                        );

                        return HexEncoder.stringify(new Uint8Array(keyBytes));
                    }

                    function generateRandomSalt() {
                        const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                        return HexEncoder.stringify(new Uint8Array(bytes));
                    }
                    exports.generateRandomSalt = generateRandomSalt;

                    async function signMessage(hashedPassword, message) {
                        const key = await subtle.importKey(
                            "raw",
                            HexEncoder.parse(hashedPassword),
                            {
                                name: "HMAC",
                                hash: "SHA-256",
                            },
                            false,
                            ["sign"]
                        );
                        const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                        return HexEncoder.stringify(new Uint8Array(signature));
                    }
                    exports.signMessage = signMessage;

                    function getRandomAlphanum() {
                        const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                        let byteArray;
                        let parsedInt;

                        // Keep generating new random bytes until we get a value that falls
                        // within a range that can be evenly divided by possibleCharacters.length
                        do {
                            byteArray = crypto.getRandomValues(new Uint8Array(1));
                            // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                            parsedInt = byteArray[0] & 0xff;
                        } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                        // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                        const randomIndex = parsedInt % possibleCharacters.length;

                        return possibleCharacters[randomIndex];
                    }

                    /**
                     * Generate a random string of a given length.
                     *
                     * @param {int} length
                     * @returns {string}
                     */
                    function generateRandomString(length) {
                        let randomString = "";

                        for (let i = 0; i < length; i++) {
                            randomString += getRandomAlphanum();
                        }

                        return randomString;
                    }
                    exports.generateRandomString = generateRandomString;

                    return exports;
                })());
                const codec = ((function () {
                    const exports = {};
                    /**
                   * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
                   *
                   * @param cryptoEngine - the engine to use for encryption / decryption
                   */
                    function init(cryptoEngine) {
                        const exports = {};

                        /**
                         * Top-level function for encoding a message.
                         * Includes password hashing, encryption, and signing.
                         *
                         * @param {string} msg
                         * @param {string} password
                         * @param {string} salt
                         *
                         * @returns {string} The encoded text
                         */
                        async function encode(msg, password, salt) {
                            const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encode = encode;

                        /**
                         * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                         * we don't need to hash the password multiple times.
                         *
                         * @param {string} msg
                         * @param {string} hashedPassword
                         *
                         * @returns {string} The encoded text
                         */
                        async function encodeWithHashedPassword(msg, hashedPassword) {
                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encodeWithHashedPassword = encodeWithHashedPassword;

                        /**
                         * Top-level function for decoding a message.
                         * Includes signature check and decryption.
                         *
                         * @param {string} signedMsg
                         * @param {string} hashedPassword
                         * @param {string} salt
                         * @param {int} backwardCompatibleAttempt
                         * @param {string} originalPassword
                         *
                         * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                         */
                        async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                            const encryptedHMAC = signedMsg.substring(0, 64);
                            const encryptedMsg = signedMsg.substring(64);
                            const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                            if (decryptedHMAC !== encryptedHMAC) {
                                // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                                // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                                originalPassword = originalPassword || hashedPassword;
                                if (backwardCompatibleAttempt === 0) {
                                    const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }
                                if (backwardCompatibleAttempt === 1) {
                                    let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                                    updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }

                                return { success: false, message: "Signature mismatch" };
                            }

                            return {
                                success: true,
                                decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                            };
                        }
                        exports.decode = decode;

                        return exports;
                    }
                    exports.init = init;

                    return exports;
                })());
                const decode = codec.init(cryptoEngine).decode;

                /**
                 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
                 *
                 * @param {{
                 *  staticryptEncryptedMsgUniqueVariableName: string,
                 *  isRememberEnabled: boolean,
                 *  rememberDurationInDays: number,
                 *  staticryptSaltUniqueVariableName: string,
                 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
                 *
                 * @param {{
                 *  rememberExpirationKey: string,
                 *  rememberPassphraseKey: string,
                 *  replaceHtmlCallback: function,
                 *  clearLocalStorageCallback: function,
                 * }} templateConfig - object of data that can be configured by a custom password_template.
                 */
                function init(staticryptConfig, templateConfig) {
                    const exports = {};

                    /**
                     * Decrypt our encrypted page, replace the whole HTML.
                     *
                     * @param {string} hashedPassword
                     * @returns {Promise<boolean>}
                     */
                    async function decryptAndReplaceHtml(hashedPassword) {
                        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                        const { replaceHtmlCallback } = templateConfig;

                        const result = await decode(
                            staticryptEncryptedMsgUniqueVariableName,
                            hashedPassword,
                            staticryptSaltUniqueVariableName
                        );
                        if (!result.success) {
                            return false;
                        }
                        const plainHTML = result.decoded;

                        // if the user configured a callback call it, otherwise just replace the whole HTML
                        if (typeof replaceHtmlCallback === "function") {
                            replaceHtmlCallback(plainHTML);
                        } else {
                            document.write(plainHTML);
                            document.close();
                        }

                        return true;
                    }

                    /**
                     * Attempt to decrypt the page and replace the whole HTML.
                     *
                     * @param {string} password
                     * @param {boolean} isRememberChecked
                     *
                     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
                     *   expose more information in the future we can do it without breaking the password_template
                     */
                    async function handleDecryptionOfPage(password, isRememberChecked) {
                        const { staticryptSaltUniqueVariableName } = staticryptConfig;

                        // decrypt and replace the whole page
                        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
                    }
                    exports.handleDecryptionOfPage = handleDecryptionOfPage;

                    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                        if (!isDecryptionSuccessful) {
                            return {
                                isSuccessful: false,
                                hashedPassword,
                            };
                        }

                        // remember the hashedPassword and set its expiration if necessary
                        if (isRememberEnabled && isRememberChecked) {
                            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                            // set the expiration if the duration isn't 0 (meaning no expiration)
                            if (rememberDurationInDays > 0) {
                                window.localStorage.setItem(
                                    rememberExpirationKey,
                                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                                );
                            }
                        }

                        return {
                            isSuccessful: true,
                            hashedPassword,
                        };
                    }
                    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

                    /**
                     * Clear localstorage from staticrypt related values
                     */
                    function clearLocalStorage() {
                        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        if (typeof clearLocalStorageCallback === "function") {
                            clearLocalStorageCallback();
                        } else {
                            localStorage.removeItem(rememberPassphraseKey);
                            localStorage.removeItem(rememberExpirationKey);
                        }
                    }

                    async function handleDecryptOnLoad() {
                        let isSuccessful = await decryptOnLoadFromUrl();

                        if (!isSuccessful) {
                            isSuccessful = await decryptOnLoadFromRememberMe();
                        }

                        return { isSuccessful };
                    }
                    exports.handleDecryptOnLoad = handleDecryptOnLoad;

                    /**
                     * Clear storage if we are logging out
                     *
                     * @returns {boolean} - whether we logged out
                     */
                    function logoutIfNeeded() {
                        const logoutKey = "staticrypt_logout";

                        // handle logout through query param
                        const queryParams = new URLSearchParams(window.location.search);
                        if (queryParams.has(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        // handle logout through URL fragment
                        const hash = window.location.hash.substring(1);
                        if (hash.includes(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        return false;
                    }

                    /**
                     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
                     * try to do it if needed.
                     *
                     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
                     */
                    async function decryptOnLoadFromRememberMe() {
                        const { rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        // if we are login out, terminate
                        if (logoutIfNeeded()) {
                            return false;
                        }

                        // if there is expiration configured, check if we're not beyond the expiration
                        if (rememberDurationInDays && rememberDurationInDays > 0) {
                            const expiration = localStorage.getItem(rememberExpirationKey),
                                isExpired = expiration && new Date().getTime() > parseInt(expiration);

                            if (isExpired) {
                                clearLocalStorage();
                                return false;
                            }
                        }

                        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                        if (hashedPassword) {
                            // try to decrypt
                            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                            // the user fill the password form again
                            if (!isDecryptionSuccessful) {
                                clearLocalStorage();
                                return false;
                            }

                            return true;
                        }

                        return false;
                    }

                    async function decryptOnLoadFromUrl() {
                        const passwordKey = "staticrypt_pwd";
                        const rememberMeKey = "remember_me";

                        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                        // since it sends the hashed password to the server which isn't needed)
                        const queryParams = new URLSearchParams(window.location.search);
                        const hashedPasswordQuery = queryParams.get(passwordKey);
                        const rememberMeQuery = queryParams.get(rememberMeKey);

                        const urlFragment = window.location.hash.substring(1);
                        // get the password from the url fragment
                        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                        const rememberMeFragment = urlFragment.includes(rememberMeKey);

                        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                        const rememberMe = rememberMeFragment || rememberMeQuery;

                        if (hashedPassword) {
                            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                        }

                        return false;
                    }

                    return exports;
                }
                exports.init = init;

                return exports;
            })());
        ;
        const templateError = "template_error",
            templateToggleAltShow = "template_toggle_show",
            templateToggleAltHide = "template_toggle_hide",
            isRememberEnabled = true,
            staticryptConfig = { "staticryptEncryptedMsgUniqueVariableName": "2706317a326cc47deb0a03b889076bde169bff1bd5f725df6ebb97842070ce339436dc4541f5fd3ecfbabc2003c05764fb8ce9c9424aea88c038e3bee2a7a2c048a26fd3a06ecbff51dd4b0ed658d3ad0d39f9d85e0b627007970c18fd08c36606652e70b792c4dd568e554ed35810f923ecc363cf50ab6b86b44e878526a09ac2d7134e9bf0da9bc283994397a9d9f5874b408e2f732a39efa3d19604f76f0b4256d6edc62486af8e9f6f165c482225350daadc26b20164ce8841bc473823464dd3f2ed957d5b723a1407dd6dac837a84caf79cb9ec252cb483cd92ebc1e02b56f91e4b528be575a36676d68692a7d1bdde182ff1f22f53ecdfc61ed4fa57a8d76a4d39d35e135b774afd81795c41197a09c85b291670deebc5ba3f86c2d91e65682b82d73f3d6d4e716fdc6d4248df27c95b39991205e8cee68a09d157573c026e17339fbaa24731eca4a1bc54245a270d7fcd3c0dcb4d5113fa1bb56054f43ab9e7b349a3790dba12d5aecd04f4d280f5573a1c9390f51c612362f4937639131de9825f731751b649e4cf5c638b3212ea32d48921c9203b2e61fd5cf69431ce8ad3b0914d151e0ba8d5a0f4434965738dc1707199ef6ed0d6ac0178e0431af16acd2eaa0c0f0648bb9f3dfc1d8a98e9edb0eaff9bbafe87755bf8105be0935629ffe4e9ef477407f794bf7b4ea79cbc57b48330ea3b6ea834f46111906d6bc95e05398c1407e17a635ea4b0fd254d7222027e834c3892a3e9e34b9ba52a65a0b3f9c6c7d976acbb3016f69fd83f4a1ec792419267c1481a260f12927342d3928b33ef58f0d91a59a431849fe9dafe909e68164804ead01086274bc555fa4fbf7b1c59012da876bcf7a635ef6498945a7bc9a84f8f184108715a95dddd186338d398fd34f094d79fa1feff37066df7ffa8dca94b3b6345f3609e36ac45a471ab9c9cd5d349775c4a68d3d5ca7d69d071e316620f47e65675a1978243b05603099f89137b66c17bc6e92b3b3873a52bc8aab9960064ccec81173e22aa0a4334c2b3e03f3ee7b15ebc451bb4e54f510d87574050c50c1712feb74cb32a898909044af3ce8430c52b62315d7e0e2a10152f8e16db2acb9d08672c7524b450af292279028c8efb5d648c16bbb1f30de5667728d80919683d3a08724c9370a33c622cf9d3b37a5c694b0f1f15ea66b4c3fad4ce3d8b75041742e7e663d17b3708a9d5c2b52a4a5b1e7192490ce776518fab6549d8da280bb8fe8bdb6d041be85be0baa1e9a1324039d8bb0468130f8626eb3aeb8176234302e9457ead57b50407fced1c1859b5b66070232dc7abff7e78fb768310bab829c8a3a3124d478021c06818c43ef5b441b759c3d00b3bd52a66489adc0e4f7626719f4751fb7a43c399b00d04bc904ef01d1ced91238cf041ba9bc441d8ce085c5271136d098785ba0875e4eca965aa706ead55765776e1c60e6b8960ed2bd187340857da5ca17a5aa1303e7f0645aa9daf76dd873db586c31c7bfc266fb0ecb2e904bef0762aa809f98d89c880768d1cad472cdb476a5e8c1d69ce3982f6b50a31342b4399a6ee42ab3eb6b484928458318d75177b43eb0471f2b4b61e5fc03d1ab6fdd37f72893bf19feb57ed79587f963bcb3afa5d5325f667f7cfb2f4012a8c015d28ad536f2683c81a86ee4188edf33a3919520387054cce9edbe8c0931f5b036fdc82c7adad85947beb5ea680c7f9814676eac03b0bd38c32fa72fb70a9670147f410a1264318babbc2db0dbe0e62d016622aa74185b95640c6a00f3112a1a28672331037500574c3c0510e76f2f030a601499469bb4b6ccb6d7413e8e57fa2e967e1f12d00d24f4048f291d5b9d3afb65b0d2a93da7feb5fc4e6bbe882dd1235505913deda86714c4c47a4792503e360453bad09d5389621ea1ce9f0c40712b212b51510fb2986d26a664fdf2423ede928a69932d01f1f36a36034bd6c3eaf5e708eb87a99b073c3d2fb09a9e90f3002263ff82b3bf8ee834d109c961870e20652c56df06147b593ce5922d440c5cbbe87b9d3242b4addb7faf58f7f72643c9c56a6620f37798df0c2932c9519340c0087f478598de095dea9e925a4985ce2fa6d3ed934193797d32917738d63c7914f7cb3e8ba3636afc807dd39cbcf12d985512de6494a9330f8bd632dcbce9bc1afbb61e31c0410918d16521d0c40789e4fc6c5b9482b1ce9e612afdc2c3ead9dfa574be9b5fd3406bf69873d494e93f775cb5fa3bae9742d63d24e6a1c3684619a015aa9825cc3c52c9ecc2c7815c384d257b0ab259f955d37dc312043c7029489a6a6f243b2ba9bb7f1e578656215ed82232a99ea71a7bfa40ef342121a23bce485c9c681e74850b5333d33a954048301b7f12851ff9a9134d3650515f5af73f4b8bf580ece720e21669f76cf495fecd9f2a38d2ae9e14c771b256d3f5c6f27481f687856444d1c3077b05c8dd97158a1ddcc8d9d6c954c1dc63dfbcf71088fc2c22a4a5b769cc109720eb2f9e267c8775ac5e3133c2a76e7ae2d035056db3c77cf4e38ceb641d07dddf9c265c1e98e2b4da332f71c742a2de33ec1b3ad937c8106637da641cd38f02e1f6ff4ac36784b0a9259a7d40100f48c03c31a5d9f09c67ba2671945848df67fb22e0413abe2a4e9062e47a3eb6a403333e97cd3b56fd61d99dc59d04eea4a0d601b698366ced7e35563c79b124025c149b3df6b2ec7af7224ac64228a6b4d2e4e609809ff769b20cc4a53e647e8a4cdfd47c6dab0d1c4c6a6c649cee1ddbf02f44939cae31cb889061b5423bfe100e2818ff3d8c231076c03ee7314c7bce03e18fad12ef2faed794ed323ba06680dcf1f49a1c1ebef8ee4f379861bdded759802c1bd9f82986ee7bcbc661186d019251cbfac04cc5e374cbad87fd6d18d77ae897f46ed533457e8072baa2b5421941a1055e385f74d68ea7f7543a7a5888fea496a2ad474a0052b1a2089af3286725a531d54a8569bfaa8996562988d44a66eb84289a75df73da79ae80115b6d6f9adcf0e178a14d1ebf34a77b22ce8cc8187007d1d89bbc1267ef1bcaa820c2f4f6f6d7d4f605d3d8018880a49b520c547c620f1cdbcb34f1246a861c32341fa03d65757808f5f2be652a94f670d52a349c1f539fedbafbe80ec861cb683e225d98ab4fff2f3b0bfc98706d1d8b46dbb1c4c9f833f86843bda6e96262ced7fa203df561bfa59f4624b475ca8d178f6fea1f1abab13d3d9273f139fc0f3a35559e341485c8536b8667a993aff6c57a6d985a7975f351c7941a6c093e699089b04979715cbb6bb3a2575c05904735e40f4c17e34ce0351665c503b6ba456b9b8c9b6308d4764e7f673975ab282656c265586370b6c3ebfad132b2ded5b78a6fba9eb65fa8999ec16214d78d2a239f3df9512f63a66d0d883f9f1ac7066b786d0241288b23434a7011b85d8664c9e1dc065c336f9d24c8c7029b80a21b57b6f867407680f1b9287a14f615371bc6d5da0573ab4066c6baa2792495b0ed0d8a816af3b40d250c2535085bc59a09ed747a24576e50dc89572f875270b088b603576d1d74a284c2f305291d44cd5c2f3c8ff65e34ea40100d26684cfc2923c039305344c5cf491b3768b020b021bd9b0c5ee4709e2d50f7d0f47ef08e7b6592736d14293f0846ff3d312a1b2f98c9edbcfa7c102c4a2082789e186480b0b4f7e8d8084145ab75ed63b7f7d4ea1db8c29f103b3a7e8817a9060343b13137ecc4194f8e2593bce7a4a11ec3bb8c365a5712913726ae89ebbb342407f30b3cbefe3437eaaad16c4a10a0e711118849aaa0b0fa5dd155742dddcc692573eab4cd64aa84afd16b7ca6f7eccaaabceff92b120782de2b6163b229d30985c9c5cfd45221e218dd5e623ceb4dce96bf384554a73c87775a8517cc882a80f2de0f839455a4dab5bde62602711a38648108e66bd9813646e0c1c2395fd10e15d1559246a8d1d25c7dfeda9f0e18a86c745afe16603a426be0d616af61e6d2891f4adb20a9bcdebbdc4697fd611b8c230c71a69c5612d36a2882f74137dc3fbaf24b85fd6712f6296a0e76b0bf62634de802953e6dba153d83831e0490dc0d165563a57196aac29dc2a4490cb212ac5704cc0f9d8fdff45d2426e20c91c958e10b575cb0fd544c9adf558b5f2adc74bd06596f8d1aa3ce1cf6b579c017f32932072880c71dff8023fdd3b5d6f90cdae0a303daa0c4f995d8a507fcf2bae6d591d1d3bf365e5767d8adf3dec0b97923be31f958a8fadba3744ba05f19232fdc759c0289f5c728a239a8b81127afca0d5ef2764c28cb16f46ef595a7192fae8546373e8301650bb4306b695d4ee5782476df0f3cdb2422a1b0a6311ebecdeab46ec571f62ad8e92dee6df265f66ca962f93a2288009a95b61cbd0ccc27d28be62348cfdf1137f5b7a612b9e5c7044b1f256b574ee296a6558d205b7872f665475e74a5e98b20d18fbefab2c33044fc31d846bb97ff72720247f2398a87846c9bf7af8539b383a4ab3f0d691f8f18b259a6085eb313c35e0e6d8d980ccf1829ba294ff95743ef98717b360dfb111af4485c25af1373ee039a686cdea1bb850ad0cfe16bcea9484c5cf5cd634cde75d66def5168ea527364d7fddaef7fb1762aeeb73d40fd4c12be13d2ada7b50212020d5227a32bad166998db2c68a4f5472cabf22250f123a9b70fa83f76f4945860278af0c12c3786e35ecdcfc69827d2c9069ebbb68a358ca37c8f0d726733a871ea50ad686c6c56fa4d86d794d20c15a6d08430c08a97eaace16b312c52f2f5be0bd2f05ea307e13f41a2c88a5378287e2675c68796d82fd8271754094316f55c8e2be3b5c76753eff14ebb239b88a9e840eb11ce78d8731ccc4405e122c21906b0bda66e5d28347e44286efd966190579e6ef0465e3408fa07b9f763d0495098d63e8a6205023d9562bfeb14b4c95a0dc4d5b9159c3aaca63bf19968106234b2e39c66450c4dd822c74e4c9cf278b273793c888999422fb535710000d141fd169c00397da488e2d01ae0718a223f4b103d14914fd4939d3398f3b903bd01224ee31ace654091cdf1e4518266ea570e3f779d35c41e0b5168ca70f2b263eedad531affd56a7c4146ff465c36cb5b2b32b358aaa26ab97ef6efc58297ddc03be75714f7466b5502a54f2fab0d852a0b720c33e1ff4e9b7c118376c50ce442d54db12d276c11f7230727fc3c185fe8c7448bb5ae0955b75e08132e20d41a1b3c857c6df84d35388e6fe2daadcf0a13e0aa67a4816920b3874705da77e68cac63ff3b8a7f5620a58222e7e6fececf62ccc6f040607590036ea906401838bcf321d3aa96a703ca9657422969feb460b7bd088968a1714fa39d62a0e152110ca382feb450d790537aabfb38338df8243c9d675afb0efaf000b509520cbbcaff9b4f38d6666940b95299e743a2e227d634387913697d7519d60dd688f21504972bb7ba03e223c627def36bb97225a03c97cac4ec1249afeb8624a878ae2ff878b1d60b0a140940dadb86a2cb2f7ac824acf6f1872ada51cf7ba80df29e6d8e4e5fe040ef1d3a0fd509fc17745451a3014fc64d6a80dc1142bab5dca20f37f7b837a2b9e49eafb912cefd6179ec16e8836e4abc4aaf18ba0ebab4765a5ba9b80031744ff2c5ffe233f07058d3890d44a799b9a0fe0e58217e3fb0651867638c05fa4f223de3d27ff4a2fda1e14535ca3f1626b06a503e481cc6c717fbf353333815002f520226df1b75b66861b8ea0f437f21697a9d8fc162a92868d8b5e22c49cf00a47c31aad858a0dd035f8d20e10a022ca04438098f5f45b86a3042872f11c07fb4fac2e6cab5aefa37d1a81c0e3d04c7a1ffb5271fbe08bc420b3e78bcd00e27b9dc9a093f3164bc256e0c76078136b2ada29ee0f3da0249d4ab2975390336a092a5ef4190c6a572f1c8dbb2429ec18c22c6b050ba9726da82005952d836db362a980be6c997db6d81561d57c69e9c352dffd2cd003e03de1651d35ac8ffcf0d909ce628c2b701314b2c2b29fd29bd8d34d2c8a56757d00fb1c27637cf98f69b8c15e3bc8f9ee68430600ec5da1f0810293fc5c72a956d3f135b862c4c09fee717bb0fbce07187e9f1c863b99cbaa62188ad8d8d6a71bc84a605001fdda921f7bd5e8aad951d5bca9b6fb24b43456dd56ae753cc2d15b8a99e672d717b06e713383b6fb4df48ee5f8a0c06c87f901e709144a2ff11504f5cb50a23c9196c7c17d50feab2e8e7a3ffb17e4235e2e605f3b9bd726b8b21d5d6f5b7800c827df84992bc50d38d0bfde3fcb1683759970a4205ea3fd2c59d650253f59e20bf833b3feceb5185dbf41fa9f7e4dc7e4fb5beead138e68f7c945deaf543f58d7dcaa6f73b8cd64516dafd4ade3c64863f57c09da3c9991120d80c26732b42e6de489d9ce3625e5a71db119869334069e461ae748e6987ab0c11745135f571c287d6d11af57f95f5974f7af0f36486a7c4bf8abae372dfea1674a00ec015ce8d746791c1b33f748dc543037c21e9d13ffa14187ef6863087cb605bc11eeae4f93e40189e338d3945ca90557166c6e53786a0756136de516c3aeafcaf01476967669b336711ee50a4d6ea5d2acb8d813f7a8b51299a58b05380d260465a42077d7749dec87677554e294917df361ff210a8afa96e6f7e3048ea8d09a93b9a5554698323de3f0964319624aed77ec34978338b2e405347e94724f60344ffaed617f4d1917a678b0cc512bce80de3ee5496095e716a7df8aff74ecbadff47857b680fe8aabeebda48af5a3b17874e1e76db6979d2518a32638f9a852f17db4f43e32cab5cd994805c5c9d0e9438fc4bcddbb207a445ae44c2249d4010ddfd4bca96c84ab2effd50e0a1651fb5e0f0bce8efed4fc5c2d49945ef939fe239221b999edfa4f3ccea68a739258bfbbf3347cce18384d49a2717532c25c1efab1f7f53d01bec98300537e9afc925edd1b3648af82176db40690101b0197df4522d946cec80e8041b1fde3909d2c4ef96edd0e6da6760f85f4d5011547d2ebca1f2874d9236b5a9df12bfab882b111cb36a28d1f9745b2394e27022ba168511bef883ca6b90058b00ef12f6a1a6e15865b4705c2e1584abb4d623448bf7dc540513ce63329e6df19ab30bdc8f94e90d6bc6252e9e5fc626631722058fb5277b171ba7aadd4790c2c37a0a8bc432e13cdad757c43eba43069698040446900bdbc214c6dda39cbc49ef0b7e55b3a60b3b4fc6f4373c68f1d87a4e940d45baf4e00889fbf06ed44eac99cf6539aaed23662b4eea21afc127718fe5bfa2d05b73938bce5de5fc17b899ac07b63924aa2d89bb48a1a1b5c5fcfcfbd7ec35ca0670af9621b5f20545f6a768159a1917a50a7a49830eb537418f4e8fc5ab0197d866a60aa61a53a886db48ed24fe918a158f3064574bbf5c0d0279d4e28b22cbf705afd8e7292b36c33a79a3d441cf51ffbd44a7ae161c8ff65f057578096e6b6d277c63c9cbd9786b97fc29da8c4aeacec4bc59ba97b30ba847d93023b2eb5d4e8b7d3ae08cfbfc8dfe85d00728734d579905fc0ca87a1e078ca40bfa58e6c3c4547765929ca9e9247e9077b7cca930c6080206c1643b10cd5f0191bcd28cab3e32936de00c5eeb9f104b4e92098f38ae0ad0ec6f496be7428871ee1d20eb8e856e285696e2d1668bee4746c75bfdc00b4c2046d5c74ae1ee81ab475628a0f810a26c524570a38a03adfda2d692a416c743f53423f7325580a2259ab761af9b96296df798b8a02947df7601ebb262688b974fd8543af919645bfddef1b1dd5254fd020ac40a7f6b666963053f74756acc9890a3b70ac4d2f449a9ee2691210da5189d5d6386d07b5f02fb94a6579b9de0ccee7408f6604067105a37705482227ed84a556ad3d3b13c162e4ceca957c93e6beb96ca901721ab0ebe5c0fec173f0fb347f6fa48552a55ca4a80a2f8e839709886d62f2e97f25df155b921109ec196cd9d4ad399c093e9a147a039fc6ae00f6c1c8e9bc95913d74ca9b9075a5d99582636cd2f573b313d7990e10239f0fed930c68a950f922ba8ce3a6b6e351cd84069c6439647d4f88bbd3e0f99960042b1b10daa9bb764aa868d5b4692d16ee6421508b29f8f87b20444b10605ad3c1c9919f8b66cc04dd05ca77f0835167c421421d622995dd6ab750cabc8ff529b2e812aad3aa38bf181ec00cfc3ba01b107203420cdb31858680f6ba9c16492834cbdae750c837f7d53f1a4a2574967830288dee930e3574d3594b3568b4f99c990de744db8ba70bdc58d6b6e4637f0d542521d600af26e54d4c94bc29a0a35351f9f1cccb2d923f2980e3ed1e85c38e56e6507188c971aeb944f310aea5bfd7298484b51e4b3a048b54b07c8325b8d70a02577ff9a51b850e7fd604bb00fdce832b2dab2b31261e5cfaabb311939683cd80894f6257f081a29df656c926aa009ef3809c6475bd10e0da9d2eb3e13e9845b5df4efdbc7934f8e6ba175c043c1f22f092260c634a2ea3a66378baf8445b090354c5dac3fde34b3e64a56867300a9411233a2d82285ef03009665defe4d18a3beb66d279958a69480220fbd1766d8addc9f1a3ca1072a502f255f8e4ef329d52c35c7d51c5c3385545023a8936a7866d5ddedddc60f77c41b7febb2bdbfa7e33bcaef6c802031c59f3df42d9d7d08d8f4185220ede953c93ed884f6a4d59165df9a273e2db94b08eeef97b6570a6b84b2a4ca76d3b0159bcff954b2912b757c7fa9f049ccb6058ee8b229d050214b6a32ef1671b48f2c68d8c18c88ce5fa4ffeb0d9c2755a3b5fb659d1ae610916f2696e74aa57f46f40de1b0fe45493528bc39602fbc2e8ad2c914b384fd42ff2b1231ce775bffc2df4d9ca89366575fa6d24a866094095dab9fc058136cafdc2a586b6f570257c32a22bf34e900b5abe3881d9187a4b8f2e254b11664768ce3d3687e1b736c7b9576cff3c4b786dc25111134878c7c3090ce1f7357c1e32192f7da3aaaf3b7e02c4a7b29dd50221cdb7327de199894de18cc189cf692b4ea2a5ec14e862dbcdf5ff6283e8e232bf68816962d99d3f0fb000298496a3820d740f9c23d2ba298ad9c07ead051bbbe9b2c9babe3409712ec5bcc968cde53956f6cbf155b2b05e2bf50d24345db1804ff91404fd2fe4ff584bc3ad1d6931a55577ef20c7a1b0e471f9ee4d14e41232ea9ee9c7448e6db12f0146d217e3f7c9698b461c2a6d83808821260865a844ce8f99cc54797392f6008863369182ef1bedc7a4109cdda563cf4af3a6af7c17be51d0437036fa011758d256bf4e43ec7a29450d4aa21c49e16db3a8d809a6cc6ef54ad99ec55e672f0fabf717ebc5bd23326bea02de839cb5dbe1a5bf17fb15ffa8ec330de9f7adff259df33d7723d85e5c74d213eb47c555bdd8c27e1cbec9adc1308f15a94c91e2402a5645f7f690204500f53fa34765e18ffbdae62e89a7bea2f155fba24319e24970df7c6bff91a4e65d5f4515e977550be3c2d5d0eb5233f26a25a2ea94cd57e7dab93bfb7dd5f530672c7b3a7d100c6200b68fe527928f240467d58574d8355edfe299f6ad9f6a423650b4e14b666549c045000525e9524698237f772eec7abb7e49c969286f8a62cfa1a1b310b5a3fe2cb8fc206c5ae522994143c216558e1c53d46ecb671f52156cc20ad1cc6d14b8b9670680e3b01232d27bd875a415e074c37c8521c285d1048a54313852684bf8e7bea6ca5c78a6d0194cb1ee36bb2c36a206f33b52a1f990aca58023f9a46ab06f7f834eaf8f5156ee325b30ba78773adb029c38d4149c998338493351bdd2146184a53e165843a401a0da5677e0e324b04908259c5c15b4003a18068a0a5f9407fc0549177d4a3b6bf69fc955de99060b91604b1c7eac17109d3e37cf886be9294c97f1c3b9e2d1b44a94473cfb9a3e8381318da541832ff572161a2f255b4c1b474f59bd03d87a1e965a902e1d9942cf874d6689741ff4ac312eefa91ad5b9bae18d2bbbaea7f5bef0cd4a922e01a8e05bb8ef751e808ad20b9b0ee733f01ca33b100edbf82cdca3fb3729b744bca937b23e26a0d5da6b8ee246c784834229916a1147b214412cdd9c82a69efef90a20f84b0b5a3a909a2c25b0bdefaa0b07dce02e1b842ccf2e6d12ac892397d08861031d04a729d76ffe7c57775d644035b9e31d042309fc733d0dc162a72efb0525e8e941fc85b48b048212f62a388308988f5ba0ba60f10ecf985f31c7faadc649edec2235609318261d90a03561e0f3815cf8f8a721595d39d6876219fd97d523c98656086340749fd013dad1e95caf0f0a121bca994984b7ce3d9543cf264190e082242fb2240449e41d9b854db5448c40d7287fa0a57f851c41e7b224dae103e9df14f1031a613d15867611665c3f70a4fd90facebccc57fef00bfc7f5d7af8c950bc61d799c66594c30f3ebc6a7a7876393266828042790c540cb11f4f63e7816e46ec90db693de6043547be212b26f932c94547b605c75596bc99725f1e644daca1e9799a44f8efaa66d8033c32bd289e076429712e2c5c6340d72aa555f4a50b21a16701d7970507fb99318186c9fd5e740feee63533716dda130b8c96eda38cdd62e07c2be1b3d1788fdbf58a32502511de2f12331b8245214df0542a78781c86ee92f2d65fc1c3718bd30c3ced2be785cc7449c6ffdec07bdf620a16b5acd361a3d885f884ca8be51a637b6137e352f3c76608386802697ae909c1b1bff73e1e1aecef24f021c72fea1847121c0c008566db77b12c4b4cf8a36ec5979ff837235d094bc1c9462e595610b6626ed1e0ed06213a7243ceea83feeb35b473ab8caf7897ecc3b87473d42a27335fa840b9a2b0e850337f526b83869732ff3663c7bdcfb561a375ca8ccb97bf2055ea820a9a591f347a2543ce988d95f74d09de0a62d3161d9cb8aa81e9483d6c85f73c48c54279ddc8a6fda2c7e27566235ff768f9f42ae0278d4828ed45eebca9ca4c164ea26aa0eb13dc3aa004e3428f7e692097456e6fcd90c8d4c67272614ba5e391671ae656432dd1f5b4fd08b518bdb3f9579cfbc69e4601bf21ada54524865e15e2caf568e95b94cd42eb06b00aa684b2b4a48485d08b126857b3f8c85e49ad2aeb84d0873102bb9486e3f58f5a13dcd14a7f16221ba05582b70ce84ee8b69b9b91fa129a2fe2bb4b8ab464b2c9f00e9fa2b379d5c983633ea95d95c63d215f479c49533a2410b84afc6dc3d3781a8786aaacc09ab1ef6f7e2111af2fb04eb1317079e529a9566f615fa3b7141336ecf422ca218623d839e2fff3dacbf994a8180c0a9cb5d98b0e90298f8f622faef855daf8d4165ae8222f1ef08037a6b22eaf8a75260bd2d442cd3b03ab674d41648e65d3f0849b1f9be54829e59cdea5f5a5b4eb544c663f07220523899fd46d15d8653b5d204b718dca2f7e31af82868ff4a82d886a55d9b1698fe4feb35d80c9c6da685782287a4f844a06beb802cf94183abf6b7ec73a5fc1017ec92493717a714220cc3f0479b9cebadb91ae2502dd2703411cf47d806467ce62e6f746a5989777b942e6ac17a15e32426a6d8286d4a8a102212f28cdd24beff4eb608383ce3fb6586ea67e42aa9ad1712e67577f1e4eb09aae62b91ee540ddbf77f2dbd5c5993ba784a079c66ce98308ece6d35ac855265da1017c56675b576b8f7b49c817d0779ebc39a1488242ce6181a44a7dd90e6751eb59320a8077821dda023eca8efc79e6a17ae7fb818642c7f63ba8f7c7b02d7be03bf4149510b76b2e0710bc551d358c86e4c81c9959dcde47a6c3a64821b168d04919efb1da72269edac8965e44b97794d00a4d790ee6d570c7b0469d0732c7cc8bc696ff2d735e261bc649cb19494533681b250e115d0543e014a06359d2151a96f21a83397bb160ec1ca3e93b9650a65dbb20f92a1bcd789be5c004bfcd6b007f1c199dc11fbd5fc5b003c2a18236d3848d37629435dbd7e031d29061d79fce93201cdda224531fbdd9011b0ba64e6ad0d8a12e068648bb8d2a20d35a2e14885f8a5549be96d4292a7ad877ce29b5fbde7dd8df90e425a7295c78da177d11ebb400ea992779e7651da37ccf316fff6df2d86e6faa950e8ec3f072d3a9d702bb1fc8801d97924016346f30c1966d231ad1119b06c0f7c46f30b4358204f7f0bfb94e544989b116676deaeeac9dfcd889beec20e29faa329d650bca64e32ac9545fda5dae8a60f07e5e6e6caffc6fa843422df3803432fe725f64aa1febdff792c6c9fd9f5024b041224beb87d2ddc44eeb341123264dbacc6bbdddbb55d3c5409da0637bce1668b6277f2f6b075761e7ad1b48a4a8cc1b5f63d175919184bc50ec313680bbf801d938a6ff72aadbe73aa719c65b7d807a6591d1f7e5aa4ebb5988cab21bab19fbc3ae26390a6113a6b39011f86fa8e40d240496a6e657d824216ef095e52ddd0e3afd6583533ee953f51e9de3fe33175bebe9502d0c113f725fd856f36ab46fd3da5c77ad5182bb013280baac21e877eae0ec2887cf1def0262d2d6b307781d02e2612619dc8661b80d463b173e8b1251c1a197bf0db2c9a2367a01c239141659e2bcea59f4c3b9672e232fe8d0e69b273fd214e733d23d6c22d94c7a409b4e9800692d2c66c586c836d81136c0bf851a8ef66af3a70880e8fec1412c78f85c4d33a336eaba381e50a56da16562bb111c76fd3561381719a42a0b702d5b90da400e2a09b4d2df8d65b002f3f42e5364b1522323f9003f859c39497491b0a5837e9330815108dddc7d49c76a20013b3db93ac2fb5bea799b0de6bf3bb54770477dad7eaebd54f4a755bd53769c06af64dfe42ddc5bf7863f07e2cccd9b906016560486d459f3095179c0da93d7f53b31b59c583a52f461a8aaf812950b65f48bf13130dc20ca2454daa9c0228609731ddbe5fa5ed9b51af3f8747eafd075a793a8c5490aa1505fcc70b20ed641993605e4dcb5fbb8cec21745a48a6c428ca86e2a59f22fc9322aac09bd7745603afa14469db449e726c7daed50b56579437a5ecce7431dd684060f1ed775888a344035104a28ba4ed0d7744170665bd5abe9742dd75f23cbe1835e52d7ac6bad5de7b187e1ae697437d863db4fd4a09b6c4d0420bf8b610a672a9c18c7c442dbd36ccf5c2a2ff2b64589454e44ce615a03d41b16407e292c6da3ff48ae6a383088a72617b5220e553681476ece630b495a08775623f64c66d0ea47354f47f5c68da973f0a49db408dd608e021cd5964af8442696da908d6892c65be3267eee15abda8087178dc9fdb1262e7996cc35ebfdef8435949c1a7df311c9f6c896741136928e2621c504e5eef96fb3e13a82cb9ad2cd11c7c99c34e6ab7b83cd17c7b3bd93b648411b806f5fc01c9de80b61360333fcd797742941615de4b59970aa7e35c33a916b8dedd2cdadf07f8ab1501c6a632261153eddb002aee740aff771a48365da7c9f3eb94e59902966ab6c19ea68a4c30c52eee429adbab5a4b77253ba68ac15ea3ba093a202e3757e156edf8eef841dc8a6581171aaf085b7208b19be3e2d06a7edc66c84b6bef9531240b279cf91d2f09c7e0f77326e52209a26254ee0c35d26233e410ce26a23b7761c271b6453ddedfa36f66997873f4504a7e9c4f821a999b615ef5687293d2f709b826f2dc312910cf9d19a3cb91f39eeb5c536998bf999302dbd2e1b8170e8b45782507e5ae70b806ecc9ae900aa0203a97d5bbc9a6a3959596e1ff921071ba3dc4bab4f5b362b6b1d4df7f6eb4ccde6f11fc318c0c4be97c95828752036c1da3fee6486e06baa19d4fc11279c1ff5f74abc168171c30ddd31babaf2e25cf0454fab27014894b6074bf8b101dfed4ebf149544ce1aabc9fc11b0cee5d8d7714e60ea906df28aa18a2d602740d14aacfd07d0aa702d58007c1c6d63dbf07f77f9e9ce71ee0e6e3c6392b9dfd271372438010fdbd74d3a8673c925937a993084e199abdbc1f9017550b7349964121ef98ee262cef632e8e8c395e6ab8a25927c5eaebef86752ab4be4e826974eed3cf8a6ffe673bff350850c129b8a64b6883177267442808a570d078292d616d3253643efe3d655d350b60637ba966f3991e6249db542b7319d6062c3be4ac8fa6c1a56d6f939a615ebd40a5e19f36b3a7a4849385447daffac78dd72d0471a4acdeba49f245e33826e1f244815a547eec9b1b0517a4dd5cf26dc67e7d8de57e62515b9372a1c4170ed1e9510aa7b149d7fbeb5a49de0102b679bbaa4121fe24b4ff2dd6fb96a5e853e483e81445c9fa877121872c3f718442627d4b16902e6fbf27445a5439487755a89832dfa2fca027ce2748006cb2f6628549ad4bbf33895820116dc0f0fe1ca9418c8727d59b1ad48daab4a93c3e9772f827962c5dd2caa925ea7356a5a8e9cfc0af1566a8694f3d2d6134608484a183e7d02fe1192bebff3bbd456591c3385f8f5fbc6c7aa80a0f770cfa87ad877b337315fb9e3a393abe1e1c33e17e9afc3e869efce8b3a3a0fc86bda42421e82ee0abac886fdcd098c3aad3d774995f0f1ef53d2582de2e15399d9aa31d4e0a7c299de96b4893daab540e3d9b0be62d007e398ebdf72267de3b285f5f416b3d749354208471b1dcc9c3c01537cf10bc912319a8e6f1018ea9a40fca45eed0e35853066742a6d55a66c7ef23f86699c5212407fdd29cde3f9a5dc4a778c74d4eab1b498b347c2c2bf590761dd1047f9a858c2b507a32b14eb04c9eb8f2fa29a46378cbe5622010b6dd7b0140e6ba66b9940270817c818ee5b7fdaedba12e6ebb9ca56c7a4facc8b3534396b265b8e0130e55074d2b9e09bab86241191fe71c4ddd59619afe54941ebc54c2d3ba9e47a64cf49881b8548247fb85242d6a4ab0e8a7d39bd1409992e21bbedf6202ce8fd8a1e864d69af821419d41aef432432a1978212bb145c5d3e47bc5eaca15799f16360eaabd09ddfb8c021bc0a678c95cb39b60ec6a736257ede04b31b62ae587ae9e0fb2066d4f4efe4f66ce4caaf8377de69222adde2e05f1bb5febdd205038e09981f49264a6982fe0b40b2dcea02af6352e1d8d2aa23e224f86eeed77a0176879ad1dd27b9f581034def0ce567438b67565f7c92570c5526a86979482ed79afd19d0250ee7bacea64667f4d2f564142d7816b43aa6bb6e487b05235e928f42263bd410d90802b5d942a201bbc4f353eed043feccddac16295ac586c49e893ec9ea8876f4afe037249bbe1d3fceae3caefa6a494c238985c775e6e55a393f64a0b30309b1dd06834e01ff14b348434aa8ec7fa44c72992bccc064745e08bf51fdbf299a7773213f2b99a286cac84ce517a3f5f006c8a5e500c191db56f2b8610d1d74f73baa4d55323e856e5d3a359908c6511dbc078693f805fdea20fbae50517347ee2572bec280a80ac58752f48045b4167ae5fe99a3c7ee329a55948f322844a9167b3e8ae4b14dd858aae1553772ea232d341a4083b0ddf42d17f13ff694ce2e4239268e42f8cad2cd01f8d0c2101c97910e05c2bd2c9a063ead9094e91778d4ef973b3efe60fb06b9d3813b71b6b9d607ef0635df8e5eadf0de57a1d92c196ccc4ffd1c48068c158e36f5bf1a528521b8b91e98c34a9ac65bc6b8314bb69c5e5866eeb78a3fd20e5108401219d93d458fbde2285442723db529834525ff658246dad40188a3cbdf14a17f9c56e8499a8d55ce662a2b783037f8860a189ea23a0247909b1386c4c4c2201de5584b7e6e34654fc6c411eedb67017418eb6a0b2462b67b83d82a3ba150f8bf89970b4c440ff577d1fc97035e738eb20db6ad9039928c950b71e6c464238baf1c9f6d3047fbc959584f2148ec6dc45ed413f8adc0d67cc5a4e30953cfcfac02eb7f313b2400f62c5e746440be1805bd3fe26f1913afe936e81312777c6b41ede13b9a9b23965bfc07b89a28466d6b3ed81912addc8e37a77af574415da81016650097209b6b8ef3067ffa4fdb4c35ecad05b544bdbf203aa44b5772c5501757c4c0c9085e183c9051a0971b9a0ca6a8ea9f197dc2c789120ce2c75b2453ec1b80672da3f128488fa8ef02bc3b4a492618f5f9da36613d42c58975c4149edf1b4ead985a211b9ce44cec2c9af4f37743053eac26b20405cb96c18821c27b3baf9b8974f7142fe82a0a36eeb4de0c3d978c1d4d7ced5850f56747d22f9fe945e73c016714575c60355b83b0e3290699bf1592dca8c36097ca3d16e38231d407e740b60876efa5b00603e69973c702ae9d8e1b105095ab6198771fc88e41ec86438ac006e8643e1ca789e1dd527434615de16bc3217fc7ffbb207e06ae2fd073946e047ccca8a68be4b517ccc11293f05e6a1b4d430db9ccdad65f76b82f57274e53b58537a14ab11a9207c0808aab3ec44105477af898d29f25fafaf5964d97c55adb606fcaa1316459ce9af38f9b11c641587262ab3fe45c53da0668185bd7ee55eaa548c130ac522490cd0cddd8c46d7e7321c59efb61589be372f1249987ee22d3f2ef10c0db065d4bd6af1988da539103ef8eb349cba8e5cda4f65c5a34c35887d55553df65da31cb8b884288ef218cb98eaba03c29a2e863b9dc7edb8946c975c1436e548ef411394f80f738de6cf2c9eac2cb8b598ae941a5d47ce9044b74491c0d91fe1f725331c26132c6b108da4a5a9db31af0a52b10d2d88d04d3924a5bd927b20855b5c4faabadf74b7390c659a8f38798526b038401c1eae3526425062f79d7476de7f22518e2b2c19626a45d02d39656fc3389ccf8ca0f561b801bc6fffa361de07050ec55a22abd886dd1cdaa95acec59090741c76ac8669df0bfc6f7f395fbd231a268078de723ae30b0c234555a8d6613b0db1fb2982ae46b7f358602573fd03c49b2ee972af60e6ddbb5cc65ca8133f0e2a3b5e7d2e6d1bf7d7708b3af2c9b6031e9087f98f8ce4e068ced370ddda18f9321fb1c81e5bfa9f44a6416ad5ba88345b55711b4700a035f3fac1b611537f0f4d6f5dbc3dc81d377b9ddddff5331430e8c3d3b55de0c0caa3dd71bd1b5ba1571ba468b099aaf3f0fa6f65bf2af1e0e3f5dd4f3cd543bcc213ea2fce1ca6d37a9f35216c4af1e6b96ba53717b968cbe4d84b8069c7c6fa7591266ae0e4544af6b63f849d598c6151c413cdb39836f5e3c46075fea16deee109a3832350d3dfc21bb9577d318977ab49ff953ff04f7b1b0c862cb6ada78bdf9bea2a24657a6a4c7285d50da8e53cebca40252857f1f7306af42946e546c4875758d33df28d70d2c4b0febcc0cf4888f8c295958c7d3e4bc40a85529930e48e58a9db71128750aa68b0fc390ceb8efdcbde2ae313c34bbbb6b769b9c9b222d1d3c11af60a999a8a2a4becee833eca7efd984087d7cc6e54f00488707aa3db9b8f2efcc11f635910d1c861288d8582a15c178d8dc6d6b82bb7ef3eea81f806f4c55e61c59e3d773427b6e9a1761d90dbad3296d6aaac77ac550a4b198d7dceaa7e360caaf23c053964c2df810b1e679af4524c11effaaa78e84479dbab12323b7f2a05ff85d4f9f2058e7786c6812e769136a5d26bdbf8b588e1b1ac5d8dfc4762794dce4e5a22af7ef02a16f1128b777d95b734582c5ffba881038123428b4affdebfd200f44dfd88f56c02d682656cafa08a4fe0ae55c8a77acb597430410e0075f51f6bc06a7bb9d01c843f716adb0800f4033d3612e8e48c1209e21d6f89c632e95fbaef4498f2342a30b4330e5cde75eaea7d78d4d5b88d024f9ff3fb49ee0490b041627ae91842c6314b6361b500766fa42f6d8446be032495aa8627390ebaf48701ed5377f84a3bf2bdde925ea509aa8c0dcfa49efdc62c2386e600bf135a54527fcfe58b585aaa6b6b6f81934e94bbaf0ccc4b9823f8591c48f75106982158c1f6aa9c69af8393086500944bf317c2e3fbb723fcb8edf81eff30566443709eabf713caa76fa523e5f3e4d16a3922c25ae62dbb62e115c7d4bc796d2f1864ee1802f3beac98ff724ea385b7c80760b3eb09ac3f8c1842e5e89ff5c0fe67c6ff32356ada7a9429b3b21a6d6bfd9d6dbb76b9627fd59167ee420885306521c1cea8ebfb143ec6592ffe7e0595a2382aa6bb1979fce1c0eb4e56f3beaffed7e382571fd3581b00ff932a9527f57ce27fb5799ead620190f0b54009db4da75d78b7f61b1f2c5b632a947283f209103827141af1de7dafd152312cb518904fb36d78c60603dad3d885e2bb4c504d4c06d3801ac079f8e49bd470a67030c2353a750aeabeff0ab687a82b6464d65463a47d0a6ff0260a62b4c2fdb8d77fdce4e4ce247f5faab3e7789be1a3f6f9cea2c6553ed7a32daa3c063fd1f1cb6530aa3c421efd5ae3daada976c5f2ecb260a9da8a9195f30cf132dc2822ea86c0a0c324a38b3e866fe8818fae0f0c1f52fbe0eb353ff80a4d2a092ec6fff997c139466967e69ed6c4a7622904e4b36730267f6a005eabcd50e4d4fb86acc157ac6749239ebcf62cfa33a3eb514203b9dd82d097dec22578b0f5e04780852c907081c0a62559ce7d3966710eb1ba8bacef6ff503cfea5124d5953f0cbbe3f2551a5a6b4cc9f8db27b85b92940c3623a1acb13eaff02a01196e84801e9fa71dd14c783be16d7640ab47b1a025f066f65c0363a31a1de08876608352ef2ccef1d5e9e6f5ac366efc27311f073cc128cefd30633a58fddcdabd9a756926d2a7bcd804430258ee917281edd203603641f0c2dcda582f9fea2f4def294851d287996a5d996f23043cc842f5e964bb207ce3451636769621911bebe814a9d50fad073c39f61de16a792c955643c3fc056e176e68ffb004e20029203b1ce485427cfe4b6e94603266b3d8b5cf01993d65865ab764dcef05a5f8208fea6352c772f95a9d7f5c34ac1a8188c0abbd10b400783e1d8c518bab41b88320e071f3b7d6f66d825bbadba84bee5c685d68e49b5d7bcfcfdddc7a32f431114893ec572a0714336d181b67f2c5e7b212ba9c9dc3c600c665682a7ee68997b301454a802117979250fda16a0a425ba08e76a4873f51ecf4445fe06bc835202519ed31efabb8712e556c8dad30df238276acdf8afdc540dda19594e609b6eda1727b74fe979826e1e4f217149d8a4d961b530fe299168776ebcf7ca65f18509502f55d7604768b44e1a908730128810b106827e8bf150a5bdab34e6da1e2f5f38b969d29c1331061af34889ca8ca87dc48553efbbb7b2c0269671560fc4e7bbdf6f1fffeadd1ee28996d39207bf1aeb1276aae5e237bfa465ba00d42dbe4f4436f54105fc1704d3e53722fbdc949e3a2ff879dc44e7b24409d64efc1b1b6616e19f1e23be12130b82474d3714d7a138ce0966d3755de910f45687946396872430c260d7dfa3d85988453b729dafe14bc107ac6c6ae788df58f4fd81394f2de8f6bec9a81816a38f8321b0de9cf3d42c6c0ac9001fb4d46aae6fd75803d9c2cd22279dce976806e7088ef59124a3a76a48881b6c0412ce08144b23e2ff84acbcadad4b610f71fdd9521e7215f992fcf3542e41d4436d3f9dd127c9b3204d9fca134928b96828ff1535455d1f36111ace09d13e056facb13b3e4ff86527ba549ebfdf62ea7f8f9f75fc7844d6543e2c8094f53ae9843a8c06b8411d093ed323c72a76045f073000f175289baea0333321e3825f8521e3989e9a888a36d4c50868a43cf0c4a2ad738b110fdd8624d73bdba86384cb8fd9de8ba210f872cd4fbd8e1bd5e56192ba8676150c65e6ff8ac7b68dfc5af54b75a864b4bafd5ae0c55328ed8204c3cd94ae93f8b20b4a07169a8d2b49cfbd8bdc4ead16ef5ecce5789a0fc5ec76ed325291d2f3df270b73bd783037b4ec825e2ddfbe5a20b4f04f97fa1fb9457fec7b4bbefd0ffe21748d86e83f843f353a522d8432d639d1d00c6406a6b3343936e05811b319eaaf25d05a87dc2d34522dac74c7e77426b570440f3fa351334bcbe50034987850393843aae0df64cc955b637c990df8a09663a353d6eacbc0fc5ee8a18fc81b244c4739108ed83aeefd6b229752cad97cc12a7fb2c0102c39a3611cdb06bca3fa730b6205d4e373a4bddb2cbeacc93226c78992456c7b8bacc93fc03a9e54d6e39c7a359cf441981aad6f06e635541221d991faf32e69d316289f4abf1e7cdc91d20a4331f38f134d4aa633321b7f873ce51a375a713969cb0e7345ee6cf8b4c2f3f40d4d4312b01ea601d60caec1a3863f515dfe77b452fd345930311cc48794713ddea2aad14c2c77d47c14a05bc651e82eb45f5ca1f9e71b1454ccd681bfaa002bc50de75f7227ef63753cba854f3eaf9d037a9fe3c7ba18854b464dc4da682f6458a5f1184706afdc8e7f8b645418b22b99978c2a8b03d5734ecd44c040d2e559cad8f1358759dfd43f64b3de6ebf369955117c4be38b9298299d21096195d73606d0514185caf35b2080dd07469a6fb009856dd49fffa97c5f63399bebf05f97f4e09fce28c576eec563978b05d3fd3a695f7dfb96d4448a07e130b59fb0844a81c95e2ee5f984f91811cb557a7056f0d5d952ecd81cd0988c37e5fdc1c30d45b752a2a92390fe9be33bd82fc7dc2b3feee8d2dd1adf9cf861b9a4e84635c425d7c8cf52730eebe4135f60bc003dc78140b3e15ee5a78d874928c2ae1837432ac9248eb8ddd2180c4844f378c122e8fa5f4cc37279d86a14217678846580320926a81ba5d65b113ada897a10c3a20d854ea743e661f83afe063f127fc57986e0cdc175e26f747cdbfd059f07f2f1ad817f997ec8a723bc0743d11ecfb50213638efe2abfb612da1373cfd3a51af9ac3fc232f2b9443c49b30631662d521de0a351fde396f31d0ec92ec4c0f2abc1af6abf6f83ce5adb9e85dc5244e6f518912ebd877dfcb47f34485b70ad4d938ef38ee9bcb8fa42567f9693a4fa41f3b5e5cc24610e28a8510bf0d7577e5227d4d81a575fb73ac39973af4c5c35693d1cc61ae8a0c25991afc3d23ccd1af6a21451f3e62373aa58d3482df2dadedf343e5b2bfc6d7aa9e6d291ae92ea76de61f98fa34202b7363d56bf2ccb5bc7c81d44e090db556a627ca866a23502017bc49c8ccf31722505dc83dfa64a4c1043117c53f72431c4087537ffbc06c4bd260b36ddf858c0a9f7cbe058675acb5531b", "isRememberEnabled": true, "rememberDurationInDays": 0, "staticryptSaltUniqueVariableName": "d44b10854605bfd782faca35cc84c591" };

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>