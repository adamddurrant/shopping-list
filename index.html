<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"abe888f05a6ecb15c92e2cfe304a9a8b9497de97692b7f513e25089512dd0ae5f005717e4041f408bdbff63b0a61f9c0a445be79eca4b38d82c554342160bcd9f26d23952b5c3e7ecf6b6fcc8bb3dd167ff5ae61c0033ecb30edec361bb762a894ebf232442cc1bf111f6058a5b18efcf4abf0607a10badbfdcf8677610308cfc81352374e45834fc6de0d05adcc431f58a22a5f7962e357ddb538505b299d3921d1bdeb752716fb62cd612ea978ac1211e3673775ce465ea249ed39c8f992eeedfde37ec6a18d7b78c9b3f06f8e9ebc40d81422d828554a6a6e0d36d7bd40b43df03ea6f72219758f68205acd328cde0c50a5374424f89b9169b40b056e29e9b3dff486f11f19a8fa1daacebbb5f7aef4b8f29dc6c471212fba21cdcb7f82be4a891016ce573af2578353e7f06e7f9134d398de591805e22d73720378cc184f2484a37689d072f9bf2d05dde3ca483d40e5e9663093ad6bfbca21b60e90fbe9dd6d37be70a479ded911ffd2cce7865eb8c06a6988d6b77c31f82634bbb0a20c01a078875fcca6eaf9042670aafe89ce32ba6da925c8e0c14861fcacb6e682f170976471181b9e0ca8e9f60a9ae69652b7318b06ec595de23cbd810ae3a6347691373d148c0d05cf9e74907092e8483f932d89ee9e00b528852468f8ecc839867a7be5ee311119d5ef767259844349cb727e85c5e1dda626cca2d2d5fa19c99ae7f3e392d2854283049bf1d629007fd0ae445dd9cd56fea1ad14caaeac9cf880982dfecdca372aff86d25aa2490adf623268a26a562a01a2425866fe44be0ce5a85293c5daa0d5caf678a8f89b03213b3025e445767c1a8b447519eb04faa56f5abbc8f587ed207563a47aaa3a101eb91dc29a605168bf931c01d831eedbf58da5d00f98678cd0d03b83a3570c099209c70af238ea88a711f0cedc8f91137a2d65c4dbbc2faced55b95e2f61455ef440ce7b4fc8814edea580df8b0faa44bae5efaf7d2a04dd6d83d26382a98a24b1a37e628ba85dda5dadcf9e86b0bc3780732b8b64dc9c07b8790e6aae501fd906f1b09bfabfed88ae5c0f510211440e9ef386aa7a6cba2062d34c2ab36499935c69ee70ca1c141d37f77f738fdd236940ddf34c9a858f9030ce4241e1235e29c0f3825ac014631e8bee8d67582b990afbf3eb48a07e24ecc3f1548ed186b331df5672bb380f22dc8af64be2e7eaf1711b9311d52f8a4bc5aba7b6bb40c2b689a2f2992eec9dfea846b62cde0a08ef54fb063dfdb86d176a3fef6a5c9dab0e21bc93558a45afd0714f41c0b1c4f0e1f47393bde5f20ff2ba782534b00eeca010262751d2357862e8d41b98da63b1d82888f2285335360983df20619d77cc994bc73f03ba296a0f377733d66ad6acc7698e205d4046e4bf93e93e6774b15f8dfb84f68abef67cc93dacbe3eb2ba5ad30086921fd5af229746a9cdcb11e170279124b872f8d45185fcbe963ffc7d998ac41672b043d25c3752ae4f2f3b1bb1910e2456890b41cf74dd7128042909bfe874de00b7866264d8d29e501f7be83f1e282e354b0d4dfaf11982626b706b595defdf2d2bcb0fcc6a57cff1ac366e90bb1e88e47568053886352d2e4092529fca289bb1bcc8551269e459778592fcdc2a54c61ae0524cc811a833457846095f0ee02b669e9c32c362ddf5066a7dbbd23fc4d831abbd0ec4e715cd216bb787d74dcb065bf0655d63c68bcc2a8a8fe8f7cfee470b6477f58d10cf5a4a7015f2ce2ce5d04eb67843c50e91e3cd5e022e0401c7ef55705ae7dc72bc65d0934c2b8125177ef8d6ea6358ad64c1bf0a3e1648fa8676ed8b8c38014a6f8442b5092fe0a2caaf9381252fd0c4a9f2624a27d0523f98a13df1ed7322b94cea4cde890a6c4503a17c21487fc61a24899a7f5ecd324716eb6a9d94aaa8f72e4cd05fe42ddc40a813f640d1d9b22052fa33f49e687b3efd06678ad0ad1c93c8d59255dc9c4e5dabf872cc8540918851da1d65632b154a9f85ee9d72158778fcad485437f98551b648fa654b66012eae6ae2a412803e6c4f701a47cc1cfb4f895a7fdcaa75eac7dfb337e44728bdfc1758d55dc456ce047ec38296094d28ac432e6449947e7d514def73346ba30e3cb869f0a02919c0ea40f3fb3c3e73a0e2e77168940f7def5caf08087a7e046afa0569d63343b9efb9c31bdecc05aa074268e5115cdfb7a646d426ea597ee920fe55ad927ba4475f786840194ad73c9cb5dbcad58abb108fcdb7f5f217ced7deb9fdb7c57f6b2c3358839ded86a24ccaa7e6aa08d04a76d1475577fcf4cbb57127317458797725fc1891cc73e269ded3e86ae2c085eaeef290668504980670f9e4db03a41aac035e4440cd1a81c1a222f9589eec1d8a0d1c4c7e87c4868e252f4f0939d7fd0a7d271ce55ae3253bd3c72d8f65aeb7cfd2d8e6e754b2b93936365882ce7da8d3de12a50a02f6b2e67bc819fef4809f6e4bee9c57c1f78037b6ac2977d14fc49d3785581ee036a65168021b0fed35a5009d863bfd445f0d574e2258ebc015826c45d03eed5d004ef9fd4b8b3d0f83fbcff8c63e8aa4d2be561e35614f447610ce9d160da9929f6802f95a4a63fd71dc3331dd48ee4d7f88275842755567cdc720121018bd005409b74bab4a257590d0a37631075990746c6dabf28cdb7e36f905bbfb6e5d96551e9b6ec2f3b7541a90c4b5151dd53956a08d1b8ef3910f80450860060caab342eca656a4deba933371742d1d726266da84825a42c9623137d89ed515dd03ac2f6ce33bbaf037ec967a97162a178428bfa91ee2a65ad7733662e931fdde625dcce17a9299768758e5755a459ad809ee54508e4fea01c5243ce0843a8c82d91b0ec682c119ba1aeaf06b7f09df69786c1fc530c0f00e08546fe65002d3d450132920a69b3476ef5fdcdf7fca071fd649d19d68da5d217acbc145636c7c72788f17d74426c122103089f8b9b16254c255770c241eeac9ab3349881229e28c09fc11d2f8450b845740d6a732778d24db4a06ad03a51c444156f46ee96f7654346fe528a0f36a0a17c76fb9b10105d89fe609853313f6edac93ce0a5af415410eb48700964c4d4a70260d24b65fd39e8c1e60dbecfff34b1b0abdd8c3a3daee388ab45c45cf15ba2a339b2454bccf8a1648d3b9436cdc024d69014634001396e530623811dd8271954a9b3d0ac64319d886e8712969d0c0991c160efa6af41a760c888d766af05ecc340597ded0829293c4a3cd4354a66b90da2397ce88eca40ae304e77ca0fd19d7002e2fa24b4a5f4fffd71d339ac6fcdb93aba273ba362483f1f2cec2cbd1d79f04ebb3426011524415afe82f3f50808c17adc9ea48f313d6006ac05001cbb93124e599fb90f56fd744f6126f5188ef1790957789ca45fba3d614697ce832c313de767ec042d561046794636ed30fe283629fe23deb6ef907ebbba9df57088d127a22dd61fb8442f210407e73238067dd2e1cb1dbc8966cecb32819152090f8e08971b70f5d44d2681636e67e7d16884ef69226c7fab33bed200c1344a2a2af33ab16c0c0384fd62534027d123fc40a1c5670fdf0875923b877355a0d99fbba618a269564767ab6dd783f79b6c411c9d5466f6b4fbf0a9a0f5a8b7273a446568c4e07429049e4f47a5c2719824b7a30ac41048c7e45c444f50c71399ccea515a58f730643b9cfcff7d1276599f2c2b781d2722547284660b677592186a7969c7f4881bec6fe881aae348f51c4b4347cab9dfc57766974e4ec8a9b6ce2519ffa5402f0bd9adfe2a481cedcb80e8547e1b19e56eca01d82bde9c541903aeaac4a5f9739cd26595f4f628ac93d9df1bff790aecc584f3102bf5a313e173c38f9aa85c494a2df04e0079c620103aeba3bd6771d1bfef97cd825f4bd04a7c69c366a42ec1941b022f0cc4e9630c2f9ecc9bc303fa57d8bb55b0676a9fa6b6b25b98eb0a6314d65b162cb40224d1458a6ea79df6ed2dfb6a693c0e08486c417cb40263a90e545548644380587a4b2e303e9787cb25d8cb17f577175ec26df3b6a56fb3f83a77a2e8593beb03a9cd86f3c6b495b30e836ff709ed147a5a8e022e9ae4273a4b100eaf67fda6aaf36c43b4e62f94bef9ead2a2f84b879dc66aeb42abe27038fbf42e7e83a02f763e186b826b13cd4d2537fcc4fca29ec17e2a9cb8ae5230ec8a5afa0265a49e2970b627740f179b272700f2995be8037f15e27f85eb45866ea655abf76929843c4189bd013bd014b4d514271c93742dfc23e0d6a5c57591318140a67874c4c9913da5a8a1a908f3feba9d2f01d388bfc5b69dbb72771b388af51cf218e7503043e21e136be07e6c9f162a4d7b5c909bb18283a7df58f5bdf52138a7b7c6d2a0ec721ee5705d691603c35fe990cd13852cd72a435e5070ca37be9a6f9e1a4f3632cc8031013b756ddcb35d8ecdcb2954d15d5774dca3db1f08d0cbaa895fc1f3764df1b926d31977df8f5629c2b2c100e5916c9f28010372d022c739058522b3c4518f67955f5a376f51d4ad2a3a836a0ff7b362be2dcadbd258103a2c2fcab1fa656d190d44f6f7d6fb35ef5f03ddb3b8a5168ff750bad0e12ac12bab9bab1dad415ac3af5779a5f0f5c5c36947f2af73eca11e6a3d144324fbf95a280356d477add5cab376fb0b7041f09511ef0bb8bde3485a2692e8033cfedbca209fc8534770a21818f304e65279daf41e3cc73204c41620e3db9737a7a57e776b40e0883c8df5a377dbefde0734afa6b4acaf6a47a7b7d22d27788d3ee5a838d403e6dda9e225817850e9e16de6c6fa8ed249e93fe207cafa8d03051c900d219607ad4ae3d872b22a13506f523171b833ff322df7438392e9ec72f899ae662f58aa0dc75a42a55622446184d7a11b98b18c26c662d28f203fdda334bf822156bc47f48de47961cb48ae4378337b459847e5a6d8f03712592de6ae0f78db443bef9c61dfb1bbc218cacb1b9989ea7d998c97708afe7dea345be0a46c00f507cad3a8505ddf634b28750a26768356eac68345a758015a45f93d7a00e0547063329cf3a6766e50793b54f57da3f8143edd69192066cfbe33751174d4b697805d0acbfbe212666f3395ed8b24506424224a9a1610f86e01f402d0a6e3c0bf2720d035fa5b59e5ab07465b2bc3129dcdc8043baef2311e61d963c2e740f428e4c5169582f19ce4b3dfff6f7948d6cef73ffa2f0c07c0a95ffe59d18e806ceb829223d552c731b46265b875fc555bbeb32c353d8906f0b867a5f95eda7663edf53929bcd9cfa09d810fcdf9387fa00d5947d0a71448ecff742c4b3ec8ac13f8963a8b272166533841666b535c2e4e00b981a7c245eb13f44d02ef683501ae89c6fb73e029b992e10c6e88eba0c415b0991ee238a4bbb6c27b5a9a70de956be338595ccbb852a96dcc21be39e7873677b0427b154d4ca41228ab62cd0fcf6a57e886d96b35d155e3456616aa6a549e6f796bb1284f5f670a19ec84d293454bb12fb3715e20e7a0769f66e12a2d9d6fb9cff96541e5984bb8b86a8fd59a951084a7023d6d571241876aaa6e6ed03a6936bc2f412768b65b1499f64f0bbb509e38ddad3752b098f92d7b15e70cc9ddb20d59d5817ab1c7558967c1018e32ee987fd70fb2222270ee2d59a67fb518228eac77886b27a486c5cccb3139b015e47f727186e2d838e604f16b47bbf4ea6cec590c950a44bb118961a57e3e8385ebe49105c5f4c642d5f8b48f51c6ec9faaa904d19d49251e6f8d98cc4f0b2f069611442064b0c96e7394a2497cb58d87a85e2fe39e8719efe1d08d0dd46aa298c3a9c66f35f711c458dc194f2b7c43a4b2fce46437b33cb7030d06cf3752266859184aabfeabbe8f31219d8a0a3402ad5319e117ebd6aa6d3bb4be0a45d39e3c88279b061d0649339de63fe0d9e2a80be5633a4fbfd1f576c5ae8e12a29a6bb199ff57a0afb2f47cbb5685e7bbd365a3229de71994db833d8808acccf72a9b02532e259ab58c752bba9c3a96468f9ace913b043fbdd1c56fcba71722006b73a23797f524b9e386d97fa82c118aa7c703c6e6ad3657f234e26b0c57579d03e9ffa369ab49ca110e5b52afcd24bd4d803b4fbfc992cbfdfaa11df6954eed3f8319a75ed5d2d2cc60ff4a10f853d4502b09e0ce57c874f64b71e7c55cc4d04ada9aa5ecb61559aea392bb2dfbc8a5a2c3e73618f3c1d0994b5dcb8ef79bdebb11dd28ca445b82e85cec99205c85f252139784dc1a6c98ba5aac477ff798b300440241b0c08b6e52c833ac961544e27c5a3046a077065ffef8355404dba67810c937475ea0ac001eb5bfea7648bc5ebb440b644a06a27db06fd0c55de5f0709b8656c248a1574ca930b4baa05271e4f4e9040a6fca1c5e076aa8a83349b792945d68d6f3067c45349d6be8c618f1e1c62ea0a17599539c18be3eaef402e3079216ccbfa4a0fbf3623cf261efc1d3f207b9edae70199ac197a8d55086d4075687a47b1fd2b64785db93c38aae523c1ff883a976ab5dabf9ba15392f60e5d4c6b4384d03c4713a910a756bad416813882d182b43a11dc49a4d58c6c2ed7fe269d375c8b360864b23d5ac90d44b62c265b263a89e77c31aa9b3bbc1fe4253d21372f8a9e52eec49777cebd684be7488b0ac9b0b96e8e4a5b7dbb2338e29628615d1e3dfdda838b459df2ec426a6c48d9739a0902f04433dfcad74ad85f10b3fcf4882dd34eee438f37a0909a251e4de3a8a752beccc6f1cfe16a3fb3f9f1b0df4fd3eec47c20da679559bea763a9e71e4914bd565d521637f6b017a87b301405c8b5b17ac540a9abedd0c8215144d6ec6d0d0cb46568fd52743a6136e100b0cf8d70116b7079556fd5c24b64fc7bf43c748e1f81c243b4bea836b287eddf97b70b6c3597c451438f454294b8fb0bb183b539f9300c805838dda53bd762fe393b25f8bc703487e4d380e87d1b53c2ca26d6e11d9dde09ee2e1cd2dc0b36f4b7a26bcd8777615ea73d86a217901685341856c5ec43447ede3eaad2c4dc8f0701c156a4e903f06f178dd3c5ca7e84a1846e16c507bc8852d536d4c7917a75ff6f7cd11d2e95b086ab54d351c99e0d696180d29532df5ba26ea38ff8cf54d82e727395f752ee3b039840cb445e59056f65c483dff4ee5185688a32b4815c034966acbec94b6611daa3e6ab2e305b456f5119074abba853179cf03252758694e880aaec5aa3091a99adb30cf80ab77bf8235cf47a945ad645e373e86eb7bdb34cbdce327659577e39fe80e6fc38e32c93960cefa70dc4268cf8f9e5e5af5b1a6cfba63b23fc98d663b1c90cd2df842093902a1f03dfeb9897b2a3f3ee1327154f47551777652b5fe7a05842c001e9d8ed101f6908ed9f6aacaa8f9842b9e333375cb4f93cfde77d4be83a1745631958e4bf14e8a379af8ebd8f5dd6fbd973e2b117f41f3101a96336080685e6321b60fc808d754cbcfdce62416ed6fc696184f35bd7c4bffa5d2ab9f7e2c64fe2083fb034aa3752ed9ed6327e10a7453c732bc11c6aece374494745e62aafd97d4c697e7e46d48a6dffd6e36a8fdb6738c2c779348560456115a518b12b3e3405e6deaefa7e4e2d27d4fb452e0139f9305e206539ed08f3a1a08a2a1aa8b11cebe90ad766dcb689c0290cf89d5021c280fcb8e34ef76938b943df74ff3674313983c0cf25da41832cfe13f1ede44ea5198a25b5e351abb2b840d4a19e38c5ca6c9082f87b350d54c53a4c6a5e2868d65050141bfbd6ae8dbaf9b2b4d736d43064d31eed6417a55b7b4f6b9b40ab88b360e2ef3e063bf3f8f97bd6439e7f1406eab08707e75964a2b67dba3407b362f67822729462fbfc7e356563f7c86261ae453377efa4f9578f11680dd9b15bab23f2aedd62d948b4403c49dca5f9a60f12aacd14edab8aa9dfa08987d9de7d4555d55da92a068fdb7593441569ae1cc6df9a070efc5ee6343bdf02f5bd30125bb19a32a67779d4cf7b5ea00ed81092e33043359fc9b90841ebd30f0e9ac951af28438e7afd2b9aa2e4e822c2d030c46d76424912f17feddd7265567ac100d52e23869897154012ce4f1f2ff7f79648bc4e56ab543f1162a9583055044c20e67ac85246ab9c4d2bc8a0b979453761db600e301b5f13697771986375a28d3660b70171deffe69f1452ef5003c5e7f89a272882318d70c8a03ed71c9c18c83caf333f14960e6d78a4568ab31a64c6a34d5bb3a9e898718c7c5d84debcdfc119f07d6fc9bb4b3c59cddbb0ec65622027ea93b4b576aa37780c2dffeac518c560a7cfb04e8408c71dae9ced612c53679ef82cab255136acefaa470b643acfe35c961d0ef7c486952f272bdd67f484953d4d6421d135691feff6e0597fc178cc3c42fa39c83c7630b4c5d5596a1ca4bc93767e7151e3ecbc5973dfd3dad68be432c6f7be4ebe34cd901b856d4fc69232fadf8c07e7483d30b448a7ac8461429e092309e985fa2b4d2f7981ae4f72f65e91b1ecc8a41f1db28a11d16de8150cb10024f7624896b8b440ef7b4a25139112df630b24da392926f80c17dc1219a6bdf1f390322292efe92d18042fae0a4a32a28a1052d60607eec78ed8a72f4fcb29cc848b78717e06c546752ca0f653595267e57ea80dda06c9a108c6e8b3d4d20ed2c2c04beb4e64b3bfd8f9803dc0255f7b683738644b5a346018c5f6a679642e9c8518d4170c873bd04c3cd7461a58952b44d16f4e1905b8a404d67d39160512764800f6d90dce7438412012d641b335d9fa13e22c215521d7fc6b6523823940a5aaac51c57b8ad4923f371a3fe37fd190294d2931d09a7eaaad8cd2a07548d8d6e1c3e63cb0268d4777458bbc49dc72a76860c58759dea30ce590c3be3a6435e0ed24bc2bdca19f37b09ba1fac4744c3e8421a13282fcbc668da695d5c3a141885b7774b294bea85667895ab539c1e216bd98220d36faa8f43d3194f86ce89faa5262d22703c1e67dcb072fd22e6da5d9ab3eeca310ad7f3c25b41efb83a9e6e558b33cb42ca0941b28bf69f8d21cdd21da0bf7c6f4d1f50c0d397b40ce1e37ce1732f98a2fce13f2c5df1c77b7bffefc92616f5567c1a0f0b1ebfd5ed962c9370cc7d1aac48123e7683773c469d8044a0ce2af5bc095b563af6b28b4299b8b4b9fdec5462d02770daf075fc3fcb1c7cbc995a8b8af7e4ecc2a45f2fc0de5a7561d29cf40b93a04611b85935f81add94fcea98219f8f61a862bf33eff469b79a60a5f816ab43a69a4b078ef7552b021f3f0d326b265b9c1e11c78c69a5cd1451677d6d7159a59d0bd2f41fa800e546b65688b10a33f4383a7a2625d2c2cf070bc80ef472891fbf90c97c0b6dded5605846b29eae14092d55bd0edcc7783b15be834e472cfd37a61ed3db558722612f403129d8b6021cfa6d2edb6e492960c060e9291ff571ced9ef379315d81181b8de6ae5ffc20be41c49a0085af33ad6fe67cdfb8adc57d56cbe1d2546aa4b63087fef168a966a33e23663047ea7413e33ad599ff6d99b1be9d8ed7f582c7d7fceb581720129a44c9240425e0a520034abb2147cee47dc35f61b7e5db7c87819234d95c9721826ee6db905fb9c0419bf7996f54f8d12c9c5d0f1d4abba35c4a3da3ff7370c8d74ff9e7202101a211c3a8d10d7d66414a81978f3c24be02d62a11db86f50d4ac76eed7299c6b25708b998f55c11c3e076eba50f11647943fb79c7ad0088bb08dbe5412f19dc0219da28632cef65407ea7dca58f7b5428056962aa61eab7e23ea3f0493f1a8e134e434a0c5f8bf391dd6d4fed3d606eac79423274ad3fb211b1a931cb04cef4fd77d0335184f2f57a88b6bed185bd8f655448ebe47690861ef60e50b5b87e0a955cf0385a419e35ad3ceabf5a8568e1e35e1d55125fb1400782b2fbc72581043cd720259291e6bba8b4f62f0020bd809bb18bdbe020521c2448771759806056139cd79cf9ef78bd0e6a619159c2175e85b3a2afc51a4c65f7093f588b4b17a2ff7380f497aa18d78e1ca10799e0806459747724b1796e6505dfb9f44b709d92fa5b65dd8ce1db6863891d1f215a6e2bc71851b660b5e59343dab040c7dda0f882018ea3b004ef3281e3bf9c8904163dbdcfd1c5292d342e3f6f1e5e327dee83933179065d86d7d8fb1ec21fdbb0d4569239fedfa034394a3d5856258119adc9286837b464369ecff9419d01d2df1c0c456f1d2e3ca3ff8e598a5abd1f52c7b3090f986f0c3dc62b758e3dca3534cc88b1ebac772447515571f647945ee43119c5e775310f9c887ac5e7404605e73317ae613135ac9486de277fc469038c8b50e1e9b010f9b878f25cc85256e2e42313b3e7dfaa4bcbf49feff6f36a4446fee670c3d0ba587ef78493021d508d7457351fb1ca18333ada1d6912425300ff22550a931606e9743339d8c3b63c0c33f1d7ae30b42b2c04d1fa3a29d55c38f2b179a257122ab47bf8ff5f2bbd62ee1e84e4817c36235a68173f0cc88263a880601a5f3d4c90e798d9ceb27433830219df3209a3bc842452766e02196ffa0894543fc6f9bcf6ced040dd52a9fa25cc8957109f54a3c6c79e671bfe0f37afab90ec0ac5cb0367a9a2b8cb86dda818529137de7b42366f4fb351410c4d156e3e2a9e70647c8dfbe4486ef41eb9b55b7bd421d2c1dbdeebe6bfd1a2a37c6ebb8f749b865719d9498b68908ee27d0071db57491c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"45dbce04556034d246fd5a6be5233e00"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
