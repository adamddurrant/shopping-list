<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a5a246211aa6abd4f35291fb1c17434a7c11efb376c8b0759fed4bf17d5f625887f2736cdb61d7af0f1ec1685966e371dd8f54c24d5619f49214641385b76c874ad4c40f4d2c81da656b1508e1370ab8b5dffa8be13f259bdc8ab5db593718c27940a87357f93a5c034ada1457a8c26eabd3df7fc1966ecb162e6311deeeebead9efd57ca403446043d5daba4924266f680d5a76cda8b93fa2094d5ccbe06d92a8aa4eee326493dd8986688754431ab87712e9f1ae75b1e1118de51a9d4a44d42e41deafff96016bdbb47c16e0d7a724ead547f6212ed89c29f035af39c3f4a98b71ba2dfb335c1a4f6e4874e1a5499b42203dc90fd2d90ab3d8dbeea39e13f1d1e5e8a5e03b9fce4620bedde04e5f5205535304f21eab3ec7a461f95fe2d53cabf77fe75fd737d18975b06e114da00e9e7e1977676625711de0aebe15312831f36d129f00a87a3dd7ed05df02ad35714b7a3c73facc8f2c6037ecdc32b5813b20a1b3cb065fd8e04c13aeba1f48bfa41e9c0bad3c6107fcd1a3fa3f9bec3a417b54cacd8c7ec5dd23bd0afdebe9c9f14c6a05a9fe407545a67e125d4e5f0787c7d80dbea703a5762adfc764f0e8ad5d682467133d2625c2985d990ee468463cf8759d7f4c49d7313bdbc6ed60705f76a6cd48bd4654bf0df6abce84ceae25b845ad979f017f1ece604327ab551f57fb095a9a1ec4fdb80d4d68831e2053e8b95bff553d68076a46d3a7e7c3f34f4828e86082b06a057f58969644b077d14a932f68072bedf7c0d7f3ea990aabedbf84094aae3866fc0af62ee37b2b6ea7b101f342ceb07ce031f64111f8efe0ebe4324701feff1e751d1db775c072db2c42593e44eb0f3b3d9fc4600aa19c0f06824f5e39ad5ba71e3eefb4f87d27112f6603585a11175f1b767e1f83c388616a1b2584532b389f9dd28296b8590d30251b5b6fd166684ff5fee06688b9dfcbd5691c071906e07131fe849629e4ffc5bdece68d31d2c48209ec4677d7d611028bb06cbfe3ef722fe4a7614d7b381462185ff0e090258a3765c726b911b84ebb9470a0e91db335970f85ea15d1077d2bd6c41d1720fbb1cbcaa1c016bebedb3eb7d08463cd3c3247ee55f7b409d1d5d2a102328b767b02131883da3e185d657c2c04edb56ab4011e7559d96d771df1d00fea24814b8c7bffb0789e5ac71397db9a971662a55ab979b13e8c09be23e2144cfb2191d08550040bef97784e1a7e7d8ff8937c8bee3ccd73e692d2ddc4b91b7a642a55321b9fc5714ec8957dd410edc56027529912447c16bb917be963433e30edb48df8b37fa655d3bc0424c19967216d7707f8d2e64f7bb10a03edf0361fa699660cbde10a3a5ee1f3012c6801b10e916a70d7ed6266312175382bdc27967bb142eafd21d81d18ced314f273263353572eb25303c7b19b93d5eff25ba23316dbd4bebca81f8e8161c5605fdd6d8d9739cc8baf1351f940e505b425e128d2d2f2b35ecd0cfc2289ffe0bc05dd9a27ebec0c925f7c4c51514f878d5208be5ca15d46c173a56136b72d4668a83f805d809da8309463e9db228337e6931ee3aacc673f90039ee14f20935b75b11065e0fb5dbd762b2e33bea842394fcef055b53569f354dcda0a65693c7f8c2236de434b7252f72c7d44d77d6752808ee5fdb19996cb025bf014b34dd037a93b3ff198ef538fd1d8984b48c76a9c14c2a09d5d38c1fd2cc386f3766f75d698cb8304bf2f4679d50ed61f989107f14bb0903be102fa56167abe81f09d6c7463d9a3e072ad1a789f289648e942d71627abca12aa8ff6fe120e7ddfcae97f74f18aa57814ad0823c1450a6b8e4ca4b1ddf60b7609f67c5d5bbfc390463add5f347508adc8d5637365bde37328d9c018f9819f3c234657f76bc7391b887ee0d82019a34eecbd133f68ec74e227d9ff3c968374f1fc9fc998dc4a6459eead243524f37593ecf2230548d91719c3fa82e9d51aa4eedffcb327d94203a7da16fe564e19fb5499a5449662793574983200d5c51396ae9f1e7439ce74afd8c0d9e91ddf06e0390b31322500625340a068fb29cf7f8ddb53d0e681043ea622d9aa37cbb8666602a5129a15f521a0c9e925a7188458defb5fdc29775e6e36f1f33b9f6c7374d29d56e64973578973bf9b9337617c5d82caf8c748016aa42d9cf8789cca6b2f6d22d31e48c09e92e9344f278b22f9abe1b74cbfe7ae3e5edee49bb585235e184850a8dfe10d73e7477dd409a38603a5c22a935207fa80da4d57bf34d9f4abf10e8d1f99c246e4e6e3f9a512214d8175b743d4ddbf78e1c69459abc03e8cfcbb8692dccc16711ef3cf8486ec8a7334167e6b0ce7497a9df36b726b16bb9a5561d5c631702875c0d8c4953e4246bcebb742f9ddc0384cbb75f9757f832afc0b800d62b5d495932a56ccfd4bc6cea47502a234465d7404429ead19362c58b0b3885b36a7b2750f9386633d9c3326f686b0f0e784d64e01d4e97e61aa0329dfa1d10d784888189326d7e587289cf03b45281a7cd8f43764869427324f00c1aa551e6425573ac4e6a4a717268d5142b153b7149fe1b6e490590d02411b13330d5a68f870b36c9036247c54235c5f7c8ce7afa6dedc44626e3ff4a5e7760e5bcce1b37a8adbf869094400e7fd078eb5fef0ec0e97f3e304898871ce6cb5988c4c4fb02de112f2b5d024892e1856363236192d26527fa48d57f206d52698ceb5fa16a539e8f56d8184939f3cb7bac5a3262556b2f4173934c910245fec96c412760203cce120caa4f9bde370b35e34e680beba323e153766c5fd8aabd07f9b68e62b6e4e41b1f4686485b2fbdee725f94c3ebf08d8de8e1f4aa1d55739faafe590a5ec9ac2f52ab1c45415c7ae0825e724423212426734842215bf557bdd6d182f3247927700f39fbbed722fa7a1a88c472e7cd2fd4c10e8e558d0efbb9762125afd524bdb2f3a44ca20da6becbeca6967a7a4c805ed387604ab8b97c61a4cbcfb66a5d92cf109249382d7adbc4c6ea188f0c52b47f29ba9ef03d870f8fdb38181f79f282c5348904d69efafc586166ddc9e4d2ef30fc3657be3977f8fec3a76e6b378a555620eea9db0bb5c7c405c913731e8f4e73878dc7784e9b5ed9a1dbfde32a81a1147b1f7b16b5971492aaa0a17960e8892587e8164a614599dd04f2f9e8b563334a9a873a08b49fa4e02d13d5731d994eff68e63dfa376e5be1d510f72e6e4c4fa30ae2afcfa402d8159b6ac919eafa3f2218852ea314bb797938f07eecfd332b9ab511a7af296fa6a748d61eb3219ffc540d1d1eb1370b083e1fd1b940ec114bea2d180b48d411094ee73760ad364ecf7ef93a61441eb236e1041ec40acc8b4d4f8e7c1431e551d20d1006da8a61a151881d135337840febf8ec68ffa1f05118d871c19dc13c4f3747d7790edc5c70490618e711cfb9f891630c70d49c3a3d7b952dcc33f2d9e24c6ce405f59f7661cfe2fd89e064a303125648ac88afa0c6eedc4c6abbded26066982deeb9d4dfbc6156cdaeefda476fe88db16f65747c325f41c218310c87693993d4517021b11e12a9bbfc84f134b98999cbce63d913ec8e919b4e87953fb561dd689a8584302164215e6f4b9c0aeb6032c2ad759eef8da7d6e50f766d6d5f698b85f7600b841c47338a91fcead952838bf9a0f0c62a7d6330c9d5e9af4b8d87a0b459bf10fbb6b92d699249af80b159d330e5f0391bf85255b1a635127330671e943d4c8c61c74509788995202bf553f4e4060c1618b9679ae1e92b29388cd5f249af18dbfb58978876c9686c0d53780eda076e6be139a402ebc89cbcb8bcb171a50367b75118b00ba821b3c4275aedfc3b82c06589447d1b0118dabcae83bb8f3e624b9db515c1f4b474abc1f1024ec65a155e39c9a92465c222730a8d851e30311689c5b3459ac21789be6edcbd9498c40909f8dba87ba5bc8fc28dfeee255289bf4adc7945374e69901f7411ca1d0b0848ec099d4b7a24287b66077f23a06e0d2bb7e95035c2aa0a95c9022efba37252b89e293cbd1596558ed611a4477694952c62f735dbcfce9f6eee798e83a46c8d1c82092f16ec50f665c23dba3ef8f17135615ae7aca2066e999cd57cfb7884d9d9e5239bd1cf1f5f8fbf87e46c3b5b0ac9d2db09bb08fd51b50775b3e0b51ed738d4328852c6ed93d4f408cdf9abc457c291ff881d40ad8a336060572ed4611b9e04251809bfd2c8dfe5a9595487209240755640d819f09065189c1e26334f3c0f7564395305dc34b0ba025fb6d4f91d1eb153b56e6045d0773f04dafbcdf92000561cf98720d83fc96241d43b8db3b9778dfd8676b3404ca12b6f7d8d2838f94ea6af2bd128b4f73095065357af7a6899a80c6f5384ae00ffd4a82ddf248e85d7b518e9f085c651ccd666110370d1d0e47f1dc67f18b4776afdd98339925d37341bb452bbbc9a4eaa63499f0bc200b9eec51ebf905877e236ad23ac0554c07387fed619aaa7e4269c341abdf76d1a99a00e1f935050bf7ffa32664f23d0c7c1027d395c22d25bfcefb8c66b729aa75374fec98d9e250166469578aeb931e8463319b0f2dc144d8557cd93fb7dc9c7cd0392a4cebb0867d3ecb2b9b3dc8dcc33bac85b733df0f1a5c32069f9fd4d67e9c7356263fdd4e8fcd3c3ebb830495cff43fe16266b4dfb386c289f183afaab30bd247796d5013baa44a8ed736ec2f1575e0eb9b1b49cbcddf606d3de2e678dbb3cdf633fcc37e3c04de19fed375d488a320691649cfe3e60afc6a4113f3e6b860ebdeaa0825b88b46cc0e2f8a498c1dcab632051b3a17fdf8ed294d2934f2aee13c67ef85e851117d33a08133d0ff382e073da57791b7a50c80599658f4fb55ce33b82397621e0d200ce89d742af07fb847af8a4f25b03819dea4dc44788d554d6dca124b077fd89d00c4651416744445d6c84a818b9f51abf574404c64367884b4bc47f23a239b2b804570be2903b129174044176ca3ca582dabaefb41266493a5dfb1f1f2d7af890aad5054f76f3a23a7897bb9cf7dfa62c7988bff09d23601cb7500f49088b72b61084d68f8f7301e1ccc64ccff2a89ccd046871651df6ec47ceccc36153e1a195a57115f5391e34b329aeba733ca1b6191b72bf2d2e73a9dd63f2fe23fa834dd194a3fd3d1a8cc58b3fe1e0a957012e3dc1b7ff6a310967d7e15b62518502bc3eb637980987ff5f980de5093e51e65056bfd9b7946387869e0198090f9f443a88468238f2f276bc368695c5ee31e52ea7e3cd39aa611e0dd26712819061add4807a90395bcf3e41c11a1cc9f00e226cac52b9229245059633d5fe0288be175b8afe6316ad802f72c4d82351c4ff9afed131c3dc8cc0984e2768bb6c2f2692393ce16f3c04c2768d2fe9d14d6c0e56b36f9f5949767cade184263dee0f1981852365bc4b1efd1dc5f5614e387b5fabd047784739e101878170871464e496ff7e23803fa40dbba8ee191e819cc364f63dc7225e6f21250499d3c280cfade60740b349ca98761a95238059e1c05c0a1cf5c4fa63b0f2ea57ead94287e5b79bd6a8fb403b1d7745efba9216d605c12b974e359688c1343fcf7366b6b9c73a8e14bef54c4b5f16fd2c3d43e0d3046d591c4da009888416ae94a5a069581e3f1f92804b4f4b4acec027aa98fd4049bf8b576ce5353f4b2b09d3524a2b2bb6614a842b008358738e40db2951d726f1b1ddb360ff80d9329168ff2e0eb1f62565086f134d55626634f545ce7750477704b85a63cd09319499f3abc010c9eb7894badd1fcb0c3f32339716e71a25076fa283f85e49adf8bae1914a17958223f2ef2ec9dbbefd97db7d77e5b74d966fbd0878f47e386335ca9a5a1b406a1aa7f1c8298ba87b75146b1ce9573c991cb1cbf0184cecd5cf23295444767e6cc8c00b2b24f755c9b57e07297abfc346aadad5d1d6a1258a3d745feb3086bb2d16247d7e32f79bca1c740adb4685d14f89c08074955c5d3d8d39f2d2170b56a7f7c44a438f75635852ada8d25555c95efef39f5d362759768abd84a5195eb665804cd4bbde2d3600b781432bcdbcf16274069e74fb5f31f4bc3d17e1d945e3475fc1704e0dcab0160bc0bc44079489e0266135b1a0d86763257184260d68813aca6ee9c25b3e49f581a1896293aeea6e8bcb44727a89cd8c07beedf8938265b5bb938cf44e55b45b0f1215f872bd01bccf8f59565efe4b09624cfc879ff44bf90d2f5d68b8178534f950e4b5250c3f198416b2baffdddd4fea6aabfb8d7bbb93153e4b4d435c87df89b471103ba6ad5ff735845f311f80535b3e2c1c26ff5f5cad26c9a5d8bc05741b24705314f4ea8f026472b0f31f71fa212e52249fb09ada5808be284da6d7649153420062c4cefe78104d56a772af2d8347a9b74862a4ae0ce9067ef188ea8963f44185bbb25381411214cb90466c32ec0d34157f7b77037e2110ef4ae6844a765f4711b481a829252f2b0739bbcfb75c3c9da3212bc2cfd20687fb525e62a9c48110047cbcc5324018c7b25a1fdd61176d660c482aebc15e81338caf4608e6bbb3380416f15f3d28f93162f662b2b39e91d1468716961f0fbd06e9f0a860887fa7b1035baa16648fa053d02d8b65fbc082149d43ef952cbe7690882f24a1a86f1f77504ef9c85c49a056975c9efe54c2b4f16bca348df20f0ce33fce59333774e218a492e6ebe40ac0311ef106c0d2c10e7fa15df25a35508c7a72ad47cacf58bf91947dfbcc0048d4dc34ae6f5b9d82390dd291724c26edf3d4044d256ea072d58da6900326c315823f64f17c46de5ca30f4f101b360aa481856f817922b5b7cea4e48f645e8dc338171f93081eb26446dada008f565a4fb34fd0c2a155567c0acd9cccb9c728a5bd84d144cd3b263746aa60ce799f76c42b1b4e35bfb05c20996fdd816943763b632a27d0173ee81ff2f8a05b04e480015cbf12422b38f9ce690b872fe5b7ac066797b93d156b891bbc62e4cc32bfc30f6a19a941eb590a623d35608a7ab853bba42b74548e5622fd20b8db3dc9995a6ec8ee25c0862575b146def59c03031811c905e5a7893c2a075ebb8ba6ba85ff7183b8deb49db8983ebbacac3ca80c33b7123ce0cb64e898f2749cc950b6e98f7e72e28a9352e9c8ba49ecd200b0d32b26a6b22ef3733976c91bdf73d22881842a1eccb8f65c796d0c8505bbf4c5679d9f88cec624449c92b0b814ce0e9b682fe13cf8be3254f5451d797878a31930a01eb7d7fcbe3152f8e6c39925ebfade5eebbf00b79bbf5dcd2158f78593bb3487ecce6ec68328d0ebbdff77a9f162bfcc3ca6e54563db9de400d0eb7c266a4daa68d7301b3bd82648fb7b461b5c8894c80fbf40c53ce3ca1c7de8dfd6b9501422c17b9bcc8728ed8ac8793b4705b0347e7ccbf1312c55f6ec7474f5875d8ea011eb5afd47d3122379ca400d218822b3e7e14c416b0ed1ac70540b4b2b98df2bf8aca651d151123e63951e6b2eca06af26bb37d2534f19557d0292a04c0b9e525c4c923391d9dbd93cdfe0af1c332af4563be3e9af3a6eef39f93a06ed97bf213285aab066abd709d9508ea1f9ed3ee4e2dc81edc9ca5116980e05553c9268d8fa17002779ccf47521ea06497e8f2978eb37551b0870695d2ceeba5941e993991d7fb51b64c49b74eb361dfabd822fc228724d128c56ee8a60f13639ec12acdce902e67acbf55177dccf5df2a0748690458cc34a71946b9a49070fbfcc85c5be678b5d9dc61392affc9c1815db030e43bebc063ee04d7206a73462bc74d95e07ae8c19aa8a9ed430a4050cd977a62dc962aa958fd3c622a3935a10d27d46d931bf1d96d23f355416d9cc666cac07fe02d8f06acae03626e38f936c16890deb2d9d23137272922b2afa5c0ca68871eae97f1a1626878feaee68aad8e8da33f34edd7a3971154e17bd415e99477e8022b33e6cc3614c7bdf4f329514102efa5703fd5e760fbc9c00b8080c9858bc7cc84093ad20dea36104eb0e5b8a4cbdb3bd4cbfb13ee13f84db5970d6a7a7041b3e12399096912e3e22182b1f8414732b34eb065b0c0faa063053d32281fc30c882493ca508fe12db7d5412c4a501c86c4767f63f13ce4b09f3abcbed7eb57c113a8d45d006303345a208773e28c7b667500bc1da981d9dd35a6f53e570b21ca317e47489d2665e4cf092e3ae6e87d154729576073be209fb93f5b5d7ae9b06c1dcc047709799fe6b6d848d4727d22867dc60757e8436809993ebae720f2b9f30c6e6e5dd5ce198b52fb331c80b5a6a60ad49da8641f5731be7b5d336104b753aa41957c7616ac8a93c030d4a3563ff3e094ecc6a3e8415e4f34a88bbdecd4d46f93cc7c42a4b0ffc35e2e521756d0fb22097c62088d511383ded35cea3f3c4315059fd1ef75a5a3177f495d933ca62b46d5a480c0a20173772ebd2e5fa6e4f7075d7af0107973de602e54e6a9a205fbae00d2cccca40da4e133e0ceed04693a02871285021c342cc0db18656bc493f9e81359fdfc283a7cdf9d7753cb1868d5b76200e191ec0951d3d355afa099accbd4c9f8fc4a74304f2b4f6dbda08ea52e15b84c264c39ff3e10283c440890147354cac20eafed8ff143a40a50d13b3007e7555b9b4737fe59cabaab15aa87a8c03a0ba91f7ddaaa5a846a601b25c50bbab29369c026c5c1c7a2773e45d693aa018bebac37215960c31795365b8c57080bb1404cdec5a4babd490be07fc9ac02b842f9f55f12f512c7f294be286af8b7f2377a26443ff7a24fed238270486d1bac09ced53e4aca6f271a04db48a04d2ea85c42ee9e1617b57bc7de88c1dba376ec79dbf07e3faea739ade3ac1b49ccaa923f43e067d6708c28b23af8fcc86b73c261b7dd68f806d0970db2e3c81ed6436e93010cda17161de51e1fabc0a096f447193637270c8f35c43eb6a3808d464f907385f64d6cac3b2aea9821122b327d9cbd4c89b595a7ba1ba893270560814561ed0aa3a8ec6dbb6653801cec4aa2d7bb95567fd84eabfcb3fff471c67a2f3ad8002bcc32e695991e21a057507bf8ebf95d087d9c8a207069374d33de0d451a484d413953c5439958feecccdbb64350ab3252875a3773e9a0196719d7bcddf604e434839810fa6264c81471c931c869643770e5b6a83d14d04bc3610afbfb90779590ac1717e533c6ca9e048c8b16e72ee1d94929ddd45f68ce2178edf5e6ece62acecfdbf846d088507388e9b43821feef8604b4bc8b38aba87fa61e1569d850928b567ec267babb5ae0d1fd916d9f8cea653b6e8caed371293edae6d07cada0ee681d3704fe10fcd5a39c5db1e9e1976a81085ba5cc7527b8c0d66a0b21a3c061e8b845f2ee1800daa76018dfff53cf558f164fc380b62d4751ea087f1d747ec4df331bce5a7137596a94af6410a34db11854a8f251acae7e67b97a1215e29b83bde7583d5d505ac074340d9a7020fd7659140b99cdc51185b7ea5d4b09ca99687c1a749f6356b1cfd01c3ad030b2aeb95edb1134a9d60b4e62113758218b55d2e4a3a42553fdb7092347de698219a71f442a275ae2bb1a7dd7fd32d3b1920dd5ffaed6181f976aae36e21604f4ac4f467de4bb50d77f677c62d1fb1078618c74df9789bbcfe2962d8030c90c661ecb2ae3f328275da736269dad22f036c340117ff79cb98cd03103544d25bdcd0c9ee2b1fa44b8b07f3c3b0546eb2d4e3047c2b0cb5a5a57a5945ca8ff81983126d2a5700ee9e4168f0eae0b5363ac04976fcb92fdb100b349504562980ee02a7e43ca09c2a980e059e40d8316c5c1ec1f4b462a01ca92b805b9eeb6a977e01b09f768d061317c0eba4c59a92b75d335dc0a9233401d9a4b449a4912970a574159ac4a4b04538bc59c51c626e5e95281a4f8fdc02032411dcec0d6b6eadb56adf97da078eabbefe0a3d78851b6f19893af4134f9c778999c208eb8dde139b96775ea3d92c2e312581f5debcfc62e0dec9fb44d143d6e9e3f7a657559429a0017d91edf938e03ed3d3c9f475484c70c48f22398225aa64236c775a928820c9214467d2bdd6a8ab29335dbd735b7c25ff12df699bc38e203a2dd076a023641621606274ffac2c90b595ae08d3e83eef2faf8109a5178cfd41284dfb7711994606452c68cf64b697e1f117cc7f9d78563d0c0b5b8542ab0da2703f80b29aa426655ea3f78b5a389ce136a67aab9532c4720cb93902d8dc5441f5e3f58a4abe924d3e6a390049246212f94eba820fe5f26f8b0819e3f009571ae72cd74e407056462001c0b623eb7a7d629d67a3cf5e23a7f72bce8859836f31732c87591d6f417ada44eea1fc73355849818f53b80d2cf9907fdb6226e78e95dbd2106139dd76b055677f405d57d9874b44c38b2030690f68471f2b1f98a3315b6ece43b94b74c6ac98566cef62b7e5add4205c486484b5ef668256b763f9126d0570dbe2ab8cc857c1d60d157903ccb3b9da50d54ea04c7632c25bafe4ae7c629cee7466606b00b7343457a6b2abe49ca3c273b1144e1d9c9f55b3492f3c59d90c0556033981635f5e7e275cc91ed55fcd80e2e4696e60f772768bd6412e10efa2cc0618cce523ff794917614d247d6cc41eaf41e5f89f6420e298ee551ca009d3245c00d9d8c0f856a9581070dd14d57a8b5b1ab1552f58971c9889b948cd3fb149bf59a3a7025ed15911dda8faf9eb3de3dddb371b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8c46561bdb1398834c76ef01bb3a372d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
