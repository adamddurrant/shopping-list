<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d5d5484a848004c755a845a2091e186a24b666a112ed6bd7a7043cf316daab9b181d499000406990887b05d6d9b41c22dcf4f93e59cbe9dab63cd164b260343b137c270af37a35a0b6b6d5bd836784fc1b0b92a8e6c6675c33a845e232164a3df6e7457f29ac98625ff211ae54e9a63551a22127ec21f988ea81a05960eac44be5798faf2c76700a6019a0fb399d8f804c2d2fd1f31d95fa523f32c1f9b963508ab9d09d04882166947c87a67ebb24c93d033d4a9c9aecd2b7df659a54d99b512b06b8f25c844a6dcac3e6b49abb984524592c84df6b96cf0f174b61a728a4c8399c0c257fbc1c232e324838259d7fbfa37c04e14618212ebc3036488ad54fef09f54778958abc86dec0eaf7e48342e6bb4a9cea5ccd46fbc9d70b6dcfb693ec1f934cfd0bdfe17b0bf1998269bac994482ec0e80ca8dff40c7533bb509476e230043ca33ff832a069b22947ddce488db7fc62b8ac5dc382c078952529baef8e8c58e760241cd91aa9f07852fe6f3c4548bc547f51e4975e6d951906b9669b452f547eafc3d24009bd8abb44efac92034840de5868514faa2b46fbf8cb71dffd4b6f465e91d2cc63a75e971737570bbc39c9a65de3c174deeec0f3cc592d3370b6ad3aa311f9eaf969564c22daeb98705ae3c848c045bdb90e22ab0dac59691d87dec68587b1b4136c0c950f654ebc77687e9dfe403d96b6b63d44dac2a7e72f80228377cd7c39ea858079f93a0d45ebf4277341b0d3078849a1677d69b7cd6baf6ffaf31e729c0c5b8482eef41ff0a503dd1bec600596d0f8c34635df8493552ba5156d178a541206bc305f3e675826138bc3f16df09a1919032c17b084964501b46dbf6e4132e028e050364d0350145531c5dcdeef8e74de86a8864e414f238fbb480126826d8e8c03a94054ef0b5aa28d45bcb94f2d0406c9d7a8a878c8ca4d84d59f39abe8613230005aac03eb29380bbad41d0dffc385f19ab6d90b9a6da401681b2a1a255589357cc4d94d9530f901d0658e262497485de7bb45798a1f1b05c3512443f20276bff824436fbea6d9b14f03417269ee5f8e5a65df02e09b0719251bf316d11e22a26243ac8d1a9e4b8768fe2347b72c82c4ca9c07ff3634b7e7d057edea96a5035b5fe45f1c9751a29860b2f86b3ddbc1c26d053cb491256ba2fb3fdbce3a4f615f8d007c265d096a17b131e5cbc6120bc0053fdc420836262ba545e466f19d6d26946c5952fa05bb76b9c9307ae97684ad0046b8650ff390388f5f3c54172800f141fdf68f6c343982284777753d123fdfde5902d31c030216d33f6b3e73a29dd16de1a4ce9104ba733ac98e36ea588df7c725d25c9f5ca25c72d0c72588c6ec35c336902bf70d1545dfe66bf22ff70da3a59e7a252247ef0139a5d2aa8f9698230a446192ad8bc54f6151949be553fb98bf08f0811653aeefefdbe53247556a856ecb77d835c0d3b2e0a0f0911ba200d82eca3563b4e2192cea0a707b5316000b0212e3ae97c5ac3d93b0f198144924c037711fd6cc644b84d0b91adcc36b52ee3423881a17c85b68efa0f36e576f66797261b7f701242512cf999687243c95af861b98c4629cf55ccbdd1f6e120d747c618fb4e1a1aa9a00e9a4f3ab292680ba2072e54250d2f4706f25bb62c90b3753def1a98803d5b7a588c1610fa8ed0dbf5fcb3e24216de101be488da3edcf3d0e4c39311e8d00de076de53b59a59c3f14c432e74e33f4d40731836081cca1836e4de56d8e8df54ebe6d151f99b5029cbae53241530b9f9d87f1a7b78e4e819b0b68ee0f8ddc6dcf87d9b490f796ea32a24c815528a55871bde1e56d991985ca6c7224e88324522f1acb90cc84b4dd82d6bbae5897161368b7e96d1b67dbca1d933094ae1aedaff3d79d4a683046204815899f3c1fb830cc4458b8f632c8552293d7aa8d0deec36538992f384716eec62e2656cb5157a988421d91de8f8328c8de6f076661b5f2d54d9002e33bc0edf9ff8116a6d3f1f1f5ec6ecb70f8a329191074c1c84c5ea297171017017548b26fb9ae659b1f9236f958d1c16e1fd047bf278f85673ff3f3d487a24ee861a722fc88341eef9f462b00021227ff84c5b5edab8644de0ebc2d0251e8b79ebdb9732b847380c378251e34faad175d8740b1d8f94f900f264873131b43ca002ac6ca4e9648a7f2f98061c5000a2e07982224d3f0af5582ac9b79ffbe0cf3dbb62d201209791b4f8db5f04cc265afa16f111dc274df3f0c07d37e58a8f36c1ff8b56407e20981b339c71fb90712d5ec9dad82e159f7d0782fd40c4d6c75693db3363d77e4d0f4352f7daebe1251a8f463cdb8b2dc64d67fed2b01346bcf9c3d49a1f5cfd5ae4e1f20b0bc50be67f4e183c04a8c6a9e150cf91eef453167a115a92724c9c89a8c296260dfe2eb4a2be1e8e7eb26e49165efb88e81acc11f9baa115c8cef56cda3ec0daca9e6f957040ffcff26c6451734ff1eefdb8e3bfb6c910954b0ec5da65fb2ddee4fd39a4cac97e66eaffe4d245b49f11b55876fce5c9e5b2f56775a9a41650c0925380819a019c4ec49bb1b82138477306ee0a4a59b30ee4beec6e32c56a3fe16c559a3843aa3c1ce10b9a93c451f0973b820777395776b720d7afd0a079439ace38135d505b48fa754e3220355ff121b981a4354596736686ff369e7f49f9307f745a194af392ab62ce40d7b10e5bd0d10a7d388f43c41e69e27abbf0947e22c852583bc18c470937f3ffa31008f2c5e49db89c2342f6dbe924416c8b91f008835ed69b43ea2ee660d71e9bf0d673b723a4379fbf6487f98ea6dc6ddec8fa88dde3a8cc7beefae271096b086261467c26fcc8abb6f104ca254b38df46d5c6bc3f010545b531915b67ceb60f5f77caa957c6b34a87890da511eef6129ceacce129c3a14e3b3b956f02f16d2dd26a08f24cf27d48065ad7987d3bf18a31a4f9065eef56d968702e641bd74ad4cc70f25c3688a73c0679bdb31c65e5324f777aaef1222df569b1a3e87fbfb3b9d1d6f4dd1fbb624927f2dfb51cce43586a2b412486c25a460bcabaaf7faf0fad43cee3edfa24587e23963a9a92d9e507cfca0041444d21ad97a0384473d2b64e5212b1ec4cbbd524ca362e2d2f0765a02213e2da927c15e7fb5a2b278bbbc51a7b2cb5a3869516d92dd6cc20bd631299f5e9dda67cb98bc0a954635f95308c1491a51ce17dc443b01188185e151b52f63e30cff6528df152e31fe03b58204bc932ee43b5dff6f1db3857d5ddc7e6871b9fc936de5c6149b480e997b7988ae387334dd24171587d238f61b772ee975b929d1e102e7ee64e2f0ee91365c829fef54b3052e39e422d232cd9e38f9579da646c45a345580c18321c4f9c71eefe4c43548254f4d4fd2611974be690263832282682d876554192563ca04e19ad37a06b2b29077ef1a7aaf129f4baa6ffbb944350b237627fb6da2e71a2abb7196812bd0f8490f5f329f4fc94c363bfa08a275142a038ca9dc8bcf2c36164cce1c2b463d461183a36535236eb6344ae8892f5293acfcb5cf2f800cea3c903cf0cc4f42ffab0d4ad9bdd58892b439dae229b62e94a8cf8c5505ca645657c566f25250d5197d91ae2c7c11bbb5943e06a0c6adc96c2cf1084d11a4194243c5eb5795b05c1dfd8f04a571ca4ac7820f217b04eed267628a466fdbf0afcf2addfdb2bd4dd7c5547edec67737e0ecb99334b043811d720d22e40ce5b3405b0ce4a5d8d6dbc4018324732dd6282294d410906e6e38e2a6a9bdd0d4072583e9c34dcdb2ce22ea515e69c36f121e205f173a7721c98ceadd9f829748708816097ef2fcd0e3aa41da169213bd0f1434f59e2c6c033314dac513a8f2c9748740d5492e47821146231dea700f11dff1ab95263249e9179ca5db5ca7060e9030b19becd8149e72d2ea51f9513365aa4a858d0cccbfb419f2376512e008c57bb0dbbab5d6b24785dfdd94e2029a83bb361ebf68c9b4925f36360b7c3abb1f84846f41b2bdf67928b88f600620764d478b6233658dfc736501c0c263a993e9acdce370136f37daefdb6cd70c970be9db19632b9e3ee2f52d5091805f5f65011266418f7fddbd7a82f0971eb9575c4aaf0b8f9cf66dc3689d7da7eb60f4044bac536b70d6cb8a4708f77b85fc4514673f168bd982a468242a49428b8fe9a196e6b56df90dd5e1393224fd352b406cdc29f10bb43491315774f8124251b282a539b2bb4479d2db3d5b5f05d9adcd622f09b6d5beca9ccc0adc7bb7226fa6f7b0d65a26801109216dd924d8d3cc4842c8623a77a8e6c0aaf28c92c228e785a5214da0c15ad395db602121fa1f7ae3c0725c555a5074e49b678a207a93745d4e0baf1088ae585a94cb6f72a72b18f38b7f1f381b9b0e38f8856fb0b67eefaa1d7180f9c8092ddfcdf942d85d45ca1f5af28219ce43e5247f2656a08d11e96492f4cf4c1b3c8caeda3bcce301ad72b00361a98e37466ab3552fc41393816a143b6409539627df0ef5b54c453ae46384bf907be5dccd57fa9348648191d68fc15d853a02fe4cc3c97b9d35c1131e5a6a9c4a112f7243038892687b300ad543a59dc853e66af3a53db39bb7935c768b13b2783b66fadd4db3b36d988a63486ef11c3fbd4aef2a41de547da2a80e0f073a7aeec5714d8c8f48539c0ed9d0a8e0831fc416a8c3aed0e5bd310d87fba875b2688c8ad147c1248bc0a56384b91d17896e8b5dcefceeb509251a2b3966e9c6b80c444540343a27702cc56e5786c0fe7923ca98f72a2dfe14d3d07d73fe2336df2a7f6e321c2ac6e97143eb15c32d931c287856004995a2a0ef8934f61a7aa7bf10722c03ed8869137abf9ba00a7e354bbb99521ae5b338e12a536c98a364fc5cdce629c0b78df9b95f59eec3bd956be70902727104b07f6400fe59b8fd9cf32e712802c706c861ef64caa0e327f1da39d48934fbb3f74bfc971e5b2d5b4cb87af3e79fbe1c14af22d7a464254106374dbbae605c4cf208e05e61e4ee2c255b5c42b88b7ee3de22a7d0ace5a9588db6ee383e56625c31b1e00b32a2f772b914bb480ba5c9be71e2bcd9a9b6afc7b27b8413efb01e7b30f36220f2d365516e7663aee64c5079a930b7129d2171de7813d84041824f7ee89b9b60d388602e42c033e9188e0d44a083d02c7c8d693b3a8465b114cdf75457aad3e33bf54501f79ab06a358f0149a38994092de2ed4624f503e972fd4537061b3bab25000e3c0589be8c598cb0f7519ed3835c1a2959fdd53f4e57920afe0c7dab4f64abf8ec560a4a4777445991b0b46522193588187cf4029155907005329f3fc80350332dcbadf8149c05336510e3873f6de78dbd3ec47e866273b48b85fc115f3c5ff3e90374144616ddad31f47a40e7ceeddca82aaeeeb3117832834feb696065085849cba86b7ed73ed7a74abe7ec45cf4b6cd3840f03a61d4f962274bfc01753dee19f93ea6af0b6b8799f4e24e3830d1a8b905d9c0e2a31279faea3a02622dd370dd6df2e561695f27157f75f42c8d57662dec1e5e27044f762250dba6e9ddd06cd4c7a6c4f179942367a9c58905259f11b61dcc3d0e0adf585b17a9af6b4020572a1af2380c3616b57fa1a1a4e95806227f3fa9062f6d04c14544529957f0aa10705caa9cbd870afe824c02a4baf5d09df23c6ec4f698919a4f97515b8f2d1b45e5a2b76421802a5bfa24216f9dddd435ee852a2386948056702ad0cf28a796138a3488a858cd53bb3a93ac08632c08602d2ca69cd36d9d37762ac438d5dbe9b2d100ffb87269d008e2cf2ef63bee34fbfd921411b186f47a107c5fe724c6e1d16b46519e9f0d5f688db39e49b29a421f7100e8039008b1812ab4bedeadcec5f672bac68d095933fe2cd1b036e6509263952403a3796ca9ce83f1bfa94cdde982e4acef1f3e218f8acb56616b0009db4d63aa33319166ae681170df98bcee78b32b2d38fc4648bb36203cf4c7ce7ca2cc0505bccf4965a4f61c4a1aecba28d1ecd8af363c2739e496717f2bc481c9537a5fadc07227beba6daec99d167d5a8d732fc68a22cad20a506c0a92e275c8fc9012c9f910359b9ee6fa386f61978bb36ad26b1ad9824ffc524f70a7568933e54be838858399f45d3b895cea98a4673937bf7bdff511c090ae80fbcaf0e5693e0222166d5b1f9316a51fd0cf15fbcacec95bc0b186c44af5f0b3d2326d69a723fbde7f64fab38d0ec84bfe44b10b0165171cf1fd06eb8ee289fa582bed72c9f63b62f8fe6b60cdee25bdab660439714462a18368d544f496da840543337c17eec997d97fdc1894383c1960060451f4d69e5d8a869d5da6f069eefd225b2508602292a8eaecc1c82f5162a7e5846b7e628bd054dc9c1e40c9d139fe57d1305866d8af218377a32dc8a19fe7b37f7c762dddacd3761637d24058a6d3aa7a56fedd81e454cd3a04c925848e7800290194243f82effa9bf53daa095874b34edb23092b3843f6fb001a102daf6e251b4fc1de1453ca1ba0a16dc7d3737bb37b7dd6a5f4f63b20109332c5b614e0e4795b73edb530b7e697034b9076f1baaf4c6dda8b9f8f6360da253055e829ca7ea20d32f5bea6140839707a40cb83643a16aa62d9ee4b8f45abd374940286d55cd41439ede2cd319274ef75371e2bdba6ac6bfdee8aca7a5b4273751550d5630aa682292fa5f975315e3a463dbac80aaed57888e92601373ff0a3040388a726b8029c8a7f7a337bb5a64a9910f9cbb0d093969920284a40b0e1d2ef4b6e6c41abe2e731c2491ee161df14eddf3f05c4e91881bd4c90e841f850e2b9cb6ddf5ee57078ea68bcd6e9cb0ff92bd5be3cc6312594b88f03cdabf5d7e707389c0aa66c7b756b09b2c4b802396c45930d27472194ef5805f1c825648c62e7cccd64066796173ec78e5e6546777749eb8c37e9f7c7807b673c6f7bd60976dd6831c9e3db85174f37e21a49b3345d3488e0f1f079371b8353f63a4968f3ad8321c92e6db54e88cb210b0818a7d3867401d3e87b5d894db7692a849dbcc58c8670fa63240685416795640909b5b9cfdb42c17a602cc4b66b43269f88bf9039358364adb896373f4c74e4acc673d529d6989b5cb17274c31fb9030a4f42b0dff358a8bb58b007d80cb7e692fa6e00f54374353ce159a7b11578e62b83dabd0a89a6718f95729db65a353aa50c6a204dd2ce29ab20a9da5bbaf4094d0e4661411cdbd3c804bfd7193f99bf67eecf829459addfc77adec2eb2879e01fde62c0cb82c1811b92e2f1c4cf03b785d28f72acf1950e4ed397ce7abd6e7be7c2cb2971407b1f6a4cdc3b6c5e74200ffa36969c4dd843ef3c6b18757bbf5ba7dab3578d444945d5cce2d09b12ee6ada396b71fa58e40f704c3bf147836ca99b7d06132d7de1ffd872369c1b4bd9599663acaf4971f6f006e2389957e949a9ff9444adedde502ea30e336f183eba5c0e46ec10737efc116113a6c654b88077a0020e5b16f7e2dedfbd12f299a820694fad0f1253f2b4aa77d4aaddf2251323e074be85be30c39641164f0160b5aeb7b1eabdeca85b19779076ef60f99106a5e073c37cd112c785ca6d28fb3c5ac4cd57f361568d62f0ac0ba37f7a3ea10908084ce3b6d0e53898972cd307a5601ddfc23d317578b18b18bca5140e17e11735590c7b67cdb236183f8dea717532ab567e6a34596350e052dbf48559bf4d161a2bf9c60fda9c0579760168959a832c984e4477cf0a96bfef06f0dd3ba28a02ba6bf9c20998ccb334a336a1830b29054c6fce94b8a4ace3f447b69bdae3fb45c19d71e89e0e1015705fc0ead0aba83fd4b4b568caa0188986002a9b361dd9404443c9c6ec517ae2f3ceb57b24cef0d7b41ce16d1a40c097af99dcc59020cbc26cc2bde1ae515860e3986d3a7c55e4db63be958ce4b1d32b70d178b83dfa72399b310ecd2daf9195b43713030b20a697e85aab34e2ae959e9637bdcc504ff836c96bde40c89afa5d2640dddee705e7d3e9d4ff49c817bbc21c3e4b88353344ada8529c6511e5ef29bf1471d6537599e26c5653cb798391035226f753d05c87429f31fc6dc73c75d2ed67012fb4a55923f0fd4061ec094b14764770f865de153c3b5fee0c15f59dad37de41b0fec6a5a8160fc1874b5a299b1a9b629e23a690854b2b3301bd017c8b1586351d69fd06c06cec814ddf14f05427e5c7aa8634762189db4d2a38d212768fce07303e601cea10a55c453569eb2176078b1c8009084803287564dcd71bf8ccfd116e1b2c172a06e6f499d5fe4d2e86b1e4b4d156d7ae33c34b1d786775f1e5d2bad52845cafd501de8809761ebe1b56c4459007366aa60e28a7766377164a32e5045ceecd43ad69854e2fa3f0b518388b49acc78c3da865ea0164df6db7c7dc2590f8393ae9fdf179cc3324d319bee67c7448ad40980fbb4634e426f570dcda36d18724a43e76af7f95aed1ca781b1cc48b6ab69eabb41cfb2ab2b962eb49b21dc77e29bdb63822fbfa0312d5ea8afb469ce22b86b0c5392db2460e2c1382852090ea24d2799323e9c6e45dad81106e8818b6df97cbad67b116b1c0846edb739f49fe03fa3321dbb276ebcb331dbb6132cb4539a20f54e1da0c86ee04b61a7df70e2974f212a532f052032a30e07bb7a13e46b0f98871fa443e2ff727d3f3923b5ecaa1e62486460f31551bad804d9cc5c5f45389d3cf564712efa44e7518de99aa84a91e69b4e27450080ce62b7588565838d3ea8fbb0687287072df4f43058bc74c9b51f75cdf65bc62d404d3d5f8109d74dd60e37d4bcd76229522e01c400aa52d6571caba1952cfb78cf6a6b69e73bca14747065095ee0023f79290dbd4946af5115c03adaa587785f6684bdc2069819f3f7987920b5e6c6907af8548b38ee4af8159e558c449d9b36a749abbd5dc8e6c5a5279b63a74b2169cce35d716a60d92f36b9c0207691c08fe58befd86c53fd8e54b00f3ae3d4dbc9043a2d5c24e541f8b8f298409f956c44e472510476b5ed5163d972543eeffcf0597e578d6594d068412a05dca55428474faab2f7ba7d57f1a59c1df36ff807cd21f2cbdec22de713eeafb08796f8b43649afe7d28fb64360bc5ec3eb7230e9a2999774a1f012d5c754dbdb260a4eb95192335f3889ca4655465cee2b6029e586ee3bae4068dc0be4580eb4e402be3e03645436e7047d0eb91f2e483898eabad4b9c381a287c1380632b02270bf8fd871e42720b78995162820dc2bf39c9a42c405f304e195b2fd1a982066a4911c3c656cbb83b9e068f4c3a1f559e3a7aca0f73bf757ac136db3c089106b6d8509c6c7f2afb4a0076da57b5da3cb92d89a47b9ce80899b7a62f6ed82469a52c0b065cbf2197f47c6543c760c3746fa4e19b77edb516a63235040c5b481924954ae1e59ab2ebeb24655bf22cc2c8f5d7d37db8b3d99c058defff02bd432b71bae0417c13cabfabfde1592fc6e484c93540743e857375ea1e49a6de2e2de8d5dc998cf4e2ceb8fb9e5ef8e1183e1ea02527ae57fdeaae9c3821739914a0fd77a13bdc89c9db798c2ecde29b4440b69bc638e8baeb4ea9596b0977b4dd50c0767a827ea99d8ed6bb8b8791b8c73d3d5baaef9966617552b2b1ca6a12eff6d9291fdc8a41adaec28f2e4f078946e980e23c9bc01d13a87daf49df487b7f8705ca128324f4bdcf62dc125520ff4983e79b4be7159e8ebb34b614d5af86c5314c8b764d47b4cd7be68c5a4602eda8ee58f445666ee1ee12b28bc4cda17c4f491887925002fd2567310acf29e910f27f8eae3da562086fe040d6276f75182e80018eed4df069cc7685f7af79d637a63bf1c50111c18195961c12df4b58e6a902e89ed8816b34c4f91bbe74914258ca14d4084123358709455fd42af2ed930095224d26a9fd3bfd9762384c03696b08c6651ac38506481402171df9cd21aa0deb5621cfcaf40fe2388065863480fb0a9c790db24e01225e2a256da673d74855036ad4d6706629578a60b5d45dbe3fc8b290d754fd1e4de3b4015df45fe34c0f8170e973117a250dc61e41cc3af84d2a2718bb186d9018f12c17bc6e3e2c46cdd47ffdac535e3aa195ea01666f19eca1f1e15451088a326bcf9580138515ce54b9102fa4249367711efd59bb5d1d49361a88d8f60f9bef2d57af18af4324a3336b9d41faecc377b313e0fbecafb76ddf7753b209c9bc1635ce2a78b5f5e359b72198fe0e1dbe6d13913bfb743c036ec091c534366264162fd6d74bb9554eefe78a1a957ee863fcfc084f665564186073da06048473e0225f2a62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"6f57a9311bdf85d549a36969e06aaf7a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
