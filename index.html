<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Adam & Helena's Lists</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        @font-face {
            font-family: "Geist Sans";
            font-weight: 600;
            src: url("/fonts/Geist-SemiBold.woff2") format("woff2"),
        }

        .staticrypt-form {
            font-family: "Geist Sans";
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-toggle-password-visibility {
            display: none;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            border-radius: 10px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            border: 1px solid black;
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #ffcc33;
            border: 1px solid black !important;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #000;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffcc33;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #ffcc33;
            /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #ffcc33, #8dc26f);
            background: -moz-linear-gradient(right, #ffcc33, #ffcc33);
            background: -o-linear-gradient(right, #ffcc33, #ffcc33);
            background: linear-gradient(to left, #ffcc33, #ffcc33);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
            font-weight: 500;
        }

        .staticrypt-footer {
            position: fixed;
            height: 20px;
            font-size: 16px;
            padding: 2px;
            bottom: 0;
            left: 0;
            right: 0;
            margin-bottom: 0;
        }

        .staticrypt-footer p {
            margin: 2px;
            text-align: center;
            float: right;
        }

        .staticrypt-footer a {
            text-decoration: none;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <p class="staticrypt-title">Adam & Helena's Lists</p>
                    <p></p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password" placeholder="Password"
                            autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="template_toggle_show"
                            title="template_toggle_show"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator =
            ((function () {
                const exports = {};
                const cryptoEngine = ((function () {
                    const exports = {};
                    const { subtle } = crypto;

                    const IV_BITS = 16 * 8;
                    const HEX_BITS = 4;
                    const ENCRYPTION_ALGO = "AES-CBC";

                    /**
                     * Translates between utf8 encoded hexadecimal strings
                     * and Uint8Array bytes.
                     */
                    const HexEncoder = {
                        /**
                         * hex string -> bytes
                         * @param {string} hexString
                         * @returns {Uint8Array}
                         */
                        parse: function (hexString) {
                            if (hexString.length % 2 !== 0) throw "Invalid hexString";
                            const arrayBuffer = new Uint8Array(hexString.length / 2);

                            for (let i = 0; i < hexString.length; i += 2) {
                                const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                                if (isNaN(byteValue)) {
                                    throw "Invalid hexString";
                                }
                                arrayBuffer[i / 2] = byteValue;
                            }
                            return arrayBuffer;
                        },

                        /**
                         * bytes -> hex string
                         * @param {Uint8Array} bytes
                         * @returns {string}
                         */
                        stringify: function (bytes) {
                            const hexBytes = [];

                            for (let i = 0; i < bytes.length; ++i) {
                                let byteString = bytes[i].toString(16);
                                if (byteString.length < 2) {
                                    byteString = "0" + byteString;
                                }
                                hexBytes.push(byteString);
                            }
                            return hexBytes.join("");
                        },
                    };

                    /**
                     * Translates between utf8 strings and Uint8Array bytes.
                     */
                    const UTF8Encoder = {
                        parse: function (str) {
                            return new TextEncoder().encode(str);
                        },

                        stringify: function (bytes) {
                            return new TextDecoder().decode(bytes);
                        },
                    };

                    /**
                     * Salt and encrypt a msg with a password.
                     */
                    async function encrypt(msg, hashedPassword) {
                        // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                        const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                        const encrypted = await subtle.encrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            UTF8Encoder.parse(msg)
                        );

                        // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                        return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
                    }
                    exports.encrypt = encrypt;

                    /**
                     * Decrypt a salted msg using a password.
                     *
                     * @param {string} encryptedMsg
                     * @param {string} hashedPassword
                     * @returns {Promise<string>}
                     */
                    async function decrypt(encryptedMsg, hashedPassword) {
                        const ivLength = IV_BITS / HEX_BITS;
                        const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                        const encrypted = encryptedMsg.substring(ivLength);

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                        const outBuffer = await subtle.decrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            HexEncoder.parse(encrypted)
                        );

                        return UTF8Encoder.stringify(new Uint8Array(outBuffer));
                    }
                    exports.decrypt = decrypt;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    async function hashPassword(password, salt) {
                        // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                        // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                        let hashedPassword = await hashLegacyRound(password, salt);

                        hashedPassword = await hashSecondRound(hashedPassword, salt);

                        return hashThirdRound(hashedPassword, salt);
                    }
                    exports.hashPassword = hashPassword;

                    /**
                     * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
                     * compatibility.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    function hashLegacyRound(password, salt) {
                        return pbkdf2(password, salt, 1000, "SHA-1");
                    }
                    exports.hashLegacyRound = hashLegacyRound;

                    /**
                     * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
                     * remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashSecondRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
                    }
                    exports.hashSecondRound = hashSecondRound;

                    /**
                     * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
                     * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashThirdRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
                    }
                    exports.hashThirdRound = hashThirdRound;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @param {int} iterations
                     * @param {string} hashAlgorithm
                     * @returns {Promise<string>}
                     */
                    async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                        const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                        const keyBytes = await subtle.deriveBits(
                            {
                                name: "PBKDF2",
                                hash: hashAlgorithm,
                                iterations,
                                salt: UTF8Encoder.parse(salt),
                            },
                            key,
                            256
                        );

                        return HexEncoder.stringify(new Uint8Array(keyBytes));
                    }

                    function generateRandomSalt() {
                        const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                        return HexEncoder.stringify(new Uint8Array(bytes));
                    }
                    exports.generateRandomSalt = generateRandomSalt;

                    async function signMessage(hashedPassword, message) {
                        const key = await subtle.importKey(
                            "raw",
                            HexEncoder.parse(hashedPassword),
                            {
                                name: "HMAC",
                                hash: "SHA-256",
                            },
                            false,
                            ["sign"]
                        );
                        const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                        return HexEncoder.stringify(new Uint8Array(signature));
                    }
                    exports.signMessage = signMessage;

                    function getRandomAlphanum() {
                        const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                        let byteArray;
                        let parsedInt;

                        // Keep generating new random bytes until we get a value that falls
                        // within a range that can be evenly divided by possibleCharacters.length
                        do {
                            byteArray = crypto.getRandomValues(new Uint8Array(1));
                            // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                            parsedInt = byteArray[0] & 0xff;
                        } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                        // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                        const randomIndex = parsedInt % possibleCharacters.length;

                        return possibleCharacters[randomIndex];
                    }

                    /**
                     * Generate a random string of a given length.
                     *
                     * @param {int} length
                     * @returns {string}
                     */
                    function generateRandomString(length) {
                        let randomString = "";

                        for (let i = 0; i < length; i++) {
                            randomString += getRandomAlphanum();
                        }

                        return randomString;
                    }
                    exports.generateRandomString = generateRandomString;

                    return exports;
                })());
                const codec = ((function () {
                    const exports = {};
                    /**
                   * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
                   *
                   * @param cryptoEngine - the engine to use for encryption / decryption
                   */
                    function init(cryptoEngine) {
                        const exports = {};

                        /**
                         * Top-level function for encoding a message.
                         * Includes password hashing, encryption, and signing.
                         *
                         * @param {string} msg
                         * @param {string} password
                         * @param {string} salt
                         *
                         * @returns {string} The encoded text
                         */
                        async function encode(msg, password, salt) {
                            const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encode = encode;

                        /**
                         * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                         * we don't need to hash the password multiple times.
                         *
                         * @param {string} msg
                         * @param {string} hashedPassword
                         *
                         * @returns {string} The encoded text
                         */
                        async function encodeWithHashedPassword(msg, hashedPassword) {
                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encodeWithHashedPassword = encodeWithHashedPassword;

                        /**
                         * Top-level function for decoding a message.
                         * Includes signature check and decryption.
                         *
                         * @param {string} signedMsg
                         * @param {string} hashedPassword
                         * @param {string} salt
                         * @param {int} backwardCompatibleAttempt
                         * @param {string} originalPassword
                         *
                         * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                         */
                        async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                            const encryptedHMAC = signedMsg.substring(0, 64);
                            const encryptedMsg = signedMsg.substring(64);
                            const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                            if (decryptedHMAC !== encryptedHMAC) {
                                // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                                // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                                originalPassword = originalPassword || hashedPassword;
                                if (backwardCompatibleAttempt === 0) {
                                    const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }
                                if (backwardCompatibleAttempt === 1) {
                                    let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                                    updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }

                                return { success: false, message: "Signature mismatch" };
                            }

                            return {
                                success: true,
                                decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                            };
                        }
                        exports.decode = decode;

                        return exports;
                    }
                    exports.init = init;

                    return exports;
                })());
                const decode = codec.init(cryptoEngine).decode;

                /**
                 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
                 *
                 * @param {{
                 *  staticryptEncryptedMsgUniqueVariableName: string,
                 *  isRememberEnabled: boolean,
                 *  rememberDurationInDays: number,
                 *  staticryptSaltUniqueVariableName: string,
                 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
                 *
                 * @param {{
                 *  rememberExpirationKey: string,
                 *  rememberPassphraseKey: string,
                 *  replaceHtmlCallback: function,
                 *  clearLocalStorageCallback: function,
                 * }} templateConfig - object of data that can be configured by a custom password_template.
                 */
                function init(staticryptConfig, templateConfig) {
                    const exports = {};

                    /**
                     * Decrypt our encrypted page, replace the whole HTML.
                     *
                     * @param {string} hashedPassword
                     * @returns {Promise<boolean>}
                     */
                    async function decryptAndReplaceHtml(hashedPassword) {
                        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                        const { replaceHtmlCallback } = templateConfig;

                        const result = await decode(
                            staticryptEncryptedMsgUniqueVariableName,
                            hashedPassword,
                            staticryptSaltUniqueVariableName
                        );
                        if (!result.success) {
                            return false;
                        }
                        const plainHTML = result.decoded;

                        // if the user configured a callback call it, otherwise just replace the whole HTML
                        if (typeof replaceHtmlCallback === "function") {
                            replaceHtmlCallback(plainHTML);
                        } else {
                            document.write(plainHTML);
                            document.close();
                        }

                        return true;
                    }

                    /**
                     * Attempt to decrypt the page and replace the whole HTML.
                     *
                     * @param {string} password
                     * @param {boolean} isRememberChecked
                     *
                     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
                     *   expose more information in the future we can do it without breaking the password_template
                     */
                    async function handleDecryptionOfPage(password, isRememberChecked) {
                        const { staticryptSaltUniqueVariableName } = staticryptConfig;

                        // decrypt and replace the whole page
                        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
                    }
                    exports.handleDecryptionOfPage = handleDecryptionOfPage;

                    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                        if (!isDecryptionSuccessful) {
                            return {
                                isSuccessful: false,
                                hashedPassword,
                            };
                        }

                        // remember the hashedPassword and set its expiration if necessary
                        if (isRememberEnabled && isRememberChecked) {
                            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                            // set the expiration if the duration isn't 0 (meaning no expiration)
                            if (rememberDurationInDays > 0) {
                                window.localStorage.setItem(
                                    rememberExpirationKey,
                                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                                );
                            }
                        }

                        return {
                            isSuccessful: true,
                            hashedPassword,
                        };
                    }
                    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

                    /**
                     * Clear localstorage from staticrypt related values
                     */
                    function clearLocalStorage() {
                        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        if (typeof clearLocalStorageCallback === "function") {
                            clearLocalStorageCallback();
                        } else {
                            localStorage.removeItem(rememberPassphraseKey);
                            localStorage.removeItem(rememberExpirationKey);
                        }
                    }

                    async function handleDecryptOnLoad() {
                        let isSuccessful = await decryptOnLoadFromUrl();

                        if (!isSuccessful) {
                            isSuccessful = await decryptOnLoadFromRememberMe();
                        }

                        return { isSuccessful };
                    }
                    exports.handleDecryptOnLoad = handleDecryptOnLoad;

                    /**
                     * Clear storage if we are logging out
                     *
                     * @returns {boolean} - whether we logged out
                     */
                    function logoutIfNeeded() {
                        const logoutKey = "staticrypt_logout";

                        // handle logout through query param
                        const queryParams = new URLSearchParams(window.location.search);
                        if (queryParams.has(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        // handle logout through URL fragment
                        const hash = window.location.hash.substring(1);
                        if (hash.includes(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        return false;
                    }

                    /**
                     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
                     * try to do it if needed.
                     *
                     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
                     */
                    async function decryptOnLoadFromRememberMe() {
                        const { rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        // if we are login out, terminate
                        if (logoutIfNeeded()) {
                            return false;
                        }

                        // if there is expiration configured, check if we're not beyond the expiration
                        if (rememberDurationInDays && rememberDurationInDays > 0) {
                            const expiration = localStorage.getItem(rememberExpirationKey),
                                isExpired = expiration && new Date().getTime() > parseInt(expiration);

                            if (isExpired) {
                                clearLocalStorage();
                                return false;
                            }
                        }

                        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                        if (hashedPassword) {
                            // try to decrypt
                            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                            // the user fill the password form again
                            if (!isDecryptionSuccessful) {
                                clearLocalStorage();
                                return false;
                            }

                            return true;
                        }

                        return false;
                    }

                    async function decryptOnLoadFromUrl() {
                        const passwordKey = "staticrypt_pwd";
                        const rememberMeKey = "remember_me";

                        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                        // since it sends the hashed password to the server which isn't needed)
                        const queryParams = new URLSearchParams(window.location.search);
                        const hashedPasswordQuery = queryParams.get(passwordKey);
                        const rememberMeQuery = queryParams.get(rememberMeKey);

                        const urlFragment = window.location.hash.substring(1);
                        // get the password from the url fragment
                        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                        const rememberMeFragment = urlFragment.includes(rememberMeKey);

                        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                        const rememberMe = rememberMeFragment || rememberMeQuery;

                        if (hashedPassword) {
                            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                        }

                        return false;
                    }

                    return exports;
                }
                exports.init = init;

                return exports;
            })());
        ;
        const templateError = "template_error",
            templateToggleAltShow = "template_toggle_show",
            templateToggleAltHide = "template_toggle_hide",
            isRememberEnabled = true,
            staticryptConfig = { "staticryptEncryptedMsgUniqueVariableName": "de6c16dd0ff50737a9b01fd2ee63c98c11c3bdcc7613e25c28e42c62cef0b2044f8eb00a802a5536f4d9c4a993de516fefb9fb97a6d89c2d7ab8850d64662bb733934fbbc803c07fe451ec712dbf712d36e99dfb9313c2b746ebcc7eb5dfb8cab307aaa22046238b0b300cfbd0241d5c64958557d5119f9f58894fd1169d9440bc5e2e32f71163739d64af7040ac22515dab0ca133aaa4e80eadeab1eb23daa722eec549cf037a18621b7855e8bd12a60123603e1a45a328e4a5b3ff3904a6a5036e1618f7b9ca66618a014eb4de8303611d6c1d3900bd53f8d741dd931759b5753159f92f9f84e76ee36aa3ae937e1158b09c45e89d6a248c14e9aaca97fe9417fc1f72786c740414b34d6baf62dff69d815bb9263e3dbcb8e65d41ada4b83804227b156667abe7afaf53a240a1f20a4fdb6b01b94730d9e5cf1058a92fcdd12f241e78613f98011d5d4cd59ec86cd1a0f9c5eefbcd16bfab55ea3e476c0dfd56f4c4f1fdffdc8d75f3c73d2667579a7ed8eff9c987539597c7780cfc7cdd1d34ed5332ca1d98fcf80bbe01b916ab72231b298650af062a35679742346501ab611f9083132dd12bc596856b33e2899d6d1266ac8a29c3397f0ad9d15b57369cd89db7a711f0f9771e117624e4750e4c4907acdd71ac5920b13c7e98e9a537b4e6515028fb1aaf7fa464b6a3bafd5d8045c4a81397c200bfe3591efc88e027aef92c34790afb71eb0c5ce187f3d50fc89a9989cb6e01cefbf149573c374cd95b734a3043070c0e57a6f62bbe41a75a9dafa747eadb4e05f0a40eefae4e68e01642f17a08c14ce114ad44110747ad09ef0b0f6a96122a928ebd07e6e047acb397e594cb4a1d43ac57951d425c23e576ef673200a35054319c130bfd6d4f52048a9390e2f36d4211ee8300cd4e7061a8d6c7348d71d9434a05d2b541ed571e9b16697eef4c02e20b582f658a457d341d3a95a74c12b6e0867a88549e752bd49f4aa234aa08c4d98b3e1009a091446a359c64fbcf75c6a98480f781e63be475f13814634c3a410290d2af0343da7858017faa7733d32b5f50a36ef06f8c284123757f2bb0c9784192d67dc1e4cddff1791c29b6523b69e99093dd57ecafaa5c3b839b3de5a2c98118c88b767c76dadae5b1530f9752dd1e6578c0201220ecf7008a6ff11f8ffc968d33663a992bff3ee517cfc72ee308e60c784f33945b06b029b04e56ba30c687e0772c530087e002857361586fd827a878354bf6084fa32dd5ab2f479dcdc0dd36f8d53f1b2ae4789f248d195483228af88930687f8865d1fc7a7f7003b67459eb329bc5a800a93b6923a7e9b4565468c897969c30e84eebc7143af21534b9ad872b4bc07db877d07a91ae2de10dec2fb27bf1df41334d2c252445368fd4dad534573095da3382e249135806f342eea209cce717054fd770176a98a794afb5bf601e9ef4cefdc192c532904df96241bcbf3cc32e7f05e1bd53a8a5f3d50c699209834eb62ad4d0f0329fcff1049f93811458aa81fea9d279eabd477c19f90ccc4da576d45a87ca2f0dcc71bf9d37d3dee124263dd61f2ab5b0c4dc3b31dbda806609e14c01f02f90a2bd9d6cc3b3f19029ff556d4555e54d00984590892758744577a8669910bcf713b92d43e824e86fe2a10c22dac89186657320617d5de0dbaf71c4e8b40f6025c64c3b81b20e23a4d2e2399e5fa13f87c920556ea470b49afa9b936d36e15e3ce01f5762e216f5a79f77f8437783f625b13005b11705bd35a400a1052b22282cddde35fb0595dc005165c6cce4ff1bf400794c58c4cf94612b198efe6777a83c3c33b31ebab9a0dd09706c9e10227099d31cdb05f84559fd86c34b5496ab11af66ece391273d3a341d17e9b15cfb4992bc4182d51072269d6cade04cff35656ce130f8c9364231a3e62494254a56e4b6aeac09f83ef4a103ef40fb9319bdb5149585d7c66f9ae81320ac5a1aff621fcc902d9a086259eebb2a07c176e2ad47a651cf934a3f30abddda80c20d900d74f6550e85e9f3b8b566b6dc0b84d2d42c4b2aabe8ae5b95cfc19d6b9b5bc640858256213cdb6a94cc5715ba56d22007c96e73e6c7e74c9fd94ae18006f38b06923c2f39e5d48a920aa45074d1e97c78bcd16240f782d5a48f594defe6f47f99a178d880cbbf72c786c0beff28241fa566fb4e559a5e34fcc4840508c63d1601251e990c2b7f794865411db27d59fc1f78a9ac0256e8da0bc963a968e0fb630985e2b5b58d6890b05d89877772e6c9ce5a2287cc1faf4dd1d2614567d1dece9ea0cf3b6d0cec7d5e48faa328f5c4e21bf9b4fd5b1b11db67745408ce652a84e820889da82e4a4a56c4c7ef811781446b314c649a2834b7d290fb1a0150e6aed114ac112350c94a04e9c473a03bb2df8f45242aeb2df6e825cfd0a7b06723e1f62cd94292ff2120f45b0a47a1daf1df90b1f49df353e299a0267510a9e8872d98c5bb039230b82e98398d386c4a6036585c898379a0a4963581eeed53d83e83b2ffb1213ea493edcb0c2c92e028a31e86edf71628132ab575403094b0db7b80c2c578517be19e356ddca07543d09bbdfb7e4bfe8217cb2cd2e0d8f9be3ecb4ac235fc315552ca92414b9ee986906235db2d893c6bcf572b48ed791e1ccd6268a594b45a8082e22d3d9b30a24e95df0c7c4c22ca7f765f029aa8e4e5bb079e1870bbb79dcd40b1f46a52eb1586dff288ed330dae0c6ca622799228d607a694491d38ab1020a101157185954837a34fb3d1ef177d8ecb40794a7954d0e059abd2164cdde596434a58c732b715f57668e7ade9062fa88e5fae12c4f655769c0e1b412d1c160c2b937f3b68e68cf7eb86039317f7f22f773aacef786d1aacf67720b7c7c5513eda1e7e73f2168cfe6f19040b34d86f5014db088559157f7cb46b5d06c2922e458d00a336a3f7cd0b82050dc97f7b62dc3ea018eaf3d11a75b6fb8c078872bbfa076ada224c655670577e9ef6e4c2137dad71a441f56eb82c808595b81dbe46e64c1fa235a5889066baec20a40c5fb1d132c2d44fdf301a870f94c8b7672b26d2f246da3a81a38b05c8077a6288f8691f85bf101c031b9af305586f602eab4691ea5b809924140b4e1cffefa46a4b6670a2bf987c6362d06b97fe43dff489210c2813dae9ec132f2b1fdeab553b72ce7ecac1ecb6a8a921716c4a19eea86a437e29416484077ec32fb65d31584fac23da5002e262da930163ad6083ef25b04bd14c1de661939a1351732ca3ff35fe62c1d3f37109829d4667adae796ab0d3abbc4fe1e88f8dbdd45ed745f21aa3a273d20740590f066baa2e8a3db5183c8e1c2d3d3bb2614dfc047e91bb1e892e372bfd275b83e7efd45c1060f91e821abcfa17a05c911257f0eb3a6ecf4e9ccbff347c2a1b98647cbacce72209d712316adb9496ef679e4af661fc3f4048d0dd0c4543873e759a33c5ba34d441b8b71c5d2dc083c1e30a59de3ba9ceacde3ea0dc9a79aeb0dce171d3123617a1aad03ee9d1325a6241cbed7c01761e1d5a6c6f7c580f1454754988845a31288e90945438b0895cd71f9c9228d522ffb90b0f6b4a1d974a77d6a2d0347191e4ee4ef2f8bbdd15e0abe45c835b5cfb6739e26853f52025f2810da4469b17e433c1d580402398c13b576bacb4d785d11e3bb6bac81fa923b66df516e935d381748b7c3e19ec7e96c68b9563e03ca508f566cc3e309b0390e75b577d1a5cca213d861ab4d3405658843cd938093d905be3a15a58c1fbbb5ff0fce6f1f58541124a4eb474c41da361db0ca8c4d005c02aea3572a3ca3184fe086b3dd68592ec6e1c88c586dd0b2b9dc2ea80c4e800ad7cafcb79c67390eb6b2f2a04d8429200929b12681c38bdde9ea2d2fd6bee145d07b48b9202165f927edbe846890115f29d0701f6ea76c13dd8e43da73190cb81c3fde2fa623a5d13817ba4a4bd5e5808092036e29379e762efd76249d8cd5c4671990b4a08d70cc84b3901b1f692f1a07499aa089fe1d03b17693e8a202c0017ff471aa0f67d3c6f12ffa0d89b0e95bfc0e3d66e7cbf3f722a3de77dbfdb2c8867e0df9546c723aaae89c1f3ee8448816e0e2a1f60d7c5332081bad527a065fb51aff62c5242c4bbc9b117ea5d9fb9b825295f3c94d43fa00a2a57cf7c44ceb8d656be2c2dfdbc2ee180b8285b6f7261d9804bddb9e1c2df393bc686d667b8d6e19cc75dcd55bd4b0f47c72f8494b545af104069b6d2a96304f55ad73372a97e40aeb629ba99f65747d5e41bf7a52e1b172605914716a734b8570206c011a729a439df8aac9e669c7d9199c376ec165be04a78fc5de571253a54ef8490785bbea4f98c8e716adcbe20343847c46b6157fd8209dc3f76cc0ab703f711520c9aa7502d7d18122808761267dfa4c1408998b7b26a7a54f8218ce585a7651627c6bdf8a876eb13d50be27f6f72f077c7ed4a928e0ad1403c6e182b7c242de54eebdbbbfdef5a7a3414dfbc2d0f1621632ba6d6b6649afdc7f5a51f5f4fdaa8d1b48dbe07a93e6873ed0b067600353b72adedf52234cc9ff53c5537532ecfc69191a3ac2ef4c4d55b542cdc7f7322044bad3ed29d405cef904f2904dd01482b9adcef18997473457ed39572507b04f5d4e35f5cfb369f760057130e89e01833a8fd18ce8baa2d9be4c4e00185acd978045a8157fe8ca841bef13c9aa00c32b9e58ab01ce501f2768c9e6c088da3ed8bc13bcaab654fbc7531eb41babb7d029d36f691d7cd5541f38834be9ad0264a3c87b0275c527f2ea8c4fbfea7f860f9a70c530330f2b18b063b71e4cc77934155e0c9e0b57ccdc5e6c5edc4ff43a9b16d5b5e88145e9983c2ca5d45b58e615f0c6a3bdcbec4fb553fc73197025b8d8ffefc23fccef3d2fb23b48e37494da82cf6477c4817b1d8a16ecfd8f902de28c731eea442521a52c1d9effdd13db8b2d3462ce5a17c5f765a036d7628f20b5fd1345723ec58560c9d7cc043583f7ad50c4554e5f182304671465dfacb1103b713a8da0a60cef23a867b88ba6c965ba909092c511f58c74e4e713c6f4fc38e019ef71a0177a315eb8bef08e190918bc31aa7d64326797569834c8c876abc36520d59b770797b62a144cd694814708dbe2e198f49003ef202892a23b04be4f842fb8c0409666e24ae7370c1077d4b2ae2690d57361a3229e75643c126caaeacdd60d212266e0ff72d32c42c2c1e748bae3ce14c6e83a7e0d4477b8d2a7782fc0a84486620c087de52ac514e4efca494f5eba1353b41c566c711d4437b3901e82d663c22ae9ce0aceb34a4831630f2f333903f8ab1096ff9213f11822aea7597403a6a8a52c6c3fef785a1b2440538f5a4cdbc1a5c5326eceae39d4cc0fcf5ed231bbfe5a969a2385358946d8f99fb55aaa67c472dd8d1099492067baa80da97c280136086ecc9dca0f299f0de0dedeee829165b17b7c298049c44b775cdc7e72c333d9803e17068bad8132656f7b15b53195c7931c7fbe9bb8ef7438902e68e6706033f2e4d55500f757ca18ed8badbf709257ff9d72f8de9890b45304aae28be6e40dd96c7d869168becba6942b9ba47ac0f31ac2c366a0bc1a4a307a34ee39fcb050f5b1e8bec53fba78f6b7f7313e191ba5d1c3c27f71c8f64c92df9f810da61dd7254e053b697684e70a571c97ad68193a7fbbf10b32aca9b818a988ef71a2e305fe0962209178643cd08b7d88289cde9f948f2efb980f563e9907e9a196dd6b04180bc71242c413523bdd40b4508d2d2494def9726d9f5270e2146ad74384a6fde3ba50bbe65dff8f933b8601fd3bcde4fa3f29eb883a76ff90677480c8850916915b9a0f2ce70a9ddc6658db9015197c2166b454817816bbe36c5f3352da69ddf6a202233f08bd4026386d4301eaec15f3a88f3de3c14a357a4652e446139c965be2476a8dcf57586534e326f56613865ccf849b6e2aecd3a126bc2cc5af7b45e3a6c9b25cbf395d28fb791a09e10ba0af3dfdcc20c75143ad5e337c3470c5122c519d98d0021a81dea67399f74a1090eb1469d0f72be90b799bab20ddd8507708979c8187e9fda516714b433a1a344ffa5c0a83ad9b470eb93616a634ee58bad39a775ccfd38f323106c7691b89bc2cc7e7fbfc4806afbc92a3adedde9101438005c35db34acb4886249fb7d96a6ef138dc04aafa1d11c40336100edaf14572e70981e9676207c61f789fd5e5504593f652a277bedbe6ed8576e2453b091c13da2aed682137fceef16aa6ff685c5b776a2356d933b22e33969d2143c90a2d24e498facb958389dcbbdff96d9d02d026af744783fa447b13f35d4f59c7a479554b89413a133ffca1114c7df889c2ba41b5fc534676c07817dd1375913385c6cd6698c3db2ae6af9281cbe6fe2ab8adee6df36a29f7ac897990f67e5e01d381b99414e690f3f237bd53904b319ba1b72a41091fa5e4d3bef917ebdc0f8b424361001b003300a1185623b7de0bfb9be639b10db4b645a14a2cf4be6084f320f7effd23ea68ee853e2ce82092e957c88205b1a1e42bb247a12b832c32753d3316bd1f978b09e60b9585876c365115fdf9a12815bc1cdb57f26e999878f4efcc6cee84e2d5fdd3c2db7c8b4c9e13056a4818848902257ba722ddce926e8cbc07798708069ac294a19d12a753eb05782e3a850dccdc4fb5f8e4656891e1b30fd4cffa150649bbc3fd887201b98df293d296ea38c82b4deb2aae693544d33410e1f6795fd0258ce0a8b98bda89421e2d1893df6a1f5297cfde015961d1b484a0c4146d683bb0240a26ee3f2bdc45fb5af2bb985b0eda8022bbc0b3a32b277f2e1c3795a73839e1caf1fe7ba809d88d1c073eb669afd3bbf6db3a99a72059ac570bccfa7076d480acc460cfbe5fdb52944e0dadc0e84f40781f812eaf3af21fafc70d6930cd610e767bff3d31f2010ff545b7b13d4ffa84f14bc40c632a27712a88a77eb649a078185ca92b5143b12c1b7f1bb8152216f7d9cdbb490f744b4c6018bb59a049643d5c9bfd012cd6b5bf3b6d489edc308c8630b04707d561fd980c3b578cfed4e38ff30a854900881f36a2a5995fe312c0556ca388bf43f8303bf4797a3ab1dcdf83765caa1ae74599d6443bcfae74ada364beaa65d84dcefb5f32c3040d6ca22962def5a1a0c2aeffd9c28bbae186fdfbb85499e5be17a35848dc85226c6c5aea8465f59e3bf6ff68152ea1dea5220c3b026ca64872c853e70b37c71a867023ae8e2860ee3924396eab4231c15b5afefae86ce5d2a002c958ab0166397715614b640c3efdfa7b3a8237ec4e16df0b77568836da39c038116a0008f2a82d1fd6e69be89f029eab3b0c3c2ae1949803b628acd6bc263f1115bb9472698441fab1cb0d7becfc5feaf788214f77a4de9be84ea2aea184d5b01fbbec66f2d864ebf8aa6bde8a415fd28157f9e9665fdab5754e7d16f525e85533d594cf15b6351ab18c880110af3f7dfcdf8c2be1560cdca8c3fa269f0fcb2b2f73bbde01b0b8aac0823d20dbbbd21f7da2644a31c42c7182b7d6a0f57b808829a960d3a1c67539425677ee53b18fab8bc75a43abb34d3fb4fb1cd4b8063aa33cb786aa01b8407979f620c83f1dc5fda10ad3255ae65fa599e3931a6ed1ed956374cf25351a3a5ec43beaac359dee1e7e793aeb2d6abb4bb7b5ec33783b5ecb138b526393bed2e4d267b5359a03827a74403d81d879506a937c632e9b3024ef79d0aa0cf688e678eeedd561ff36e9aa6fc1ea8064c4abac97173e3cc130927a7c7295c6bfebdec2290f9a18ef2a5f5084a477bdcee06965f9b29e027f86e50d5d21af726daa1a7837442ef6164cc8c37d023a5f3ec9142ca5ccf6b6c769891fda467b26d2f86d6037868276a2facd4fac7127498f6bcbb40dfff76940e0e38a6fd7c0c9b60c5bbc7de1f67d8bf8b8de8d7d6ddefa864e10d1bccaf5e1d32b587a62cc3fba1b36dab2ad22fadfa165b01f23880b53a160aca692a189b6eed41646e3dce88a663a96909ee20cf62a0882b6315b5feeaab32f5ef16056db45b702f20a2e1254bc3e18702cde7401ced2e0b98be62fcd2773ac7d1fda79eba2ceea78dafb30629ff3c9f503c73236161a11408e34c050b36af28c8627831d11506f56828c674b0c627893392ec61ed53614501d535fbde22d3c1fe99f3c0e9ce1b08fb244b388093c8ba61bfe2e19864d46ea2c44070935f733563287b0ef8cb53e80dcf234bc679189514a119d664e854e982eee122d5058a930cf030bbc860f131ba3a63a2c8dc1a29e598780e5e982b836ed4b54019e3f211b9f28ccbfa9358b46eafab2e635d2a99be4c69a59f05e0eee0d5a0f8d83211f6550d29c8e3be0b66d723e293f87168ad3d0656fafb40400a294931e48a686ebce9cee38c4398648c92b924eeb3b9d47376964c58acfa30bc31d68615a3b22c5a5f817f972194152c45238d664b0e7ca6b10bf5d5e64b47c530a11b90973e9473ebfe79dcb452ca633bf7ea64f6c1879f814a12edf697fab62e3bd82ef3031cae214a8dcb0daaae79dc3b7775020972ba2311af6c79355098a2ec02373827454c3f24aaab056f3d462a28f3640c527b0f763e77e6c2cb7d03b9b4a9becd3c4a98e8d544f82a44a857908ea5abe7b96f67f9e3a784e831006097ec01b34a76a6774232ade89d69eb57a97fdf71da11ce758a8639b5842fb5b66d8caa141a613dcd962cc3a8e8bddd13af702bc36b2bae24d6c4207ce7d2d7d669c76cc45e7dfcc68b39a256faaee4c3d5de69f25558e3d992c93842da2196976055e5a7a9130a4fc8fca56bab76308729182f62a334119c442a912115177da037bb3f8faa24b0ad9502653778a3db7af2aba1ad709b149c7af7fc756606cd6076f5db311c745e5a0bba3f9c4d115c823b732be38930002d379fa87e5b442f8388ea6535224a7a42a35c42a3c6c9d6e21af91824c668134f9e3076b1185c510eb35da6d9d9c918ca5b46b130919a00d5bb9ba070f4dec87bfe2b9e694409d212534146e9c9cc55ed2e9d281b219ff1542ee810b967c2857b52c56aa992eb63d43cc77b648f55e12377b8c80ea398a216f6990d265c89d59d46f35ded964bf15691e5a8e966ec1c9c810df3817c9d56b0d617cad11c315aaab64d42c2186dae560d6b14ba4ba73c4289bc006ceead42633250e1d58714723626be7e4c70e33ba580e1414eb75c607331a642ae987f8685f6de54ac36924076d175a84a8d49568cbeb278c79d1174fb3a44d036ef5a940ceaae9051b7fd8ee6ff789f32ef93095b2a393e34deca174c8f16da0d26f6cb6463d7c96f2c19b3d3d916e5230b4a1338f3d50ed2d3044fcbe79d1ae3c8d1db62a4e90c8a57f7967d5d5fe8c15593028f0ed605528f2f92516b64324166f49588fb801015517f900470201f62a231e68b629b418bbc5598506786a48ac20a1bd7b5683f764833c83adfdc50ebbd14f11afda299b872abc48308e011dc83d2a32c5b2df7f4191ca206e47a5122316a58a5a634b35fc42880adc057d2ccc685309fcade5903e1087d85bddb59f0b3dd9cbd8a2463388d7315d033475d3f589d21dc62bc303bbbfd0004478c61d473044dd1881cf04b04ee55ff7753f57c11bc5a56de6c802b302064d9d8c7a3db744ad63d16f27c8aba76369a1474a121bf6bd5a6ec1915f5b48b44f4313aa64a002eef3bc9c3d8eb31e4411d38be04067299b1f8c32d1b575bc636b0ef36d9a44eb10eae62fe3d21fecde2aa4e0c2b3da59cf63db561ac6a47f933196be4d3f7c69e1c7476e11588b89e9f04320f0a312afd2171cff20bbf77b4da7bb96d929fc2c70bc23cfe828eb204c10f2eda12bed0b34aec6f2e51145f138b4f712775ba2d7537b9a79074bfd4d2a0f9afe4c9911a581354c9d06440a660732b629dd6ddef6c16ef1adabb192ad2b19488fbc8b4cfc15d2b30e9da40c82d87ac628e8700e8133cbabb2f25aca7ac67912595aee3cd7b2dff6d691555c3f3959a4df2abf5c08aa5b730f6d5e21577f5e561833ffa5d43a3fbd7e1f5607c4b0125bef50046e9a1f0d60450ac85a8d63edb86e7cbb7678ae442411846c92a2119c6b85a1652501216fc92343b18e4f400ebdcb05c7d4f40cb7a69c6c6aff671d66ad169f0c3790e3a2177428f10ef3e5610bdbf7959cf9450fc8069bf2df4f6734e3a1c6472fd6d8fab4180361b0756abeb184ad776dbdb548be52283e11318588ef65595a413de6a0ff0439b0cb27c2373bdd1882aec1ce8cacbcb01734f98afa264e1bd3049c60e0e4fcfe9cbc8edd24c7418a8f8b8c0d2fdc97e8818ee12b1cc9b6dfe8abd53e60ab9c09d75e4fe7cf62a4ec1d78d74c385badd113e231a495afb8cd14d0579d64107258d2e394b00b8c58ce569d0d6a1a2fe3a6fb38d732ec03751c6072350e790efca5f05ec10d294a4604fcd8d3df8eaedd084014554611670d5f4b3fc9e9816005492efab4452a8829df69cb5e5ac4290422850fd0e281e281774ca0f001efa05806c7c7c8b9ab9d12b474e2b642c99945d265093220762025caa8a30404732661dfdfab35f7cc7af3e24ca5cf2591302c9957cd4d21746fb5d96614943c1bb4223e23b1a0abfdf7672fcec84984cf76c0951a4df5f40d20e4726e36aeed020b0fa7df80d02acb7ec3912adaabd057e7e305d8e1627553764f43e4d5a01a5f333b73c2ef10a840e5954adf94119adab4778d8d04e6cfebdfec387d9ac32c419dfdad18fd939c8325c1f3bb97adce0ef42d9af81a3b9b9e18f052c0dc2fb63cb68a023f9e4e1af8e3d5a0b92e72c739f4b22b60b277a8e689e243c3df825e6815e7df5bfdb97c7b9cf09e1f1e58a6b57b90edd987131fcef56e137d566fdec9f282fc7e25e1a1c75e14803810dde9ccde18aee5985f3889e1f2384b87818c420a3ca063132b3677129bca68171061e88cad6e0144fd386ff8ae0ac0bdbcf639d0ac19b85639c92b73a95a95472d05287bb455271d07a0e298a3244d3ca6f48cea610b011c5daa29ca37e52cc61b0e88936937e9782da83a73fd9a2aa7ae0514c518dd88ca464ea04c2f8939ff4bc95650c01ea5ec0e6c945fd0b8239e3b41542598440bbeff592e1fd7600d7237eaa95d6d9c711b72ba9da51a5eacf131836898ef51af776307faae8eea644cb81d0f9d2f4c559acf7d9c49df8d17ebfb96f5bf725465fef96ef8d3fee295db07647f265d4e425127a3cc2de9ef97ab5304b36555ca06939252942ce0afd966ddd48fb039ff5738d3d7c334b0e4642f99dc346dd524787520a5c84301ce416fddc19570bfc271e7463ab3d3abde616d6d69c41842b0abd1b5c3f6b8a5d12636169cc45c33025b448bbbca598bf118ec240cfb8a6ff94a6424fa5410f2bfc7fb9ba51e5165209dbe5a154bfe4c94c042395987941fb72b05c6d8d6d30972d1ac0f90eb28840b5f67d290abf26e202a120d44a4cd8d99f46835aeae4fd287795d9b361b540d6d96f34d11a2e54347cc27976057d00b1c845c91b44361d462d878d7f52b60aefd9a766b0fa585d44c87dbbb59580be9ed6bbd6cdcd1e1ed8cf467bd5cc71fd306e3f4b6c424ff761c03782452c8dc1d031d6bea1d20b5da4350cf1fba831c1ffb025ff2ca1ec25997224cc0a6b0ce4ea25eeeac704986755e46a6f2dd1c6353be9bae56c5ada052ff4699cb5d8016270859804c4dfa839922b9d8f390fcae8613d80147d0127082f1614869adfdccf29b4b71d7e4687942d0150e851dbbd7895c8d2c12874f00cb0142edb365e552f39a4d9b0749e27c66cf7d4e3cde2176ca68a05e85e4643de7cfc4cd8a8b4de37e0e12fff567826f219551e814428fe7a35bc07e4527ad01eec5b45b429fa5371b3a42cff7d51fb0a75fccf9df736bfde1449aef427dcff38d7d87ce9744bd09c49b0d291216535a65d952afc8966c7973e0e0def629e925582f045cc5d2ffbfc7745513596d1fcb6614a86937d95dcc7ba6573641d1cec30257fad933235dd98f9550e1fa3bdc5e4e69aeb616bed0059e884e5f65264379dbd3b4ae0106fcf0ecf58d23460f2ab877f82b7370873d3dc4cd0deeee7832a6a41117e48d0b5c8d15651ded2414c594e673bf302ff5c754a5c0c44df221921dfeea94db1d83137f36124dbb74d8e53de10cd56d951a4b13d02a8b7f26240cdd0409c35a358101d04405f6dcee9bf6c532505afd44d3842a9addebf38cb1be78c26ef8809e510154bde9afe682c7108e8eadc504bab4e9b687e87314b5632852dd6e33f0b98619ea6f00c25d78454f14c7273729073e52ede88ba448869299a1d2fb2112f3b3909ecd9e7da18ddd2856dad42b28902eaeb8075789676ec536e91b149d3395eee408eb52e867ebffd6d88464be2f66ae5a7f7aa741681e89aab8c6d472650029af56b22964e075d48f560a858874d26e630dd4330d6c38fd2d88a6b2b42383d11b01d5efd5c7f371e92df9f68f71f4a0b780b56c9c2b27732556316bd275447799417d27ddcb0420279123d40c8333e0ec41a8cff9e7bcebd2ad926b8e4661d8b249a3ebc55a40e6f48d69591c231d282cf7858efbc8774039b787131d063b05125e6a968d623bab4d0999e7fb237cc1248f184bdbffa0a18ed79a1555cba9cc5c17d69bf513d85081a9e2c1b279e4d6b6f289387e6c316334d51ca8e7b66da8a6c8e4a89bb3501dc9f156c69f84fbef150d884c3489d7616c3bb1e2ff22cdfae545676294209115cb73f76ab4520104ebe851b896759c2b6bca2cdd77a235ca5cc659d92976607ff00d50c3efb632e86c15f91e8852f58afaffad05c3ff707b82be7e631adcab66d6cd6547a9221799aeb6689908ddeda0dd531202c688a50c1cddab7da5ac96953236472152240e34c0d2d442920dab8777803c89621ca5b42ec4460cb790e347f739b9a514a1948db41edc5d4de4535fa458592b44f0fb0182ea5b2b7f479cb750fa4a8c768c7447f122add87410a1e0a4fd3ff8c9008fd5d587eb68a4436229efa34c41b5fba4f9e00e27d68c8e8082b47ffb4f3486a888c9f855dd5ea19c182ce6ad0b4898a8a21847b4d99cce1ed85a4c9eb39bd2b274e974580f9d3e216540d31d864eb6a6ae1aee0a6008b1daa0b9589fb4e16d53ca25ddd59743933d744335fdd0225364fdc9bf14195bee938c3dcc4ebcb6792f2a2c42d38cd859a15007a29d8f940bd9bd3d032fbc9d4bb548cdc738fce1ace4b322e60599955fdac0ec254ca407ba4718cded1de280a34024e8ef650a354ca1a1db56a7a899a4bd9cafe2dbbc5670caf42c15a34fc6d160182d9fa3d2323f6499bae5ebebb55b20fd306302090b76bb708491635362b3b5d0eb337ae609acfeb836842253f919879cc46a0ad3a89d7a957e0f0a1a2c63759f07a3db9bd7c4900da6efb9c3c56c4c985df6393568b8279f289a187309201b151e7a77147dd4477d1097ee050cf6cbfe3f6ef6a8a80a9429d8565402b31ea5dab736f8881b9c3366df48f6080bb7f96ec1e40c397847d2f3380ffb0253d7ce84508c741678122c50cc09c3e59a98ca18572abedd2fded23a03ac28a4b9d268a5af1914c248c25805125f06ec10c9675220cce255899aadea2348456f114b3379691a81ec6ed0bec5f62bc43e41fff99008c4cb5ab168a1fc6fd5fe10add664a11182509cd254734d28cb4271d84466580d68ff8964dd96d16880adee4e50df2399f45cfd6bbb0b7ba821dbcb7b66ed531f99f22bbdaf80511f6f9e7932e7f32dc532ffa103a5f363678495cc5d0cce4c98ee9c94ec5c300865b76c85c672ff7b28536719d311357b9a1e103c6d8742490b5be8e52c0f56648172af32acec462acc8e3c24497cba8c896a2fa0dcfa1454bbd4c5bbea7ab38ed4b74f8b558f54e137bcb5d0ce58efff9269fd4336c0172f2e31ca310221cee4d521276719d7bb29facc66908597a77a7eabab1aa6cbf11009cf291511e52ce51245028033af644beef099d61471258147c3ab5493037ab925a04f6f29190a8a10595f71941c7969bd91136e1c3b75f52fdf6fdfe1f38195298a04b35d137a57375672a1272eb9835e7c804d06d304d682960d007f5a4cd530c4140d7fa299c1be1e61224b8c3713879c6ee25b87246db2957ba256e034e130889befeb1b2d75836c68a00ab96ce7f17ecd829bf6af1f3325ef70b845f3f9e320f4d226c7abac9be73c1dd3279871312596c381778be582817ad6fcedddfddd4af057f5d5f086ae59d1af315de5d82e95179f24ea84548446d403c489cff4cf1a36760456eb1864c2025a3a75376586fce2f9e17b7ba7804d6453ba510e8859c18ccc427303dc98852d8bc93ec1576169e10b97b2ab94d349797a243508ba385fe5c66d373d1d50b9de78c1baccc58daa1de84b9ce654d391427dd15f5263f50b9ed435ce4a216cb767696e9903eb3f9e1e421ebf735a20de4b16cbdee965d8cc049ae444f22b693c36c8de7578ed5cffab9cf9735d677ddd51d4f4dc34c290fac48039f1e55eabd4a1b99dc601f402ff77fb763b62f1ef89afabac7773bc2afee950d36fb35b58674f3fcd330e0eed9eccc7e9eb35c1a57a3d7cf828a2b125866fac3cd50d032724af3f2504f0dfbb33a7d90ea9d26e839603a51d39bac27b520bb8915300be730598eb417864b9e5df28947080bba1dbbca69bfb238f06681766a9123d2446dd49c7770b1d453b64127b33cb158f1c3dcbe56bc9fa8fdcefce896ada36b30ebc9c56f5b17f03e7acab7c8e744de7d97f614060eaa2337f60b92a70ead56bd7def789f80de4762060a7bc35a55c77fde4ec43c7da1d167cbefe17ebd5b9073ab72b7cb211f6bae220be8bd87ba7d4c7dfc21ba9ac28e3f8d6b832423e8e7a17f7993b0cbec9dc5f44ead29e1d26cccdbefd76e43caf1ba7c312f5903137a5dac69fbb0e96de89f6392263241c280d2837b1517d0df25b7f85f0bc5a1d48a0153d36fc86c28c29ff0f7a55cd6ce055729f2a6d85b7132ad4dd59d1e9745b008aafc875c965a1b9c534eb99551c6e235e6464a6d5c3f146427de94f550239b62b495d580854f8450de91df22ad8bbdaf33d3b1cf200b8887495163269c7183d37d32a16d1ed960f10f98fdca3226d6a0d669e0e1013fceb6fb76c9d7432bde693a848b50aa1f95bfc00f73f5925de38e48d8d0a7f938df997872377d3eb9d53b0fa388c1ca2ef8834e9b0f9250f9a986bbb54505c91b3002d49223e6708031be2d6b62e2cc0e33a48eb3b07a0aba80a4d874e4fea193055a81d12a0f79603497bfe7fe2f6a1f22ca69bbd43c5a23a52520f00b1e7f0b2e2c7539af0648828b1c819e96398e1a2ba580bd6f1689a85d257f09dc30ef5f618e314b49a02fec8420d6035b859e5b55bd7efb069d0a3268606f63b44054d2b0e4a667ab2d9cf6dbdb3efdb30573a568f5c65330abfd5d2256a00bac13c7ff048acb1e9759b219da04b991d3430aecca56bd8d045cd142da4d19564a11c5defdac405f65f9733f15ad2fd82c7f06d30eb2381d0b03663513dd8ade4a2cc36e4e40e56f3e4dafa6f7091bdaf05c3501efc703f3225aaac43fc39543653443365c0810e43dfbd8ec543100666657c5b1969caea699497a90ec182f94e929cbb680043737ac289207ac7df8aebccd5606ad97d2730fb93119afa126cc3cb682d7eeab8ddb2540c123e607b8c402854647eb465924858c7fb86a04d43b2449a2695d258b626b7017fe33f7797d13953b45c2d12d58b70f51a7ad1658fe1c9546e1e5385bb56020caf2449eadebf93585fe6ea97f77becb548bcd25d4b584c75d8f9d9ca432c297aad13e45171aeb4fab4fb88ac120fc70f4c6dbff738018f98d3d06b0eb3f89423534872cc88abd874e5ae1569d0e793ad3473636a9b3e03d3b8a0eef7a2265d4db4ffe09124cf60b33fa44a9a259c7b692edef3e615bbd2a7c975bb324791250d07f849513769dae1b6e1a7f5718f85554b44628b72d416b360327f314b169360683b7d80250bba480892a78e11e5be04c2a8a249fe0651aadde0fd5f3bd654cbc33359f5ca2417680023fbaead19148f18684a2f955c94b95ab50701fdfb1abd28ebdefbcc3a8205cc900fddb38486572d343e47da91475b1b47ce917201f63835a4a0577df728eb92ab9944a9b098d81e721aa4485e2038af42024993b0b3fdc6c8c73976006fcae51a93d2c27cd8087eddf23aa35f67e15e82658026c8e7de1dc683ecc5429cb3ea3d2c5e61ca4b7e3ab90a0e15c23c079ebdbd644cc3570364196483ba0f34ab856fd0cf09c95378093f18448d1f6b2e80a2f9f62e7b6bdcf36e57aef9281516898da7cf48befd698851050ede32489999b350a27226d02b37d9a19e1a519cae8d1156a5225af368882465ca59fae3f76d0770e0c14a2e52170d5a8478f3e9a22caa707ae29d6512d128d1b523bc8f8e0cf13f53c27774729e153de2e3b867b7e00d5a342cb430f7935d041cd76ac116d2f9d822b40eaf5647ac69bd1a0673e76672d3e455929e12901a2c30de82257ca59afa91ba7de34bd531406d074a29e7d22c9a5b39bfba79107afc92a25983b069b80361686fa01b041e1a42253d5dc686084dd443b9745e2bf01a5a49d16950451528e44abaad20ae515c8e9b8fd14ef6fcc40655ca8a2ccf842a9af1d8b4b53336db7233565c59bd676d1dfe201b23c9241a41a7caffaef1f95a855b7b75615b291204a2507fbb1c816a0ef7c47c6db4b68b03afcc271b58a4a554fb1c8c7be44325cd50c3a61ccf3340d2edba83fb218926ee8faa57b91124ad1d020c1b9386908bb69c0e4ed1fce44d249315d46cfecb26f892cfec2045e9a24e1ce18d0ed691186728b94a83be095e0bdac60e5315b5aed1aeac28f3c6489cf1e16ba231415e95f6e209c567f41aa2a7e56ee2980b69913355712ea0068c0d2ee2e6ce3f7f9211200a4281075348068eb61bae1cb644a43458481524482738c4436116f0be4a2f095993e6734681e1afc64328c46339da537ec202ab8e60fdd427c1ecd10e42ddcbac6752db52991b6ef7bfb190457685c4ce1870897165021f60150d2de77d86f7ec0a564306ef3451217c8b82b607e87aaf7b6e0fe18b8359286b10a8baa126a127771de0db836a9750732478b9c9d40e37c9d8875a2528371ea1d6e89d303130c1a9ed068b9afa426807d52aa78e13fad6f2270c232a17ae41eabea5030bae69ba6dd867955e5fcbb3038cfa255028e4208ab44db55c2c8e9d07bdc2daef421ac1a62b71cf31921564482386d7cba51a5dd9cb627fcf4158d2ad4ff2157aa6b5db0a23f5959fc9b4dae38dc418c0d17f83ec99da39deea08c502e70f49b7ef348e8aeb32b8e432fba652cffebbdbf915e0ad6640af070bb1a98378c5a9004d1932ee1cba2ac57d92f7d469eae0576f0e193d4c3f13e94672df4e8f65b830f1dfee1d9db6033b15549604d65fdbe0ff9315c11560f072f93a912af2f498defcd2405af994e0c1dc19277345ac74755bcafd7be3b2047670e66f4ab5fa8c935e53b57a2900bd99d99ee6e52840205c6a1b3131f263eda5c4782eb0e0fa99110a68388ae600f4246cfe7a96b9b476e5f2b6a853c5329fcedeaca8e9d6b6482a6d324b87b5482c04ea918cf558ddfb4cce91e72e3ea9d9eba9c98bfbf97852d0ec294ec88eb9135012b4d1d1dd5e3c420d639d17cb2e985509025a62c774ccedb7e800975c0c0bdc09d2c6de6dd18588a6838e36ae6ca6a2249a77c138b7a0b5878b051367effcebe4dd9554fd3c5036e1b358b5b25e18506968b1d53e2b6998d49802a13b11d50831b08357adda2f95d3f773ee7971cb08b124c84022088421eb8eb793536114a187804c21142b733570da8986c540d372e8ace4ebf4366d702c8e8927256e03112828e0a38b8767b264c21ca5d258d2f69acebe3ba989f3846726c56f7980b43868f70975a2be4c476ae80e6681debbe0f9917396354595e5af1d65732e0a3eea602bad166f6977ea99be63f33a6b33c65c9cc21586f73d7a8e210393344478faeb7382fd843a429ebb580c86a536b2a2479e9d71a9a57c7f24cce7c0e0a2b6af1d5f4147633b3eaa285698f75d33f13bf229f997dcfdcc2b67c8cd27c630d04401cb268c97b03e6b2f807af6127dea2b21c2fc01cd9b50e3c700c5f140af4a19157a1776110d679adb41457bbf81bedfe7ab03742b9250bc1c297049df6f237062796a2f6b44b36728cbc54ea1601868e581becc1432cdf7fd374cb943cf542994057d065c460ff8efed2fe897d2685e2a3818595c62340f724d38cc9e24e10a227fd946360a7f5e763682353beb42f4f1ff64ceae2f37a15272f2a875fd9fab61f269158172a06f6f6f2dfd5e102b24e24f2f4453c308f6c987314235f4133ef45cf421218a5c03ce6175136c4adf0ceda41d6db7511b90364c209064dfd14dc864c42fe74dba39dadf40d21b38f5432abc0d2b1446c2b1c55cee3ff53c14dd0782ec0759c6b5b7415f113f3a19be69ca533265f1501befb5c8f5c9fd43b7a00c8dd8f6670989110d47284bbeb76c8fa9685cb62f318b726ab53a3c35b40e97f268084d54c9af6ce455cfd2b5db9e4e15646bb0157a9ab8a267b6cbb31b4cdf9d36c53da81a00d85e1db0fdd4c9b6f0eed7839d23d13e5cfc66ab102ddc597091a26f9a10451e7da9c395aff5dff2f3a4bf780a18816c328d5bcedd1ae2994d9f4d6574453f5e130b762a85b28da39ed76f3d9205b0aa233ce3b53ccf62d2f966bae99c06c21f5e99668755d9e3d3663048156eedf4dac28b5cecb9e43a050ea325f2494ec78b5c0661537ef939b9e3aad465938b14d405182784ecf4ba5c9047b66adb018e79d765ff595e325546d95b86489b8c4080133b403232f915bc85862ef17b6efd29bf886f41273e57bb28e2e992a2c4ae59f06f1b3035960ec40924257ba110202fcde4f7ca0f0101d05f838c4f6f5c4bf57028cef1710821ec6b80e64fe4560ba751ce75ff05a93baacad77fa8a902205a8a386b3c77ea82f792567f6d758eccc4fa65f3f8a63f8a147ecf67ea9c7eebacf6285231e9e3f7eea0849700bad42e909a14f46ed20df694c1755756a66fba7df9c4e1a1ac4e45f248cc11bc83ba516d7278426c1d28e70785f67a4db4edc5683d9ac5f7c7c6bea73b5d8fc0a256bff86b7bef19774d20ec7c6c4433b79469b994c7902354f760f9fd4cfcea4d6a8ac4b5fe65741919e4554e3fcb956c315879ea16a0f84ffd0056ae7e29b6d4df05190a948aac2227fa61e179ad267e22380de306c4c68f5bc7854034cf10d3cd5ff5744cc0a4b480f52fc80fd530f0affc2c648d96ea76a1235478b52422bcf7c872a8e9fdaf4f909da4cf4145fdf917c0b9e5d686c6847376e121188840e6145f0e2536dd3b43eb6aad110d5cfc9f040d5c71f7d3e362341606d7ffdff8ecba47d1bcdf23193e0ef43ec2334f19d8ebef1f4755503c01a841fea8aef451d4ee4c10a4e1b0b88c12295709e5493c179480a0be0ff2c5a93d3d4642eaa22af10f7575266f24b96a117500d942ed8b4789587a30294b151989172a167dba8d0b2119ed626f70781e8386bf460066af45c613ad2242912affb2668c59aa91eeebc7efea327a84743f58353a35fb525a164dead0510b9116372024015fb13d1ebd4d34abb70bec6136b81374f4befa62d663cfa7f312dbfee8b1438fb619e4d33a6c0bc2847d6da296f4127d5bcdb3c57ca4c888d3faaf820355bf591452740fbec0cd3330b086380c32c55a51469f3bd113aa96ed63051fd2932fddd61a782037df03fdeaf801ab09d8eadcb999bf6f027527558e8b71a3973d19810655ca1b36a8e3fb661a52683240bef7b3dc934e49a09fde46a4c672e120c86a474610d2ff5cc54d1cd24f7c05054d3e345c7cfba4c9b3f2590d7f20754cc3f8edd9243ab4e998239b9b5f252741f9c129644d4b0b7e537d184de2c17b4fdb69d1edbd36ecdd3a5fbf645a4bf93133864281bcbee768a32a95fb1ca46abbd1d5fddc1de609e10a427da8aa360f03a4b4df122ac2c0298cd5b3d279888794905bb25db6a5a91f6ad7eab065bd681dc5beeb7be531ab12f9fa5bb40bdc0e0b4e2e1f7e7233336c2b471a015539bae868c5f782cb7ec362f22875259c09acfabe3b074c0f47ed85c3cc24d268cd6a7171c01c7ff4330988c029ceee0062b7193be3837af16bcbfb4c848642ad94f16502bd4e087b07255a7258a5331767fa571d67b207b73b449e181639f24186d228809b7a25c908219d38d54b3affdcd177d9b2ebbe3dcb46544c7dec08f16b7e49922936a79f70035b10206719229cd5a57a97dd1e3e16f9684828dc73a24eded119727a18cad69a261b4913e7f6494c22e1f4b95bb75ed5da8e21691f580e9ed7ee70526ee6d5ee3d238f1b1ffd1343d9e888e2d8c298f0fe44c25c6ea774786decc6ca0592cc439504eea37b941b6b48e9b3ae790fdc5bd5654bfd5ba3b2de3346b313e980213fd4f3893ed4c2b0c1aa5b1b5b8b448ec0f776c7b73c30ba67339736b6bc34f699a0a8f8c9d7734f3175fa3159c5548ac50d1fad1c24f62da94cfb50f0bf1a744faadfe99a9f7d78620b803086fe51d5644f51492b6623c08d91a1b7ecb1863ea4d3d686f69d9c34d3f8aa3cac24efb0218c24e59bc422cfe43ef2a15f0bbdf461a81c47d6ff8400160212eae9d486b12c2773c66d114f21b1f56a9a092546512cfc9011d6c6f647b2e00f1324a0eca223199", "isRememberEnabled": true, "rememberDurationInDays": 0, "staticryptSaltUniqueVariableName": "1df014cede108e8ae38d2cd502f23911" };

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>