<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Adam & Helena's Lists</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        @font-face {
            font-family: "Geist Sans";
            font-weight: 600;
            src: url("/fonts/Geist-SemiBold.woff2") format("woff2"),
        }

        .staticrypt-form {
            font-family: "Geist Sans";
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-toggle-password-visibility {
            display: none;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            border-radius: 10px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            border: 1px solid black;
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #ffcc33;
            border: 1px solid black !important;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #000;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffcc33;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #ffcc33;
            /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #ffcc33, #8dc26f);
            background: -moz-linear-gradient(right, #ffcc33, #ffcc33);
            background: -o-linear-gradient(right, #ffcc33, #ffcc33);
            background: linear-gradient(to left, #ffcc33, #ffcc33);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
            font-weight: 500;
        }

        .staticrypt-footer {
            position: fixed;
            height: 20px;
            font-size: 16px;
            padding: 2px;
            bottom: 0;
            left: 0;
            right: 0;
            margin-bottom: 0;
        }

        .staticrypt-footer p {
            margin: 2px;
            text-align: center;
            float: right;
        }

        .staticrypt-footer a {
            text-decoration: none;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <h1 class="staticrypt-title">Adam & Helena's Lists</h1>
                    <p></p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password" placeholder="Password"
                            autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="template_toggle_show"
                            title="template_toggle_show"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator =
            ((function () {
                const exports = {};
                const cryptoEngine = ((function () {
                    const exports = {};
                    const { subtle } = crypto;

                    const IV_BITS = 16 * 8;
                    const HEX_BITS = 4;
                    const ENCRYPTION_ALGO = "AES-CBC";

                    /**
                     * Translates between utf8 encoded hexadecimal strings
                     * and Uint8Array bytes.
                     */
                    const HexEncoder = {
                        /**
                         * hex string -> bytes
                         * @param {string} hexString
                         * @returns {Uint8Array}
                         */
                        parse: function (hexString) {
                            if (hexString.length % 2 !== 0) throw "Invalid hexString";
                            const arrayBuffer = new Uint8Array(hexString.length / 2);

                            for (let i = 0; i < hexString.length; i += 2) {
                                const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                                if (isNaN(byteValue)) {
                                    throw "Invalid hexString";
                                }
                                arrayBuffer[i / 2] = byteValue;
                            }
                            return arrayBuffer;
                        },

                        /**
                         * bytes -> hex string
                         * @param {Uint8Array} bytes
                         * @returns {string}
                         */
                        stringify: function (bytes) {
                            const hexBytes = [];

                            for (let i = 0; i < bytes.length; ++i) {
                                let byteString = bytes[i].toString(16);
                                if (byteString.length < 2) {
                                    byteString = "0" + byteString;
                                }
                                hexBytes.push(byteString);
                            }
                            return hexBytes.join("");
                        },
                    };

                    /**
                     * Translates between utf8 strings and Uint8Array bytes.
                     */
                    const UTF8Encoder = {
                        parse: function (str) {
                            return new TextEncoder().encode(str);
                        },

                        stringify: function (bytes) {
                            return new TextDecoder().decode(bytes);
                        },
                    };

                    /**
                     * Salt and encrypt a msg with a password.
                     */
                    async function encrypt(msg, hashedPassword) {
                        // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                        const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                        const encrypted = await subtle.encrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            UTF8Encoder.parse(msg)
                        );

                        // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                        return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
                    }
                    exports.encrypt = encrypt;

                    /**
                     * Decrypt a salted msg using a password.
                     *
                     * @param {string} encryptedMsg
                     * @param {string} hashedPassword
                     * @returns {Promise<string>}
                     */
                    async function decrypt(encryptedMsg, hashedPassword) {
                        const ivLength = IV_BITS / HEX_BITS;
                        const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                        const encrypted = encryptedMsg.substring(ivLength);

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                        const outBuffer = await subtle.decrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            HexEncoder.parse(encrypted)
                        );

                        return UTF8Encoder.stringify(new Uint8Array(outBuffer));
                    }
                    exports.decrypt = decrypt;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    async function hashPassword(password, salt) {
                        // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                        // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                        let hashedPassword = await hashLegacyRound(password, salt);

                        hashedPassword = await hashSecondRound(hashedPassword, salt);

                        return hashThirdRound(hashedPassword, salt);
                    }
                    exports.hashPassword = hashPassword;

                    /**
                     * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
                     * compatibility.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    function hashLegacyRound(password, salt) {
                        return pbkdf2(password, salt, 1000, "SHA-1");
                    }
                    exports.hashLegacyRound = hashLegacyRound;

                    /**
                     * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
                     * remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashSecondRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
                    }
                    exports.hashSecondRound = hashSecondRound;

                    /**
                     * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
                     * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashThirdRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
                    }
                    exports.hashThirdRound = hashThirdRound;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @param {int} iterations
                     * @param {string} hashAlgorithm
                     * @returns {Promise<string>}
                     */
                    async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                        const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                        const keyBytes = await subtle.deriveBits(
                            {
                                name: "PBKDF2",
                                hash: hashAlgorithm,
                                iterations,
                                salt: UTF8Encoder.parse(salt),
                            },
                            key,
                            256
                        );

                        return HexEncoder.stringify(new Uint8Array(keyBytes));
                    }

                    function generateRandomSalt() {
                        const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                        return HexEncoder.stringify(new Uint8Array(bytes));
                    }
                    exports.generateRandomSalt = generateRandomSalt;

                    async function signMessage(hashedPassword, message) {
                        const key = await subtle.importKey(
                            "raw",
                            HexEncoder.parse(hashedPassword),
                            {
                                name: "HMAC",
                                hash: "SHA-256",
                            },
                            false,
                            ["sign"]
                        );
                        const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                        return HexEncoder.stringify(new Uint8Array(signature));
                    }
                    exports.signMessage = signMessage;

                    function getRandomAlphanum() {
                        const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                        let byteArray;
                        let parsedInt;

                        // Keep generating new random bytes until we get a value that falls
                        // within a range that can be evenly divided by possibleCharacters.length
                        do {
                            byteArray = crypto.getRandomValues(new Uint8Array(1));
                            // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                            parsedInt = byteArray[0] & 0xff;
                        } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                        // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                        const randomIndex = parsedInt % possibleCharacters.length;

                        return possibleCharacters[randomIndex];
                    }

                    /**
                     * Generate a random string of a given length.
                     *
                     * @param {int} length
                     * @returns {string}
                     */
                    function generateRandomString(length) {
                        let randomString = "";

                        for (let i = 0; i < length; i++) {
                            randomString += getRandomAlphanum();
                        }

                        return randomString;
                    }
                    exports.generateRandomString = generateRandomString;

                    return exports;
                })());
                const codec = ((function () {
                    const exports = {};
                    /**
                   * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
                   *
                   * @param cryptoEngine - the engine to use for encryption / decryption
                   */
                    function init(cryptoEngine) {
                        const exports = {};

                        /**
                         * Top-level function for encoding a message.
                         * Includes password hashing, encryption, and signing.
                         *
                         * @param {string} msg
                         * @param {string} password
                         * @param {string} salt
                         *
                         * @returns {string} The encoded text
                         */
                        async function encode(msg, password, salt) {
                            const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encode = encode;

                        /**
                         * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                         * we don't need to hash the password multiple times.
                         *
                         * @param {string} msg
                         * @param {string} hashedPassword
                         *
                         * @returns {string} The encoded text
                         */
                        async function encodeWithHashedPassword(msg, hashedPassword) {
                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encodeWithHashedPassword = encodeWithHashedPassword;

                        /**
                         * Top-level function for decoding a message.
                         * Includes signature check and decryption.
                         *
                         * @param {string} signedMsg
                         * @param {string} hashedPassword
                         * @param {string} salt
                         * @param {int} backwardCompatibleAttempt
                         * @param {string} originalPassword
                         *
                         * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                         */
                        async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                            const encryptedHMAC = signedMsg.substring(0, 64);
                            const encryptedMsg = signedMsg.substring(64);
                            const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                            if (decryptedHMAC !== encryptedHMAC) {
                                // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                                // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                                originalPassword = originalPassword || hashedPassword;
                                if (backwardCompatibleAttempt === 0) {
                                    const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }
                                if (backwardCompatibleAttempt === 1) {
                                    let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                                    updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }

                                return { success: false, message: "Signature mismatch" };
                            }

                            return {
                                success: true,
                                decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                            };
                        }
                        exports.decode = decode;

                        return exports;
                    }
                    exports.init = init;

                    return exports;
                })());
                const decode = codec.init(cryptoEngine).decode;

                /**
                 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
                 *
                 * @param {{
                 *  staticryptEncryptedMsgUniqueVariableName: string,
                 *  isRememberEnabled: boolean,
                 *  rememberDurationInDays: number,
                 *  staticryptSaltUniqueVariableName: string,
                 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
                 *
                 * @param {{
                 *  rememberExpirationKey: string,
                 *  rememberPassphraseKey: string,
                 *  replaceHtmlCallback: function,
                 *  clearLocalStorageCallback: function,
                 * }} templateConfig - object of data that can be configured by a custom password_template.
                 */
                function init(staticryptConfig, templateConfig) {
                    const exports = {};

                    /**
                     * Decrypt our encrypted page, replace the whole HTML.
                     *
                     * @param {string} hashedPassword
                     * @returns {Promise<boolean>}
                     */
                    async function decryptAndReplaceHtml(hashedPassword) {
                        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                        const { replaceHtmlCallback } = templateConfig;

                        const result = await decode(
                            staticryptEncryptedMsgUniqueVariableName,
                            hashedPassword,
                            staticryptSaltUniqueVariableName
                        );
                        if (!result.success) {
                            return false;
                        }
                        const plainHTML = result.decoded;

                        // if the user configured a callback call it, otherwise just replace the whole HTML
                        if (typeof replaceHtmlCallback === "function") {
                            replaceHtmlCallback(plainHTML);
                        } else {
                            document.write(plainHTML);
                            document.close();
                        }

                        return true;
                    }

                    /**
                     * Attempt to decrypt the page and replace the whole HTML.
                     *
                     * @param {string} password
                     * @param {boolean} isRememberChecked
                     *
                     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
                     *   expose more information in the future we can do it without breaking the password_template
                     */
                    async function handleDecryptionOfPage(password, isRememberChecked) {
                        const { staticryptSaltUniqueVariableName } = staticryptConfig;

                        // decrypt and replace the whole page
                        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
                    }
                    exports.handleDecryptionOfPage = handleDecryptionOfPage;

                    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                        if (!isDecryptionSuccessful) {
                            return {
                                isSuccessful: false,
                                hashedPassword,
                            };
                        }

                        // remember the hashedPassword and set its expiration if necessary
                        if (isRememberEnabled && isRememberChecked) {
                            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                            // set the expiration if the duration isn't 0 (meaning no expiration)
                            if (rememberDurationInDays > 0) {
                                window.localStorage.setItem(
                                    rememberExpirationKey,
                                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                                );
                            }
                        }

                        return {
                            isSuccessful: true,
                            hashedPassword,
                        };
                    }
                    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

                    /**
                     * Clear localstorage from staticrypt related values
                     */
                    function clearLocalStorage() {
                        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        if (typeof clearLocalStorageCallback === "function") {
                            clearLocalStorageCallback();
                        } else {
                            localStorage.removeItem(rememberPassphraseKey);
                            localStorage.removeItem(rememberExpirationKey);
                        }
                    }

                    async function handleDecryptOnLoad() {
                        let isSuccessful = await decryptOnLoadFromUrl();

                        if (!isSuccessful) {
                            isSuccessful = await decryptOnLoadFromRememberMe();
                        }

                        return { isSuccessful };
                    }
                    exports.handleDecryptOnLoad = handleDecryptOnLoad;

                    /**
                     * Clear storage if we are logging out
                     *
                     * @returns {boolean} - whether we logged out
                     */
                    function logoutIfNeeded() {
                        const logoutKey = "staticrypt_logout";

                        // handle logout through query param
                        const queryParams = new URLSearchParams(window.location.search);
                        if (queryParams.has(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        // handle logout through URL fragment
                        const hash = window.location.hash.substring(1);
                        if (hash.includes(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        return false;
                    }

                    /**
                     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
                     * try to do it if needed.
                     *
                     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
                     */
                    async function decryptOnLoadFromRememberMe() {
                        const { rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        // if we are login out, terminate
                        if (logoutIfNeeded()) {
                            return false;
                        }

                        // if there is expiration configured, check if we're not beyond the expiration
                        if (rememberDurationInDays && rememberDurationInDays > 0) {
                            const expiration = localStorage.getItem(rememberExpirationKey),
                                isExpired = expiration && new Date().getTime() > parseInt(expiration);

                            if (isExpired) {
                                clearLocalStorage();
                                return false;
                            }
                        }

                        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                        if (hashedPassword) {
                            // try to decrypt
                            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                            // the user fill the password form again
                            if (!isDecryptionSuccessful) {
                                clearLocalStorage();
                                return false;
                            }

                            return true;
                        }

                        return false;
                    }

                    async function decryptOnLoadFromUrl() {
                        const passwordKey = "staticrypt_pwd";
                        const rememberMeKey = "remember_me";

                        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                        // since it sends the hashed password to the server which isn't needed)
                        const queryParams = new URLSearchParams(window.location.search);
                        const hashedPasswordQuery = queryParams.get(passwordKey);
                        const rememberMeQuery = queryParams.get(rememberMeKey);

                        const urlFragment = window.location.hash.substring(1);
                        // get the password from the url fragment
                        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                        const rememberMeFragment = urlFragment.includes(rememberMeKey);

                        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                        const rememberMe = rememberMeFragment || rememberMeQuery;

                        if (hashedPassword) {
                            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                        }

                        return false;
                    }

                    return exports;
                }
                exports.init = init;

                return exports;
            })());
        ;
        const templateError = "template_error",
            templateToggleAltShow = "template_toggle_show",
            templateToggleAltHide = "template_toggle_hide",
            isRememberEnabled = true,
            staticryptConfig = { "staticryptEncryptedMsgUniqueVariableName": "972699d3849969ded59a66c56b1469c41444cebf8ebcc972af4d56766a0020f7516f8f69425579b17726da3a36713bd05c08e35a698aba146652befcca45e077dd56fdad2754516628e4104920912f1ce7ede90d9ba108395af63ab55c147665f70e6540594da43fc3a00e3c9f6546873e1cc5efa01e4c6e19529f8bdf2af654d29ae946a47b91b9d47d9e26b10b3b3e5eb5c393a4e9b3698a361bf25ac5768acd9e2b272b08d18dcff8a470ce7aded5316a31dcff4ac0a70d748203e8b21ac649efbd64c2417e6538ce064327081dd59beda5d42a63a1f45877f5bc46f6d2fa99bbe3e3e17d0a91733cfa29cd399c406f6687335b75f6d1e082e24758bb847526658cb1d8f0fa7199009f40117666ff8bc448d17c501e07ca8e86a25139d77923f8685b8eee36bde68b4d55bb0794f9680eba71ed851e8af85c32389d2055b434eee022045a14a4ae1704bfb764dc87643ceeb82be907d7296fdba0335b58e680ff0287ced1a2020e000fcdb1cdfcfcebf5f159777ad24e3bcfc3296546f92e81f01d8c067b3884f95d0a3603d2f42d92e87972f01aecb8613789b7a9e9dde75d513cec44d0735d445bdc35a9646a44d42e9db873db5c3f4ea9bd926840d901b06e66a75707555a00d771267d6ef582de32583746069d35a6cf9f039b6db1ddef017538a548d0059c0d4d12068c8a4bdc31439b35c1a969b6d841dff50c35501b84308daef3e58f91feb62b9bc6f8567e3d4d40cae238683de816e1b30fb04c1c40b938e859c2e451555c4f130bdc80d8b8df0bdf5a28bfaa9ddba7bad3456c7bc3dd9c57222b121f44b32b8b742510555e466c792ec37469bd2889a62a9a4ac874554fcff88c50fdaeecc05ab5dab94de370fb63bff4e44f58ee8248cebf0a3311115ea877bd9a97f2c4f7ac583d52636a2c12faa657e67f1772d76575d3c2aff04ab077538c3c77ab42f6894b753eabcdc576c2e3be1e2d6fa72946d62fbd98301a74373501b94feaee56ac6067326e9377ac2a839a4980b3a267c50c914e4a55f2bf583d5c7125b01a6fd62c5b9c241af78fd6f9af9b4a473707943fb3e534bcc72daab2e30c076780f2841244ecf759ab3c73ce67fc1f76ce23eebcb14c96bdf5967901f4a614dd2df323d9b8382acd5fda7975eecfbf562fcb4c43774ee9ecd06994d2816da1edab8cee4fce0056a952c97a68c4e85640d1f77d90f7aa707e2444dff04f9aa57ff8b64f9d158c82cbb933f14b46ed9d267e51f44449a4800098fe298dd0dd1c664314c654ac4b72d7da6ded177b52065d6e05b2090973c7b90154c7a686a519d263b71724075e3abb7132908d317fe477fe5aeb5c1547041fdbad73cdc902c664567b702dcac66f6de3d43aca126f474fc423f9e26fb5a86cfd1df4775a8d4a63bf8a8dd2c60da65f273cddfa57aeae7b846f6691f0791b8c7d3cf48354f7a3dc3823cbc4363be1661c7a1ac6069e17e190a3d15bd6395e87d2651a02bb3208a70c444fd1b34ef7847a7d00e7d4a5028e52782cc4b385222ce259db613eee01e911a39578942f4d113ffe0b60b93bfdd1ad0adcafd8af8527892b84a26913099c55ece38d46720d019bd4762b0a33fb062d4ac9c4263be778d40f51d62f5a41d1cc5da2b022c558e8435b7df7f3b9363f8d18196ccd92c0e751c46c76fe6664abe0526837824b7d5209e1fb9c1ca9ec11346b8a1425076ca5e00e73279b6378f3fe632df622e19614ec8ddef06a99680cbf8441a98e043b0cbd103529a717ac8095da40cb86aab92d43f468eafc264e54153411162e9ca4a96bcf1eeab1d1ff1c92293b1523c3a989403d339d804607cf8f603619a209432c47191f432d7dad4fbf780de860913e8e6681f75251ff74f46505b11ebd7d962ffd6a5c7c6f35d52d1f24937b2f8d866e2a18e181eb00d2d34372b9944627ed030e4c15158612e2358bc3dda84bd0b46bea92ddf40200f5c9b124947cb0cdffee8f71f44e0ae617a76e2659ad52e941c1413d8a78110f56e07da66890c1ccf7fab94cec869de61259f6ee3a3f10e01eed50e633df1ef1eb0957b57445f7e8c1e706f4ea7d7bb14bddead7664854b74feec738f49720fdc94ec910aaeb4f3cade168eebb4c2cdc19585bd846b64ffa41a8561d0808c474e18cb1036f1ec471767ce567e0b976587a8abe41558567d6483521173f5f46b56b4065b15d2b6c8b4875cc4fa9d609e76ec706ac66d47b502b31e4a90ea5fd5a68f097c1ebe45d72628b8c3218656838e0df223f2bdbe267359ac4866cf1a5e3cc548247b5903ccae4e49c5c6321e61f00d1dd5bb7ea6f33a0170dda22d5cdd8133bee97e4e4ffe987c4b3607dd0593d49020dc042044edeca42e47582983735de5dad9564a0e23c396362726d83a601a6e6d407d79dae78465952437a38f3c45db94e8cabd93637fddec0523b32559d0c6d0ec084341466991c0f27754ac3cc8f5233a94bc8c06ffd8480a618cccb3472e679ebe243d7a3611a1e2c15a4fe10ae91f7bc230fc7869500b43d404e4d716708950be453afd84db2db29877d5198f36f8569ad0cc2771e92c510857e75ac2723775ad757fc133752774bd006bb9cd0f1f8b9dcac64b15004a4c1f81f5ed9c07cf99a23dbf0f00d37d9fb2b3ee01a57110729dfc1f7ae69554f22b2967aad8bb0fc167135e21a367d0216502505f702d1bdac6c202d05c8495a9e243932a68b703a3c82aa1d16523a582460065be6a9a0784130cec528679fd1c9f34c58b511373dff028b7fd0fcb139e4c2e6bbad0c6a3d68ebcf4eb28c33dac604f72fcaf063cb576aefac8b0a19ccad8d3658d2984573b8a6c54aa3821f8dd5d1da9a6a37eab22d26fb8b1f48a390906c39d6eb5d76ec31944d7acc597e548547aecb363253b5ef4239e30a95aa24ac451952e42c58cf3f4750627130ed8d09a3bbf6ebd940d0ef48c4a94e876948af1e9ca45f698448fd6f0e03115e5041c2a8925963beb18dfeda63265de8c81ba9d011458a3da1a671135dc682e4d8aafe2ce75c717247a762015e7fe2afd18c4d00c67fa38546a1105827ad19f512656efe7aa3225cf732238820e8e716e7d9051269dcbb214102386a19538dc289babb2d7013e3a97552243c836438e710669a9a30ce68ee119012448204becda15f2472ab34510b6c481b6e3029e46d3e0b8912be68fdd1fa8f07d73053dba657be919cab8cf2bde7085c7032b8353689ebe336835f8c8d5d9b9663f12bbcb3da7141a99b58cd71c83038673c9ac6663488412ab2aaa0a0c015c8b005f6e91660d31b0699de105db2dbbd9a91c0c9e7924001d2f27abd195f12d8f0ffbde023650795b6b33dc31d2e222c4f5c5bbb35d9f8e6956c8e8264cccfb6a5d45d1c00930cf7e2cadae72f0bcd523ede4fec57beaead1fe11896b0d40c4d031d8db43e3779d3e7f7634373f71a026bdb104f8e74eb817baa86526cbd0ef95453d7ec56ac2cb9078483007a6c4f7c275b86384ca0392111377493022ce7e54bc98368dc1fdf686ff4e380f13e72e21dfc01ed82cc8769a3c62ef7ced1327ae940248bcbb9c00ab580b8fff40c9ec12f09b89216b622d85d04802eb55bf7d5cbdbbf1dff1f2c97a0ab080ca2d3ab0e96226742e20818fcd271d91f143ec651e4229479ec5e4851ee0587ece755d8a8f1884a7b1305acc877f5eeed9f63ecd657c48fea8d965bc9fea284b0eec9cf5c1ac4a8b8898e593df5671d1219d3252e3c8f142aad21b0c99479745e3f40a746b0db5640f0f5a6ce57a5a34658a145437c0d333167ec0bfe408ecef4a7564157e59bb1352cb4e903d405328477ccb1f254494926fb10c96e9046965935f134569419d123a9f7316103c970e211d6d02a4b71bfc00ba170ed2de3dac2a3279091214ba4379de578fdac0c524d8213db4b68aa3a60c786cc249564f06514d75f1a07fd164ec34815c69269e8ecf43953e4b1871581b55b4f5296e5f7b174a5a9e9e0198d9a2955c089ec636715b4e6294a27d9fefb6805b6a44c20680b92a8696c6b5c21083b5f4265a659136648eb08c5912d9f08f1a996ca68c790858cf4a72038a06faa2661a7ea08329a22ba5776138beff09643593da5e25df6618c3e6098cef94b2d45408666bae7194ce840a62b7c66359ef9b309f4c7aa8188907c59eab28127f21bd0858ad989e188f199adcfff5aacde1639afc1b53fe89fd42140009d448c2caf4cbfa2205948504dc4935b5909ec3002aa8f45c02f6a2f4ac91aa02a37f13e00d6d4910a95b7dcb219e79d4211c0b4bfb87e71564e72f2b0844b25585b9ec942354738fe1e376e8b5417a98cbfef8b9627f46ea0a87c73f22ffbb74fd60d065fb1f3bb46c7167de5befd3d48e20fbaba8590a56783dcf0a6b3b46a4c6db8d2bdc6249d07f522d834d004a32e651e5b365fdfca9a6b7783f0593b5d527c37b7ca0f877b09ebd0d421b4e4ed20833ba829e62c2971a65c6afc5b032e7feede9c8c13de8517890ecc62de2f4b40f99b95cf337a6c57c695505cc733bad6ee435b80528c74615d7615d036713ffc62f436f85e836bfa062884e22cdcd5fede7468fcf768c76193353d1d0d5a96b6934f7c89eaf8c084d76ab27dcdf84d2a8c7bf3220bec2b3ba9967efd4b8bcef38582cfcc6faacc2a591d85f2a5ae0def9b61ac723adb5e31ef6390ef1be27635f4d61796a4bc965b6260a93e80f3822a5d1e895f1a99c2cbf54aa17ac99f0d968f27e22dc5bf1afea3c9274c83a49ff0eb355669031b46e6618151c090d99d9fff0888db8a5277c38a577665877f670c89295953567e197dc081d4dc215f536fda4f22ebda4520884a777f61deffd96864e4e28598e1da8c365ec58498c1bba1f7d22143b8d15a3dbeb92eea3c049d3eafb4642250d862e5c539eb2900369482cd4bac8b600a61e3d96e80f83f49d4d0b1d4c3be9dc3b1ffe2d4204b12b9d6a09b94c68c876536ca9ed145e78eb7ed5ec809cfb6282739eb05470c5b8da751796f23da53b734f62e3cd8b9437416d7e3a4c38a1bb4c96976a7969a59f8cacaeb994648882731e3de04c5ea848f134a65b30d2ea1d6c4701d8d8cd15c61378d38f0a7d18c10c8ed403caa95015d10b15ec99731e99592f9d7628663b4ca2ff35c9bed703dd8946de8e8155d1fee73b8df2e19b3b1457d23d68f2e92114e494743744ec411a172f6a261918b80ca6a900a0bd9e13109e17489c9ab6aa56675ac7bbefe8b11c48ff597fba0cc6f1c8d964946cedeaf07e3138dc1f125db47545c5b342777af1c94087be7cfa13c3e58d11334f8736e14eea1e1df10806cc3bf623114c5f910101c71549a006df63ba2e72efc586583ac745e59c4cb02756ac7ad5d9a07ebb4d801743e111b4e1b967fb1b1aa2c992885dae5e944d02ca58c15b425085627df0f8b8d68946fa344cbcfc2a91bb21d2d8c3505a21c47b2e59cf86cdb65508f0c4f1853eccd128c0aec4c40aa6d97a85eb5aaccbf41375c5af808dc24a5838084ee638155212c0e6d38c0b2b7a05393aa389e27ec84c8f6c442a72ec1994318811fed349b3d91ece14b3ab5a3e3f7dce6227afe6f0990089242d6c7a32c6e2019008159f0b48c962fb8ee68f5b62ded45aa028a6a2fbf16e99cf46d91ce00d089e938aa935d5ca011eb6d2632724b65360a6e8a1c799178f327294fae64b6f2dd5c0711755bf0743329e61fdc31d015044d6800ea6b0314d8cdadc9e77ca938898e53c45c1c8cd3ace0b64ebeba6b6307d31b32bf8cc10b5a96fa4d3ecfce845af8e91ff102e1c9735573865b4cd0f65ab51286493498466dc907cc97203fd59540c7ff123aeac81a1e6b59876d71be345dfb941583b87a46f2163b7bd6be4575aab1cd3688d740a119c4e5f418c45a1b30e055059c5c4307c10adf6f94f49c80c063ba1033f5cab506e3f729cc1f710d16dc9c57510f706f9b78e3596ea3a32c2e21a93083d3a0afa453ff1a20057d36ea90638522079d66814168c46d12fcb2f37b7035c58a78f54650ffa3291f8ae56e6aaf2d2f9c13c6562141577d9dbe42baa08fcae61759e9735f094d1e0dfea405ad1f17331d66588084a0aa929e8b12ab4eed682eccc41debe7e9acad27a578431e3ae456103dc5d9cf3a797aaebb2a690d1994eaa09b89ef78fac4a426a15e0b04cb7763894c9ba87dd4ecb1309b6b057099a3a11e4850b6447c8952b8d9b9120a63d950217a62df38a01144ddb5297cc560b8c0eb3db6aa658572515324a1fe03732d82b6282daf02a76992562625448fef7a83243ced24a763b47f122e79a43bc8d74c9c83560f89a0b9fa74769a949603fcef34ab251931b9406eba66b48c80cdd56f13a17dc78871f950690c75a42e79f126c42f0b866fa7d4a1054bc66aede18e41bde66a5dfd4bd75993b7a7b8152542da0dc680612612e21d740e8588e82f5a6703e69b089b71a88050ed9c1a4b4dd3845d6c4885cac2ba7bca357f0aabcfcdeb05db35ae19bd5fd98ea488377c3737152c9e64168852f5373cc451f19832b8bfed87f186679ffa5c0b894a795114c86a0c103cc2acc8c09335704913e5c482d83fce76f021f3278f16437494805cb30e357a2e382efbff7f37e62a6ea091be729993c46eea8043a91e92e5cfccd69fb1cac768ca4877f485f7581b535fba8afcf14f55c16acdde4a23db64198a2e4ebc879b69af919ccff82746e9aa2f33136e78ad56cf3c62b647f2afd895bd68988a1931fe1ace306877f71b78e95f29c57b6421096b9cc82d4d4eaefffd8912f860cce0998297b19442c22f6a8cf6c1c069cf4115ec982f33a60123cb634b51c3b21383dbec161bb055538dfc3aa537e43f03c4a9b1553dda9b6bce3e9ed10e5991d5e2aea0360e97547955c3b80beee88f14c62b2b3f3ce3848de2956806b7b76359ab712e6bcf91b144e620256dcbd3e858ec82b7ca469460f3086cf6275d992285b29ef6fec34b986aee8c35b709e6a0fbcd423537675535a24f6655219c7b1abb75968a5ab52ef167f6fd4ce178805f3d914bcaae1590d41e161f85a2fd6f2b59d488f4b45180ae222004dbf9e566f80dd2b7d6e6197ca0f93529a598f4e57da1ecc13f4b81ab0d0839731ae2d1c1c680afb1f83ecb5a805381ca655f78e83ab7eddc7299c81cd1c1458f51ab2cc4a5ed5a59a8b4075b7c58f61b16a794bba14b2028121cb7c04dad78ffe8ddbdd9a78b85122e33ed9cb9337d60f4db42cae8c6df8ca8828ad8b6f29ba85c358a9fd8a6f6f91f8515cdb5a633b1b4d3f5a09f9278f4c79ea52012fba104398d4fd7d09318fe847f56823a4a684cf4909607acbcd83aa7676018b87728d9f660c447940b027adcc42db85dff1f6e26b0b99bd135042fd0c62a7202b0b6de7007fdd2850cc0347e3dd34af52abaadedf1cb0649d0c87a2cfa3e805540bff1f2b5def9cd64a7571501f82719d93ef7fc6661030993a55bf94d515ccae3932c2bc12aed211839bd07dd87d185371279e8f72d0b46e1eacc44743d4d78c70f2a034e88d320b693c75ee64659fc6109765e1b36736c86e3aa5c2a16c52f39557d196fa7fd302014ad60064c32190007843c28d97cc7b1e8fa84c27d3e543d25bf889a5b473f27858551cd8dc28cb03badd90caf1420abe58a6443ddda183d949fd00bbbfcbca4994a0b5189fadadb62daaf6d4c9964f2e1bfaa5564b4d9fbe68a569a54c3137d4c7dc2f5b8115a63c1fa3aee0ac882ca78944602c3f5f314045d4b9ee4bf1f94f9bfc2ad9cc88c7ce52796688615f7f0522a4f0d3f06ade3b014510a28c59fe5e78c82f607b007fd588da64a5b02d477306afd90e9258af2e100a00b7b14061ee982e641fd2a3fd38e04ffdab57224f7e08fcafee34aee20178a70a86aab74738365951b6631ca9c0b64d31cfb5be201d03e7687d966e0bb3365abd99ad484510d38a93d095a5626163ca100f0c1b46317dea62c6c694c8cb5c42897ee312d306defee705ecd5b548a024a878429a49481194eb77d6bc768c1f194753abd6d037e616ea2f5c3a2e8f1d964f3e7284da87bb14bede1636c4a74ee0c8037c948c1947b649c35bd12bac8860e84f403363bd87cc22677544c522818820f214c29c171ebf267b120456638b03f08fd9f7da6bb48c30754324c5587db04ea47f70defbbcce5c624a99fffd3865df3e2b513c22c49bf2011d66d45fd2de353dda63cd256c5fa12393fdb81cf6c497789388df5678d55283e16ef0f875accec77b12cb90018662c98eb8552e13e841261c6a05b52ea90c144a72ef7d2e998763d4cbd6f95891ce37be164e58e16e68619a83ea79327f1c190a00b8579d85acbcdd300482fa0e3f411c1f5ec91c80cdd7d5380d9ac7fc56fa852e6589d687769d02767acad2a3c84cc0a31275cdcbf630ce6c38bd3c546a2b560bcb393baf9bf2acce9096feace3e3bdc86ea2c10ab7a1b1984eaf7f42debf5ebb8e718481a8dfd979d0bfe194c08ad893388d40eea71de4ff6bcb86a5dac8b17170c2c06b833c1c429e25e0e82b969a18045af7dd5c3a28b0ddb10d7d34adf308e23f871919f21d87a3f5db23f622bc8bfe042b52578d10e8575e241711de478922cecc476d8a28d6725d90c128ccbc455b2085779441a752f14a190be74d96d79f1a1f539cc0fe6b8e32a5d5ffb51b34e5407ff92eb070922469e5b69585598e5ef77e284db1fed04fd0f30dc71e7ccf067d8316fd728c81275372bb2f8d71c2a1df649a47ecf4a2a7aaf16cce62470aa5a056784f27de118b53db19834d9910af1b1554e7f8819ab4eca23a9ceece0e4f959511bf45673e002e603c5cb7cdf53a7aac9a1bb65204cb96ea3ec1441777dab3ab56fcd3e576d967b3efff5a59a55cc1f013f1f7807daf25e16c0efbed6ea874495e149642e98d33053bb6b3f70e17095663dfa0fd9342d96bb461396784dfdcc9688af3a7c67ad27ff79fa28d0c42db99b41edfc28f445b4f14b829acb2972cccdac902247aac10a44a913c3158c3921da550b374dd621723049a240391c0ba3eee55399c4633c8f8a07f45123f80568ddc37eb613ffd311f6e079ee18717c2ae31180ca3180f2677f0f9f0bd0ac1643c7985b4f4e4b934138d56488f8958269c5ec41cc6d94c9bfbbf5c495aa1e2e59c0e8e74bb8cb53e2ad1e029bd00250f8524a119ddaa280259b12d993f0772885fb15d11f92a3d598cb14ea55ff247822914f9215df5e6d7144697563b15c5d21a232aaecc7ae8db2d5065312beabc8d9341232d3555aac27b024ec87929c903a9f9811a418a0b0bc9ab4b491677a79f699ef7e816fb3c89ad4e757c87743ccc7771afde9eb6939fa7e1df8e6704e82cebfb06dfe429b580d6ca2ad046dffb3c9baebd97dcb4537ff9e650792afa4a14190d4c87db7acd0d4b2e52b53e756a2a34be7f8db10f09799f8b565be5eafbf1a61faa68968a59a71f083cf52ba4171165ee169dcfbb7aca244582c92f139e15725450cb1c949f6c2090a9caab659c1f0288c5116fb73c9c820d11d16a90a8902970baf2e0d73c5789e4e082b5ee6f63b9359effe8a983b6a8da235f637f690f4cb1736448efdc0813e1c82d201ddadac3a397236f4043bfe77749e93a77261fa163288f43e661c3260668832f548c428b593b67c025980ffd25bbfe911efd5699e3b10b1591b37b0f496967b482e1c2ec030aa8d7613b51ec58616df59ca2732a1c3e69534b054a4ad44b2e922b1300ebc0872d69670129f60bf7540a93c7632ccf4e14841447638fdf114a1ea5483e78edc3209d3b899224d452d9a104a32a63fc69823ee2f6105ee66474fc473889846b377f7053a0cb21e372a77de893e0ad65f205e7c1fc7946381580ea5918365f4002731a3abb9f113c49614be9d8cfa8e52b07fd0f16b30db314643aad55a5ec9cd395ff60f1323d3c99b8bb946a885662e23cca9888a0374de46ff26540c2fa15af5483a7949f8ba76b839647addc22e4a9a8ce2b464b789ece9f79e052d26f1f3b7ca34f44f5e2f3afd49a8ecd843884dcacb6a662bdaa6fe3f5d654dda7da5e254633dbf618ae7efea7b4a7333ee2cbf6ffd1c0c169d088632ee02b026e4e24ad41efaf63d002b2bedffcbf91f252fc4c9fa6440c96f0bbf09adc45dc327ac7771bf928a7349f1bd283342b7b078765c5312c3c492143e6de443f7be9e383ac995b18ffeacf3844cc96c95446eae3cdbd81f88bf92a76915389ebe217e04c04c570d1d98161b611f51a15d588328ff10230e0e70efa6a9c0ce63c61e2b4910c79efa94744803cd08dd01d9bbe287f2b8a650744b4a7dfd70207200b2dededa74d9f04c445147991bfcc83ed42c8c71c4a78fe3fb539de6ac8d5f8441897cca180bb9bb1512e199b8717dc3fc43b0bcfdec76cf77ca99c6d80e5b1d32ce12899be1979ecd831c0c8e77b5e34d241395fab1d2fcfac71df2aaa2efb15ad0996577a2113c67087ab1eb810f70c78450edaf2755f9c463411743a2781b570ebad8f20f5edfdb82e4818865df1c5e81ebe243da362a674f179dde27dc4f8660434ef5a55d126d1a7d240e39c81e523588033a3a434472258f62e55187c479c6c70f947d9d2e66fe4c0b9d7579b94bcf543a22ffb7036644a619072caf6a5520461f4b64f071df9d91cd30f7470ad12a07d2943ee39d815438e90a62bf233336e48fabe5d7afdf9e467dba742c39ea5475e66983de95c8cf513e161771021cd65e9ae63d7b6c452970214e7e833e3bafd10863071882520b6e9f90038c861e1955e56dd84b57b97175273f7147e404b220f6cb10c19e94592f9c9cf518074fc5d34e83632c6b0f14d76db189a74a935f8110175d40f58f047130c7451948d21c99e0bf2d3705609de57b02a50be01c07a54f680f24608af269f24466e4c46d3113791d4fced305bebd16aa76aa3bf105bb48d9751af6101fc2fe6f5981e1915310e3792833ebd586abf3c361c531948b8d5486c1d60d1a420056a712634a1a1ea6a4a3df2a3e77ea90756ed10c0485980544cdabf682f95615f099be7848878df1746340475c4b71f307bea1b594b7920f97f55a2fe4353a8f0ea662eeba2d9d5cef26def4fb775020f92e4f4cc20153b9b3022ea7b92c3b85f8d5ab211f637336f78452e043671ea74aeda1c6f6c7cebfd5ad8379dd4228936ff53ce7a2bbf7fcbb211dc1436db1154c3b4f2f92162518b024d4b10290af1f52cedfba355603bd46766e105259cc4323a165e2c9e780f0747753ec43d8a8e600241497feb989129020bd1c59ae656124316341c67c52d0f03c3a36696125cb9d289cef4573629a5764ddeee0f89197680bf04bc9ad4aaf235a1ff3433b6632f08b065ee4a6e8cc4a306cf1ea161483431ace303b496e1561feb86a52c36abda59647baad346b1aa5ca690881364ad0f7e7cfa602b9ac57a2bf98f184b74e3c443aad7948ec084744177b1f2173dd451c10175c7330685bc29771bec9ab79f2c28cf59e0db6b647e77dee9450995db738475b57f002e4cdd0d6c14f2d55e346214fa58c323ba034e1ccc8cfb189e4656303fce8236fe00cc98836fe261a3b592d974bd3394432c6069ed04f6fb11810bda8c2c5ea9dca3a54e50dd197ac2bf0f2dd985dcf75af00e4b6dfddda71ae28150462f06c8abeaeeb37f071fcca59c17b9455c73139ff91b2aec2b5969fdc6faffcd00abc5ac633cca0d93f427b5d1d523e4f8841480bc5523c9448c2157de5ff00d9b974ad1ca8d992474426e03acfcacf2172723488d76b6843aa9a5153a227e98b1996d3b39e6e127e8b84e87d0aa7a3e48fae3fdc364c35bd6107ce80e19dbfa4d282e3fecc1d918441a39979d0164be8b2548ca8ead559933e1836ba8d71eb88198de81b38e0aa08e80f5afd8585ea6182e289e795b47af5bd2a562b7e20f79d79ed0fdb15f63b0c778765382e14cf1176f45f705bf11aadcc528c85c7a678647ec918474148fb6f2222cd582a8b53703825bf71ab4d575648ac9750fdd4dbcd70ada87ee4e64e61f4c42fe0419a3740743026f73e6228c4066be0d0f0c026cde97944a059697916ac8e84da42ba9d4b772a54f10f34dff63508817226324329702402320fee45d5527c21adbf5a2a4294ad225902cd8a916ec99c8f8f6f76a176a2dc8c95b9ae6feda797425de4b409de9ada84b6412ee7ceffa0d5994480c1f50d19328c02ce8675b49fa490a79a4c3ac3c367f92fccb3f7e031ee9d7b69c065dfc68f82fba303eb00b3bb7f4938ffeb6a3470b419224f4c1d353e3262e6e050e8d804f0cdf132e8e4b5a65c874746b0a5dd9829ca94b2a13eb87ab6a6e204cf97a9a6ff0f66f07bb19ea9924080086312ab39776978bf451958c9c047c11dbe6df6562af15e28a53f6cb551860b14b7dee709bf8b2df99d7b59c9c58d4f609c92fef496c4f8b6fdcc160eb7b59392c22bbce4da6402e4c2dce9e15fb728c8f5b1ef37ab9d132c5cb8fbc09a7f966f7583469b2b05e9fe79a496e92a66d6c3598b9b157541c692737f2d180013d941f7b9225b61d7b8de388835b3a938480a070cf5f4cdcc6d3247333848061c9f86340e00e0ec8d67ca803d3b82c4f6d22c329d1d57f91514cffa0f52e32d9515200776f8825f7a2bccd52ce6363121d2be70cd24018ba6d94add4c82d4e844bb654215e63b54c44d80051e759da6a362d05c0e9dcc634409590edc60a53bdbed89cd72a1eeacc1810b8b29dd39a2e3496f3932dea63f895dbcbdf93c5f7883cd4450a015718b83fa38e8f00cc4d741e38df677c87bd2b254e7da83eacd2a3483678c7630ff105d589ec1e6cf77a6114d63bcae2ebd2c9d859c3f66eef2b8fd3999ce6814901d58b0ac83cbd3a7f74f7d10baa031d8c410296bf53a46efbc89a4bfc2f27465a3d9455b564b8fe34975861721960445b1f01cd632b9e4b012feb296502838a75921e6499e982966d8ea8efb400fd5ff4837f71a9e7a00b8123cd91ee214b478a47444670ad040552a9f0fd57e4ab678d4a2df445404cf2ed242811e49f20d8401c8e9382dfa819e430551f81ff4ebad1cbbabc440531a4a2f28aeaa6d500302fe7e2de2e4f1b80a073012c45e923e793d0e9f7b19b68a696c4fd83ebf81a8984c18e2d923f334fefe350a34f9101c87034c129fc4a5b418814d0c402de86cd8fc987e92781eccd4d9770c52c8da5a0884ec1fbb1b8f77716f483cc784ae42467fd69f9f6bbbf780367e76041c9a8fe9b2aed2328f3da657dba57161211fdcc55a235a00bb785313a28c2a583e249049871c8f060de99b96b970f638566f46995dc926d2410785503ed0e226c3ebd117035a8005f5b13ca63e38fb3293527db17d21f7ff64ef85934752d8ca7b0e413876f37046f2f162c0e99f1808c9e368f3da2edbb8cd20eaf5c6998b46b8851171a5c26ba7f81735ac7e0e1db8ed88979cea6e8a27ac51d58f3b58dc343df5a354b03a83ac2c12f73832937cb82934eab09fef85207514559a94a6229c5447b3d15190bfe215df6c7818d7172fdec3b5c343a7b5f7304a3db0f578c0b2c72efbe181f462a382755a096fb219b20f1d0754e2d355a62d6a550103a4439f10eb828baf9317280be785fcb0bbca2a278a43968363ea7ee4ece7de2862d3f1ac9a09d09af16302beb1e2ab1e557d8c748566a1b0b4e91c858566074090759dd419ed31cf36107a57e031a5bcfbbb2ade5ad0086ab3e193e58e4069049c12c1807b28a9801ff335b5e304d6bc264ae0a0cd47a94cae18572c62ed9c8258f907219bb5eb51d61e331660d8bd5ab96adddd634d5199b69464c8ab49e0d114dc9e99b8ad2235b64ce1202ebb79ad358f67def91a72990a07ed985663a28217668c13fd4108bc0f9adfe72d2e532d6e851a2030dbc739da2a752c95c8d21a90512effb5fa0f49f50827cda90cbfab510da3308502f7c8109a2220794909a476af7670f4017353bae561d380eacdf961337075229387a336189bc464cd2cedd516c72698ea6ae2085776aec2ff77ffc2cd31072b3de28c842929292f0f2d3bf9cd1f6c844bd6640ef1834e4cb33c955269ab8460c51be421c15a29d2df1fcada994393258d4514d9d9b6318a40836bfe1d5f8d04ab38c590e5f52d82d30f4f3cc6f6e183057139c3f15ce9965b36d6cbea1274bcbb4fdda7a53adff040a2d5b01482f25ec56d64b2b9a2cc936ae0d49bf0d13a0075361b17e1c301d9edefc1b5271b68ce6afaafb2f5f0a3b5f4cb65fd9ba3346dc0b7f29ec43c799ec157445ecc5f7681b6383fc1b86b10f7d6312ad021b51270d376234e7d122f7c7fb0f24ec50eaa75d017be3ef679d0f8d7320ad81f8b8491a883fb50c7c727343746417562323a8c9816dbecb88638beafcf2411f12fadc97428bac8a947b91fc9deda097d80cc57c86e6bd9d135b369aa0d5fd96fd5a3bbfd7580a9e229009f7b5e6b6c79780d0109ed3e7a59a743bcbc2c2b5aafb1ab7b43a76280759416333f7ac7f5360ab725d3f7894c6c82342556c9d85a873dfb6d1dd994f4efcaccccc7afe545bb2e9cf7dcd012c74b85002e8b00cc5b4ad8f69cf36ea16e8c673f0e614721529c6332bf1f119a4f877c3623e1355d7d81915507474df4a38db7fad16cedf6127f6fe7d42c9685fcd9e3d89afbb2d1e34535a720c0494e4e3b1da5d2469360c9d0034c255e150cbb8bc22d6f3f98813d60d789aa410a57f7f88b284d9669d1b992e70c2cb3f80673097aa22523d925fbbf17a97b6fa9fade7de3dcbf90dba1043ac626a6960658468a58c0f9e8fe725ebc6946457318578d570ca68ee8c7904b7c26863cb9691aed6afcca3cbd726b29867613276f25b6603ca4177853bcf975c5e33e024949ec1f6ea3c524499f8076f4f0e86ec2f516104d098de887b3e448eccc1b175a568ae0787bfb0345bbdb25fedfdcee319e92976150c002caa346f8263be95dbce9d23a2bd9d5833df8b912095ddcb2f94d4ffe9479243331450055a08eab33efff2c96619449d8cc12df50d4fb54e48af1a08590e0198eaa5741705b27702d91b168a80a0e21d87b303759a1ea2b23465b40c55e1056c94bad00d61740c750a25dfb14393046456c9af5807de20ed4d18bc3d4b48c84c7d1c5a85983c57f711e50c365504c8daa757b4fb30f98ef6a1be926a7392f2a7b5105c51899025d304259ac1904a262b5400689d8a5be05b453f6cae0ac0f45157583d74401f64e6e1da2a36d062b12a907fdd74695c0952f7d2a233e25edbde4470105de82d63951b95e7109bbbea1c325a57587371279475085fbb7677ca64958f42e44b697da5744a500e00bc70fb21c913a50b891f74b75b8331d018e47ee7adec966b6c5d8b18377f063cd565ec3d9e5f4ed65693d082029108a1d4741719023e53058d8ba939ec4e1c51a9e244bb27618e60e16da3902f174efac394280faca448f7b6c494e5bb3bd65b7ff2f2147912beb4f83695f1e732ff7abac239813a4eeaa899558f933ec8cb043b56da00e2e0983d7e7f5234a3f08d68e750e1ed9ebd567382b7696f1dc0cff0cd746f1d83dc3b339b9eb415893bcfd4f3e5b9fd6ec8392435d278e090954afddf9a314f5efecc742dfc3f921e3d08adf0f999ec7840b6b92cf77dcf8173b0c9b202b92792d345c88474057ee1491760356877814f9d8de400225dc4ad860968a017c684b64e4a40037168b04ced421af3976166bd0cc1412c058800417c78525e577d17e3ec03f172ba7210f06257ef2525a60e7ab7e793972a8585e594a738f2ce00aeddc0b897c1adadb468b408a0f34cbb592e66043a344ed8b74d00d619718ed7c4581c62010510e54b93d51be852c70176c63de860a638d4f4014edeada01e49ce0a7430c9ef41e72fd09f3a48161700252d6d42926a9c26e509606571ea50461e05753fbd2ad174b51786458acd0bd072dcf42da0b0a93b05c3a5f435d361afd78ac2aa19bf56587695f6efb3ede231a8da0fa258a899bbab2b4a37d414d2f2e1ef9bde02af71abf99070fc4d85d3f0152b0b193b70c84a54900461ce23f4bcbad5a7c7c2897fbf887f5dcaa7d88234f0f213fad0cebc522c937cb378aa71f4e40829710a58185ea650e62c8b87c9da0ddfcaf39685056438eaf76a78a5a108ccd68db43d4c00ed4beb481399506f1f301a673eae65c2739190281e2594010f8f5c80b6c84c5603803d54a577d9b86651eb54da2cff89343fdcc596d631a39dba37dfbf025c4fa5603c1f7993e08d79604f6cf0da7d25e4d7bb6a21e546ba8aff016ef5856ebf8f58aa011baf8d20ff7e7048fc33e4494eb7e468cbc819a790573606015dbdaccee7f840dfca4670af3c90ca5d59fd7afaaa00b376e5e8ad05857fcd71dde28b4bcd08fe16d9deaea034f0d5628f9509ef4c6dd1ae4e74e4e5c03213d9be1e2485716c8094f841abd0799c528de0b0caf9ccff2729d3528ac3491275610582a76fff76138a63d06a068a8787920f615cd66300d18bea74ab5e3f3a3549fe21a664d6b02499ddb1e068abbe541ca3f131361b0ac76aec5eb7a45125c43e279b32c8fe0f412db11c2c9a084f3b2203f28dc6a0b722b1a0b6c0942d2d8c46d7f125b4f2ff32f215778b65a8202c1c1f709381e19f84568ad6a90306587ef71b483b8ac5d18741d0290fe77ead9d53a468b0ade3cc68b7b21c4634394f8780b07b5689cb89c02e0cd906c8f97b96fce7eea0a4174b8f13d10dd9b8404ceaea2d59cba6ead7cd186aac491714df1fa0af54232480c6c781b15782aa83ee0fc14330344ae7f840497be29dec2b36170dea05ac0d1248caa2dc18391ee6b53de88ee9400c14aa89a126ceb054bd484e981fd9cb206a4eef01479912d47c4d7d0739e52fa03004fd5e68e170c0bbf1879868995afb8ddbb11edc441dd4a8fcce6f22c338fd1384cb90ce9a8b3fa4434b1f54f325389ae90d84ee8a0f4171b6c7e059d003b871a62e82cc096a2c76794daca5d5ffd60d194bb0a358e9f2d8dd9f94cefd1d191a1bb2746c6686ce620dd68de03ca84dcfbd1709fe19b4b9ea8356dcd2006eb630dcc6b084aee7ac83b3204569feeab610a9684fd12a63b366bae189dacfd38fd2e1242", "isRememberEnabled": true, "rememberDurationInDays": 0, "staticryptSaltUniqueVariableName": "a9b8888db05aa4f8d4cc8f7e52742379" };

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>