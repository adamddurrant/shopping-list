<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-toggle-password-visibility {
            display: none;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            border-radius: 10px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            border: 1px solid black;
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #ffcc33;
            border: 1px solid black !important;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #000;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffcc33;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #ffcc33;
            /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #ffcc33, #8dc26f);
            background: -moz-linear-gradient(right, #ffcc33, #ffcc33);
            background: -o-linear-gradient(right, #ffcc33, #ffcc33);
            background: linear-gradient(to left, #ffcc33, #ffcc33);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
            font-weight: 500;
        }

        .staticrypt-footer {
            position: fixed;
            height: 20px;
            font-size: 16px;
            padding: 2px;
            bottom: 0;
            left: 0;
            right: 0;
            margin-bottom: 0;
        }

        .staticrypt-footer p {
            margin: 2px;
            text-align: center;
            float: right;
        }

        .staticrypt-footer a {
            text-decoration: none;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <h1 class="staticrypt-title" style="font-weight: 600; font-size: 30px;font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif">Adam & Helena's Lists</h1>
                    <p></p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password" placeholder="Password"
                            autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="template_toggle_show"
                            title="template_toggle_show"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                        <input id="staticrypt-remember" type="checkbox" name="remember" />
                        Remember me
                    </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator =
            ((function () {
                const exports = {};
                const cryptoEngine = ((function () {
                    const exports = {};
                    const { subtle } = crypto;

                    const IV_BITS = 16 * 8;
                    const HEX_BITS = 4;
                    const ENCRYPTION_ALGO = "AES-CBC";

                    /**
                     * Translates between utf8 encoded hexadecimal strings
                     * and Uint8Array bytes.
                     */
                    const HexEncoder = {
                        /**
                         * hex string -> bytes
                         * @param {string} hexString
                         * @returns {Uint8Array}
                         */
                        parse: function (hexString) {
                            if (hexString.length % 2 !== 0) throw "Invalid hexString";
                            const arrayBuffer = new Uint8Array(hexString.length / 2);

                            for (let i = 0; i < hexString.length; i += 2) {
                                const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                                if (isNaN(byteValue)) {
                                    throw "Invalid hexString";
                                }
                                arrayBuffer[i / 2] = byteValue;
                            }
                            return arrayBuffer;
                        },

                        /**
                         * bytes -> hex string
                         * @param {Uint8Array} bytes
                         * @returns {string}
                         */
                        stringify: function (bytes) {
                            const hexBytes = [];

                            for (let i = 0; i < bytes.length; ++i) {
                                let byteString = bytes[i].toString(16);
                                if (byteString.length < 2) {
                                    byteString = "0" + byteString;
                                }
                                hexBytes.push(byteString);
                            }
                            return hexBytes.join("");
                        },
                    };

                    /**
                     * Translates between utf8 strings and Uint8Array bytes.
                     */
                    const UTF8Encoder = {
                        parse: function (str) {
                            return new TextEncoder().encode(str);
                        },

                        stringify: function (bytes) {
                            return new TextDecoder().decode(bytes);
                        },
                    };

                    /**
                     * Salt and encrypt a msg with a password.
                     */
                    async function encrypt(msg, hashedPassword) {
                        // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                        const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                        const encrypted = await subtle.encrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            UTF8Encoder.parse(msg)
                        );

                        // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                        return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
                    }
                    exports.encrypt = encrypt;

                    /**
                     * Decrypt a salted msg using a password.
                     *
                     * @param {string} encryptedMsg
                     * @param {string} hashedPassword
                     * @returns {Promise<string>}
                     */
                    async function decrypt(encryptedMsg, hashedPassword) {
                        const ivLength = IV_BITS / HEX_BITS;
                        const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                        const encrypted = encryptedMsg.substring(ivLength);

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                        const outBuffer = await subtle.decrypt(
                            {
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            HexEncoder.parse(encrypted)
                        );

                        return UTF8Encoder.stringify(new Uint8Array(outBuffer));
                    }
                    exports.decrypt = decrypt;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    async function hashPassword(password, salt) {
                        // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                        // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                        let hashedPassword = await hashLegacyRound(password, salt);

                        hashedPassword = await hashSecondRound(hashedPassword, salt);

                        return hashThirdRound(hashedPassword, salt);
                    }
                    exports.hashPassword = hashPassword;

                    /**
                     * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
                     * compatibility.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    function hashLegacyRound(password, salt) {
                        return pbkdf2(password, salt, 1000, "SHA-1");
                    }
                    exports.hashLegacyRound = hashLegacyRound;

                    /**
                     * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
                     * remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashSecondRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
                    }
                    exports.hashSecondRound = hashSecondRound;

                    /**
                     * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
                     * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashThirdRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
                    }
                    exports.hashThirdRound = hashThirdRound;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @param {int} iterations
                     * @param {string} hashAlgorithm
                     * @returns {Promise<string>}
                     */
                    async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                        const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                        const keyBytes = await subtle.deriveBits(
                            {
                                name: "PBKDF2",
                                hash: hashAlgorithm,
                                iterations,
                                salt: UTF8Encoder.parse(salt),
                            },
                            key,
                            256
                        );

                        return HexEncoder.stringify(new Uint8Array(keyBytes));
                    }

                    function generateRandomSalt() {
                        const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                        return HexEncoder.stringify(new Uint8Array(bytes));
                    }
                    exports.generateRandomSalt = generateRandomSalt;

                    async function signMessage(hashedPassword, message) {
                        const key = await subtle.importKey(
                            "raw",
                            HexEncoder.parse(hashedPassword),
                            {
                                name: "HMAC",
                                hash: "SHA-256",
                            },
                            false,
                            ["sign"]
                        );
                        const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                        return HexEncoder.stringify(new Uint8Array(signature));
                    }
                    exports.signMessage = signMessage;

                    function getRandomAlphanum() {
                        const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                        let byteArray;
                        let parsedInt;

                        // Keep generating new random bytes until we get a value that falls
                        // within a range that can be evenly divided by possibleCharacters.length
                        do {
                            byteArray = crypto.getRandomValues(new Uint8Array(1));
                            // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                            parsedInt = byteArray[0] & 0xff;
                        } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                        // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                        const randomIndex = parsedInt % possibleCharacters.length;

                        return possibleCharacters[randomIndex];
                    }

                    /**
                     * Generate a random string of a given length.
                     *
                     * @param {int} length
                     * @returns {string}
                     */
                    function generateRandomString(length) {
                        let randomString = "";

                        for (let i = 0; i < length; i++) {
                            randomString += getRandomAlphanum();
                        }

                        return randomString;
                    }
                    exports.generateRandomString = generateRandomString;

                    return exports;
                })());
                const codec = ((function () {
                    const exports = {};
                    /**
                   * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
                   *
                   * @param cryptoEngine - the engine to use for encryption / decryption
                   */
                    function init(cryptoEngine) {
                        const exports = {};

                        /**
                         * Top-level function for encoding a message.
                         * Includes password hashing, encryption, and signing.
                         *
                         * @param {string} msg
                         * @param {string} password
                         * @param {string} salt
                         *
                         * @returns {string} The encoded text
                         */
                        async function encode(msg, password, salt) {
                            const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encode = encode;

                        /**
                         * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                         * we don't need to hash the password multiple times.
                         *
                         * @param {string} msg
                         * @param {string} hashedPassword
                         *
                         * @returns {string} The encoded text
                         */
                        async function encodeWithHashedPassword(msg, hashedPassword) {
                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encodeWithHashedPassword = encodeWithHashedPassword;

                        /**
                         * Top-level function for decoding a message.
                         * Includes signature check and decryption.
                         *
                         * @param {string} signedMsg
                         * @param {string} hashedPassword
                         * @param {string} salt
                         * @param {int} backwardCompatibleAttempt
                         * @param {string} originalPassword
                         *
                         * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                         */
                        async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                            const encryptedHMAC = signedMsg.substring(0, 64);
                            const encryptedMsg = signedMsg.substring(64);
                            const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                            if (decryptedHMAC !== encryptedHMAC) {
                                // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                                // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                                originalPassword = originalPassword || hashedPassword;
                                if (backwardCompatibleAttempt === 0) {
                                    const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }
                                if (backwardCompatibleAttempt === 1) {
                                    let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                                    updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }

                                return { success: false, message: "Signature mismatch" };
                            }

                            return {
                                success: true,
                                decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                            };
                        }
                        exports.decode = decode;

                        return exports;
                    }
                    exports.init = init;

                    return exports;
                })());
                const decode = codec.init(cryptoEngine).decode;

                /**
                 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
                 *
                 * @param {{
                 *  staticryptEncryptedMsgUniqueVariableName: string,
                 *  isRememberEnabled: boolean,
                 *  rememberDurationInDays: number,
                 *  staticryptSaltUniqueVariableName: string,
                 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
                 *
                 * @param {{
                 *  rememberExpirationKey: string,
                 *  rememberPassphraseKey: string,
                 *  replaceHtmlCallback: function,
                 *  clearLocalStorageCallback: function,
                 * }} templateConfig - object of data that can be configured by a custom password_template.
                 */
                function init(staticryptConfig, templateConfig) {
                    const exports = {};

                    /**
                     * Decrypt our encrypted page, replace the whole HTML.
                     *
                     * @param {string} hashedPassword
                     * @returns {Promise<boolean>}
                     */
                    async function decryptAndReplaceHtml(hashedPassword) {
                        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                        const { replaceHtmlCallback } = templateConfig;

                        const result = await decode(
                            staticryptEncryptedMsgUniqueVariableName,
                            hashedPassword,
                            staticryptSaltUniqueVariableName
                        );
                        if (!result.success) {
                            return false;
                        }
                        const plainHTML = result.decoded;

                        // if the user configured a callback call it, otherwise just replace the whole HTML
                        if (typeof replaceHtmlCallback === "function") {
                            replaceHtmlCallback(plainHTML);
                        } else {
                            document.write(plainHTML);
                            document.close();
                        }

                        return true;
                    }

                    /**
                     * Attempt to decrypt the page and replace the whole HTML.
                     *
                     * @param {string} password
                     * @param {boolean} isRememberChecked
                     *
                     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
                     *   expose more information in the future we can do it without breaking the password_template
                     */
                    async function handleDecryptionOfPage(password, isRememberChecked) {
                        const { staticryptSaltUniqueVariableName } = staticryptConfig;

                        // decrypt and replace the whole page
                        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
                    }
                    exports.handleDecryptionOfPage = handleDecryptionOfPage;

                    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                        if (!isDecryptionSuccessful) {
                            return {
                                isSuccessful: false,
                                hashedPassword,
                            };
                        }

                        // remember the hashedPassword and set its expiration if necessary
                        if (isRememberEnabled && isRememberChecked) {
                            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                            // set the expiration if the duration isn't 0 (meaning no expiration)
                            if (rememberDurationInDays > 0) {
                                window.localStorage.setItem(
                                    rememberExpirationKey,
                                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                                );
                            }
                        }

                        return {
                            isSuccessful: true,
                            hashedPassword,
                        };
                    }
                    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

                    /**
                     * Clear localstorage from staticrypt related values
                     */
                    function clearLocalStorage() {
                        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        if (typeof clearLocalStorageCallback === "function") {
                            clearLocalStorageCallback();
                        } else {
                            localStorage.removeItem(rememberPassphraseKey);
                            localStorage.removeItem(rememberExpirationKey);
                        }
                    }

                    async function handleDecryptOnLoad() {
                        let isSuccessful = await decryptOnLoadFromUrl();

                        if (!isSuccessful) {
                            isSuccessful = await decryptOnLoadFromRememberMe();
                        }

                        return { isSuccessful };
                    }
                    exports.handleDecryptOnLoad = handleDecryptOnLoad;

                    /**
                     * Clear storage if we are logging out
                     *
                     * @returns {boolean} - whether we logged out
                     */
                    function logoutIfNeeded() {
                        const logoutKey = "staticrypt_logout";

                        // handle logout through query param
                        const queryParams = new URLSearchParams(window.location.search);
                        if (queryParams.has(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        // handle logout through URL fragment
                        const hash = window.location.hash.substring(1);
                        if (hash.includes(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        return false;
                    }

                    /**
                     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
                     * try to do it if needed.
                     *
                     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
                     */
                    async function decryptOnLoadFromRememberMe() {
                        const { rememberDurationInDays } = staticryptConfig;
                        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                        // if we are login out, terminate
                        if (logoutIfNeeded()) {
                            return false;
                        }

                        // if there is expiration configured, check if we're not beyond the expiration
                        if (rememberDurationInDays && rememberDurationInDays > 0) {
                            const expiration = localStorage.getItem(rememberExpirationKey),
                                isExpired = expiration && new Date().getTime() > parseInt(expiration);

                            if (isExpired) {
                                clearLocalStorage();
                                return false;
                            }
                        }

                        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                        if (hashedPassword) {
                            // try to decrypt
                            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                            // the user fill the password form again
                            if (!isDecryptionSuccessful) {
                                clearLocalStorage();
                                return false;
                            }

                            return true;
                        }

                        return false;
                    }

                    async function decryptOnLoadFromUrl() {
                        const passwordKey = "staticrypt_pwd";
                        const rememberMeKey = "remember_me";

                        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                        // since it sends the hashed password to the server which isn't needed)
                        const queryParams = new URLSearchParams(window.location.search);
                        const hashedPasswordQuery = queryParams.get(passwordKey);
                        const rememberMeQuery = queryParams.get(rememberMeKey);

                        const urlFragment = window.location.hash.substring(1);
                        // get the password from the url fragment
                        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                        const rememberMeFragment = urlFragment.includes(rememberMeKey);

                        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                        const rememberMe = rememberMeFragment || rememberMeQuery;

                        if (hashedPassword) {
                            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                        }

                        return false;
                    }

                    return exports;
                }
                exports.init = init;

                return exports;
            })());
        ;
        const templateError = "template_error",
            templateToggleAltShow = "template_toggle_show",
            templateToggleAltHide = "template_toggle_hide",
            isRememberEnabled = true,
            staticryptConfig = { "staticryptEncryptedMsgUniqueVariableName": "58637c485cccaa7f0eb1f7c1d4e23d48e9c12509e177501b5f0082d5fb7f71ece09252fcb6b158db9223558777505383287513dfb09ef375b77834eecd673de627a14862d65ec7f474cfe23433a36696124c53ae234c41dad63107d92eccf086fa0b2c11daaee4bb331980028ee9d06b6a7d8d59700d1512b0b6ed3d635bb3a2d263cdb9168fd6e496ea4d21429757c10af164fba5348498cb3c20a9170792987c7f9192a4cee4a2e1b4680419c29b9e5204c0bbde05753a3ab47029243f0d6b08d1f6b8576b68140e534c11b0122a7b71bfeda169ef1cd92f4d3a3efdfab43c1f4dfdee9c875263c201f91121f36f49362d7d08d615ba8d4b4b0634273dac297e271eaee620a90568f82a2b849c7dbf0419bc62f031b15f254ee94411f5cb2a21016ff4cb4b76176bfa81101f09b9f4f88a5a8c2ac510bdf968aaf854df5b7b6a34081b03659ff34a61e63b8e7c4973de8faebbb327a1b1ff2c557d3328e4bb10a8eb8d91303df27f1d33694acfc41e5f447c549bfbfe54e1217f873104f37713a96da8250970f31536e8030eba3fdfadc7085729a9b0c7651c9e64ed982c2bc2ec085a0097ced9fc3e4595289329fc76f64b0f264757a8d292f1fc2852f39f898424cf7b6a980b5a4fb630229e7d5a8909fbe6e10e4075ca02d8106ce590c6e74a1abda63b16b80a23a0bcb42b6fa584b8abcb84cc1431476b422f4203550d8ae2dae0b2114079a8b7e493cfd14cad17fcb5c46001782952df1a490873d62e88e25339515b6dddf461fdc284d6dd21627b38c8ab115b033483220e8508b7a2ffbb77baf27d0ef9e775e6d8a470b86a78ee7a8cec1036409977275620890b85db88e83c7e3017447278c73a46548aec2f2ffccfd29fa62d3832f30c0e076c1f9465571c67ea5bc11e0682861240d152573431d2e9c86e9ba488a49a34ec774abe7079a2f2f427a81446b45af36fde7d4ebe586467a4a5d48b5f242d5a946dd158c73beff55826028b5face6ad9a2601deb5ffbddb178429d9b224625041e2c12661f5bcfe281da6f0c539ddd9cad7c7c446d700a59ff21fdcd6730b815a5c7f57d8203bc36a0b661c341a935d4606d51baefd69cbac7436d58cd38b5f239a309992064b5b4d0d0814295dfb3f1534a99e51d1df13bfdaf4aadc485bf346b280ea23326188ce7278b83f67b8cbf5b88003f9970d8b7b6987b900f2f8afb238b4b4cd5d34edf4c346d3984dde48579437badd185cd661701b4ec5221cc3d9e1a2be2df352495c85a69f48f1d30c163dad361dc6a54e6a6dee44e1918221dd89d7e9d28c01b69f4bf04dc715a99ef47d0faa3d0b39efd86fe898085a3e1fa8139eed75855e10a894dde9535abd1e35bdfb6d8a728b19bf3efd86ae2f948c5ee00e1e716aa1dbe9e56bfab34621f365c1dac13325f88aa6ac8c95d2a6e49b0d2af6a2b0809cc8a3a90c161509e498acfb99ae7241e37728d5785d06163ddc663189e5cc287a2301aa67cd89ccf958a311dfed971de3182971afd3c12bfce39057a0a8ad672f295db6def9a84447d13a2a5d03951652ba130d6ae549abcb05cd5e1aca037c67e627f9784645d2958e05fc575a6cb2730b89f739eefae135701c9a8767e82093967af5689ee099ff091c5647ec7922f489f53a206ba077546771d33ed0f0a68ac185fad2ddba5e43e50f60b433e81e53d043a4c57daa81a736835d0ccf66804e0a363710c7a830947e72b00e01241e9597fb78f4569e746a2c22ef744100dc5586d784be99ecceddaa588f311ea67562ee0eb59c4f364ba02ab3f658bd30d3a6f3220a8c0d68d61be620dd665417b8002acee2ef1948dcba55b9eaa95bc03ff33df2b66742f17f21897329703e5b536a83f197d91c92ffefbb0524a570fd2c889f1c411dc20266379843380a146d72c21208716d08cee932245c1ad1fec5d9dd4b724e43c4b5fa8f6dc842adac55ba5e9b63a30a1e0c09d6261faead65f215fcc03e629e0f5bc9d3be12d7106e69d4e6d99a7827f2838239a7e0dd0ab54dd7d75fdc15300e9aa312e9d557427c3b38a1f7138edfd09d703219a66975f853d53a91052878bf127456c41ec667c083cabf7a61ef1f5051c0f9cc4d4ff0e5177a2da6904456e554d217c51378878a8138be0dbc4f2370a5ec19516c94ce8a15d7c2c5d28938ce39bd6582ced3d34ae19e6e522637d3fc4c55da677bf44d6c19463997e034da51a5c8e1bad58d9283268795013b96fd4dabdb588c725594c472f8592b786962ce96033c92854daa47f866f060f5984f663d6c0f1f496195b30a550525a802960af204f417cf8eef295654de235e4918fcfd74cdb87e15eca0b7f04caef86e87faeb1646d021d314980bd86d975c25ce2de2658bc71f4a80b68b0cd4433bbde2541c98ee65981badfa7571cb7ad3dd0c91cf28fd37a9056a6f82581f5e183fd98a48ec9d6b701424785746a35bf837343aa04ab12349c68d56dacfbb3b82f1e103749e400ad3e9ca876c99efaf989a0eced0076febcf6ce2841a952a674d0ffcbf8330d273e8d22f8a1984483e4c3113fa68e4345141ea06f4537e53e70e87ac26bf3663db8b17c5d07dde31a39277e93072ff1f7f9ded6515672f414d8717460b57d57b59c6b3d14258ab2f5480b04e05371b7ec87fe57351bf66703d865dfe6a35387d1fa063c3cef5acdf08667b19af854a0512e64a59cb8de4430d748fc058de0ea0a0653e00597b16e9962d71bd75e24cb63233b810329da2223a2360c4922c233109de13f41d849e2207c309edad97a6ea3f7d4a9eb0988699c5d2dfc85f7bae3641a89a34dcf968bb81cb98d32a716683a52d26a182e6ed7a04d4aecee47fd2c29466f8afd1ab8b4859378327570b0d88d8b2ebc28235c68847e9f1ec3c51ee2aa0ad07f1423c24c388f5a9b85090f018e6956c5a965ebb2d1443b4e716e8057d1f96c5d3edc44e406d880dcb5ab2dc170caee7a17d699e29bf4ae41e5a1b128d0beac50ded3f826412dea8ce9aae05f65c756846af91cfd111ab7f035fd7eff1079e608bed2c95e88981c3434874f305f90c7930a7ca2e1017300e67ac2ead0fc14e49ab288b6c96061bc1c3beacfcbec521d0b592456fef3355525ab53653be629328b3ab92a8069594fab1f458ca16c9c1217d02542afa69587d1617cdea0a2d4d04ab0fd692a7d5ef1ae64c1885c9cee0605be8a3beee63ae2a1c2b3979beb60bc8ec2c9058e8e76c9090840611dd40398c7bd6358e53a5e55886865146f98a51a8b309a664bd2d891d090ed7bc57c9a9e976453a1b2a031646dc235f30d00ba57d14bdda67fdfbfc65f84ef4b033ad9464e6f3cb972316f287a55916c131e399256bac166a487cb0e3257ce7a6c0632d59ad9d5b992ed0f9758c16a402b95e22690568bb122554eeaa813e9f97f4c4a245770a6274df8d49d12208b162c6e546aa783efd8aa06bf3e16b63b7e32f454d076fd11f0c079554f6cccae7c409325fc41c021c9f8c217b1262815193c08481004551208c1ca3de92a6553b21d0deb758d6e683ce143599d52b5f37c0a770d29769c60ac2982ef1fd2f6f6c299adba00c889cca8f0b72b006f7cc14f99ff6e2731f3cb16bf1b35ee3aae2d0e66b0f0c21f962e50e9f8f1c75cec7df512b5292663a3efac31c7d7a1ffde105b1747fbd030c6da0c32e3e63941cf4686ef21524c93058b35455a3e526812ad1aa6ed6cf1d5c7a33ba582ce23ceb7a7eb515c5283eb763b27591b4c5be5a0212fa83b839543ada1a0dd9bff976ec97b7790c2ee42303f3678024404e77d7a854af7f59f7398b5ed2dd1a513423fb47700ecd9eea4443fc3defb62747bd1b27b2fa5f4f039725ec8a447f821b073479739764c4794ef7fc63e1ec20d13ef733b5f687b6277808e85b0e128be6d6b59ed10f4a33547c0809802b9fb7d6895c8ec725523acfa1721a422413097fdae09bb0a9f606ec6aa750d25415dfbbb006a9306dae8f3306cd47594fee884d40b4002704b0b650801691752ac2238d37ff301496964b4984086e032d0f6af3419eee619c27caf9d54359fe09acd57c5de6458aa7a32c6378ecd141100a935478b14ed9050473d6e04eb25c7cfda83c9c41a09aa71a8fb458acac39456209b90427af575a27c18eb2b40f406a38f376eba743adaf1c5a92260bce4bb6f32868957a7a041f5978737ed95be2895fa5a04455898c510e0c5e35abd376301da79a26b04ce11a23ddc1bde41ac3b588ae744b6ec4e082804ca079f7c362e8536b065082fe1474bfe6e88d22b893755ec271b806b6f94ba3a99052537def294f754ffb0d2b1f08d91606827be612be5d56a8701ccd1530fbc7fbdf884ce0298196fe84b3fa5c014a706ebc64f00e818e6004e802d6987837017674933b7c34ce3c429453fe23b4e478e1cf2b08e3bf7439bda885010f5027c315524169ead5c3a651b992823eef1bace3723851a2205ad9d6f77ce1073e066b20f11f78f4eded3b59a23d74e8b17cef2ec30d6fff161cf1afa22948ee17aa6a09de4c15bd30a522e7d3c798245ce54ec1d8ddf77e0a857fd36682f8dbdf6db54684ec0b84ed68b4ad9369b45c684fd65052ef449da1677048b42678bc7398fbae50a2415d1d7773388a7034eb93f5d7533df45b7abcf06bb651adfcc32eee0c8f4bf43ea528ee063680b34a4c9e1bba7028822330db04203077cd59408b6401559bef829369d61cbc5cb40240f48baa20135cd8aff13d76331c7a9d6d7c7fb2fdb594a2add75608976773b5ae005fa98c8c843a160cfe73bf37a6d67c7459c91b0450bb492c850b751deaadb36bed9b5b28810fbe1315562a0f53fc4e5b7e4d685a1bca5bf3c7286b484d3bdd7988f1bfa4e5a6486e0b4811c8452321e1bd2200c366b8e351e4037a244608b289ed4d3cf3fc0e4ec0fe719b40c0b9ce692ea5fe3af2e4d8a689a30ab95a2cfa34f43371ffd5be71c79a66455aba4cbcf65adbe3dce06968124a4623351d2ab1b5d2ddbd3141ca65697108fe68d3e7b9be771e224f44e90e818db86f607c5fc44c8edc3cdd97fc9558023c0e1cc19b92ebd02463a48abc02ff9393304240e85216d08c150db2fdd4d85be6a94bdf20400bc8f9b3af8edabee80f521e9934165dcfa847f1be826ba5ef5a216fae2e41892c8d0f7bdfaef735c87558f12bdb144651d4c68e2b2705bd7c1610d48684b586f7514b59d69bcaaec3e7e00e72ce4783af21fece5df4a3dffd4ba715704acfe7c8a370ac73a62c095b7f829fc183ea7eb91569554ee1644511426a30a76f24866bd242dadd18702084134d3dc5dd875fd4fd7f0e292a53769025e032670dc502fbbcc2d526257784dd95d7c8229b7d0274aa78f0e69108d5f7eff857d63f8a18e29c77c70d2e89509f8bb633d0b1a183791f76a4375fbafb3846cb126098ad9bab67cecb5e283073379993ce93bbab3603d04e95e7f8b4866bb3d85544e8b532c0275897da986f7f6dae5de8304b1f02c6efc13687f44a3e1d7a685e8d094b1fcb9fe80e9e8f131ab76af4636309a03faa4ad04f5793729a6550cb6d27ed30b92cf990545f6c78aac63a60952152912676bc885ef1b41cf1273604a42ae9402a253fbd42cad20ed06298c56b95dcc1700ba1188e9888a2caef16cd166c21edbc7a0398a1e2c0118fec6c4f0f34a524ba9adde17e8bf0ae92811be3e34bd89a3741d709615a8dc7fa1a25cdae060f0ab0041ba68058c93a73d9cda168b682bb8a10d350691f3340c3f483b7b80c556d44cc2ef2811b6eb161f41e64200ec2e29013d2e30fb9f1b07813a90d5af8edd2b317ca141222574ee5ae2cf30a55adaff5496db81e653e6e2705c489c0a9559fee9ffb3621f840f6c442e25344ef18120faccbecc3499297af78c1e222795fd83feef06f9ef8060b5d843d0f58b94ed19e7a76ac0f65d1fc8e350d7b24e54bfdf15c1dc15a00ba3e86ce684bf65525c36bcfa472ff304499ef0edd17fdda29e7bc7d149b0210f5ed4f3f2b2124da1a1a509a17fee5344c89764595fa29ebb4538ce99a0182c2ad4464d2f1ed933024e0f1c3d07dc22b77d6de373b1c2bd92d2f085d535a7bcaade259e263ad5dcbb19af44f42a9d5fd17a389a705b6096922014a46cdf331321da36b11e60eee4f50afc663669d8c2d351158c29579fb7e4a06b47822c4955cf842af2ef129786e10b228aa47a1c8a52bfb419a0f40c670acb9956f39bb4aa5c67dec366558d7566412230c0d83960be8b0cf3e1992c2abcbfc567ae154074aa97f3ed46a556d4394563d8262ddbf079f30fd12313fd75d6c22d2545d77bcc779731484bea63ff92c9d3f43e4de9841463e13285887a8f25419efe3ed62dcfd217ce05690a2a2f4da0d72dbb8c8228850fc0b67b285b81fba5dcef5c7de9aa5999bd196ef6d776ff0d32e547b2d32e800015acbd6f11a8360a9cfaf6aa4cbe64d344afafd0c7b62be314a12ffb8394d5633c68dd9c6f2a17f5011ac274de5c9562d9c56be0f80aa777c1b3bce7f36cf7c9716d1706aca843eeda98320c70c600694a37827460d515ee51abd4358589847f783d2db42b5592e5a88d57e05d498dc0da035e35511aa540d20f598f127c0b1d9cdcbef6854ecaedafa7ccf3525261248035d8ec5ab4de98cda3a8cc21675ab6be8fea3e743da04aad173aa2407e2b642e693b901c53fd26b5410a85afb57edd95706d623994240f362b4d993e9349ed51ecc3e6106c93ba79843abd4b234c6cb71b5b090225eed666c38d089c3d6b2189f2fa107626e3e0f00781eea357f342cb9b3ca44f96792e4d9c4583d0b4dcbc28a00511d8877b646178775bbe6d95b4929da3d48a67f9bb2fa12ed2777beb83f5ed603e0a58989e8357f391da5aba716f50a33d5b9e5f9acb108e918e3e4a27cc1253bb604117466dd328dceb7ed44288d12d9cb8799c8b81538faaa7612eccac730c5898d4f42b6e398659028e61b98e0a3d4bc768fb7e8945843745ec3db61abd3fb64102b47f22fe08543e98cec11b1969f87e595203244f69d6ff8c75a01939bc25d9f5ee02e3a5bd3c2840ba70825f474d62efc1a58c91ce0bf40dc1b1bcd01d595fd21b188cd3c16f2dbd0188ed67eb4be1645c6dc6c1ac9ca1b8cfbc8b9dd88204c0a2368179ef4f8f6ae4e7ac024258e2ba61604dd63600b64c60ff9ce7b9fec6a04ebc93bc7160d6806ae28e264515fbe6df3dfe86453d877e035f89d5442e1d6f3c1716ab82052d6d3f9fc3e6d53a6c36a683496bf4f106512d881ff28ff5ad78fe33b88f0905dff6f40b21a5c4f319841d2f1ecaa11db4a4635569effdcc1027100a5921b46751f1ceec0f640606f6d346e7f0f0183e80f7093cfa9a79638b317589463f87e436670764d8b77fc4b516d71f2a70facd0acb9aabebd2e33dd74833cc97824d91c601e8e46907ae51f9a70a31b56705c42275ba124a5652a553ec98f781fa4eb25a95e7a7742a8e2f18516fb75d307525a872e5b83cd7282a5a2c72bf34ff859e0007294e382999a1e41345999216d6a4f1d2bbce6ff0515d5bf946d4a5c13fdda395b566cdaf9740fbd6ef58fd483bf7456d7adaf2290b55e1bbd47310a9965a80400e0c7eb4acac21cc51225f8f67068513ab4fc491901a31d9ff0fc4624c80689fa2b39f98cc86161524478b5ae282d81e656ea2de50312cd8bc1106c2b714387754b80af1d27af8718992d59176338e0712465a597bcacebac808cbdc9569fe248f6630312b2aef5f683bcd2c2a3b2bc146a9daa4f2f1e3b2ffb0b6066dcc02e525c0206baf4444036321b84a7b7356e4c847fdb9da6b1bb1c12558385f5ff632252f739348d8f60b5ca020e54b3c4d1d399570625005418cef3a68e443f42ef4d8b866398ea895dc264f1466004b6109f49481683f0c77d2ac348175ed6d33d0697a53469a8313e6085ad089abab3b67db69e5ce6598d4e0ae47111a9057474b69183d1325c0ff74d3750fbcef9983b151a186db38239395334c8f41b3774fdf0624622faf28a69fe2bc557d0f29ab078b476c93ff7f4c1b3f513b0725a13f49680335f18b2df541596fbcd1f61ca2b84be2e50d717ce0185b21021cd8ec7498ac223be1129e90830c4daeacc4ffdf04f48451132a89399cc604c760670bfbbb807e43de3a905ef961495188f319fd11bfba124ff13302be7cedfb6388886a59d15ade861ee541e7dc04f9b7e9b07215e5f5b12651952601fcfadf9dad1e8d45c315e62547e30863c1bb778b6b7685be196bd8b29169a090efcf30cbfefa133332711dcf4fee4850d8467a665cf6f28786c8f54a49c5dedb0c16e4a413e48dc734663511cfd477277483f4352798398eb281071021849ee65bcdc4532739261a93d526c92d85b2583832e7b2c3c1cc0997a4a04c19ea9674825d724dd8ba22a5528a5a3362e4d00fc7527f1f7da27482d247084dbb2b61bd74ccd682f2b0978feca868082567d744c71e91fbf3c2ca84039b5dae9fd480ed48d3a8d328e6561cb55b468361d198d75cf7078733d0d3d28d35afaf8c0da12a5fdf726d338006e3951cd210f0d0362f36dc4129e857d066bce8bca9ab4dda4c924cbdb62cb04c7fb13b996acacdbf703854282a36846ff30bde373b776ea9e5795b3a8596ec3ad6f6a6ab4f7c5f31adcea07b65ef8e6460dc25bbcda7740e005c22fbebcf4104d5413f3d153bd1ad57b5c23b9d3098c79ff2dea93e89a3927427733978ca7005498d5e6de4b6fb470c46b188422446d40d99ef62e5d7f62869472787d52483cbedaafcfcbcf8fb32f1048512aa0370cd17f14d1a316dbb8e6ce7fc06450bff7ef2998cd9c75c40528385d00a3094b9d9e858441f98f6aa984c5f2fafd82c853d84690f901300fabe78ea99807f25dac213862874c158cd134ec140ea6cb2f3ccee30350b77708d6e11071208e093aa6933e1708dfb3b1b01f3f8f2b5f13fc9f8412274d8c75e0ef8d6c1e6cb260564dbf1117f21ba620115abc5b10dc6628c60849c5702d5e82a25a17d302a9fc4fbde90bfbd8e712a7f91c16eef22a6f46ad08803596599f7f82fed9f5519a43167db936c1704974d84a9e92797f453dd40ecae34cfeecb5b23536f16cac70ffeb25d5cb4b5023f4dea933410b39de9650f9c08f5a347369529e1a6b166d0d759a692e9e6fb52538222b94ab049e7e942eff406632490ee4cbe3ffc47920a22d25ee71ac1890daa996a3ea82b148ffba90d8fa25aed69f4f5fcbd917fe9a3ddea17d0be28bb849c7d7a2450d8b79962f845f72a522eca19c5d19ff5d146f075f9bea69a5f102fc72df41e7085089377069942febb337ee61c258991ecf4803f40e65c1c64ae1c3d2b00061a510152c4fc79117794be055669dab0ac96162f6678548cdf4c496fff1cf991bfd7c4eec6c352fc654873f96b7af019481356a314db9640bbad6bbe88564fa26caa518c8eddaa6e8671bf4596c0b106ef50677b25c42667fbe7c124431406a2175312dbd039916a3c36e360adc9fcc81793265baa6975a2d16c5a0c22d30b59d6cbc4a13faaedf02d9644e96885f0e23490229f31f39bc7c11a2e5a695ef78878ca804d9298d085cffe0195afc164e81b20363c4395b793000d6ac1fe558604f7f31e1c7a86915b1e50a09fb1e3166df8ce1e54233d6845d025cd23536ddbd53a18f4e3ee9c86ccffdf010baaeffdd755b8c4cc2d173518693d515f1d77e219f0d25691d8f5cd58b187073a2e6b1cded4d06a01f52df75976d1066c3a13fb36fca5d0dc3e3cf631d2e6fc89781fb6abe339977133bef707952479ee3f0a68c9e14781c65a54590f617bf2cbfb667cd14873ba3071ab4f3b1f99aa6f09f03772a62a145bd550e30c9431479f9e88e40454796557cd7bf06d664ca7314bfc470558506181f37a7bfcf832bd6f02b111b7bc6aa844afd67a1c8cdbb54b67d79ab2069ca2b60457b769600559f81e2d17a39b4b6fc86eff01c005495f793e536686820f69fc379f1413a6b3751caf35e8c934b922c3fa3bdb9d8e83b863ff282aa960fc745a1fdc7f6603a34dc409eb46dd8b307e130f2f90f8fb097da2531d7f40a79c3fdcba53f5b498d661540861de45c522e374d9bcf00700e3e62c86ff0cfda343a51453fee7dc56ceb834899e9a005d6cba501b26d58bb82c37ce9481ab1bcbed37dafdc71074eb7d267816a631f971c176e426503244ea8d2929c43cf42f9dec605e3978d797593e67240a56b26332be9a43d14b5acb4e1917822bde4b3b2355b83f8953a53db9beaa4c4a79b89ff65061e17e4ede26bfdecd2e84c6a1e1cbdff480f32c07a0fab0cd3adff1990b61910c584c75b24c32140b87b357240610563d4b17289a9ea910307dbff9684f1575d53774106f69d0b401b59d8a3534d4aed627959e3810c99c9b7c6a19481443a60ed2e5ba0faca95884c67ffefbba4943aecc7a5d8ade693b20490a10d4ae1eacc758061ac6c52819acb27060c2f7132f9cef0f2dd675edc59f3354eca5131c23a49cf2a2340b77cd2aaf6ecac0631d4375363f8e0cb531f170bcb33252a35598601952e7869e3dd88fdbd837b8eda222adad8bcda9617e3f420d08cc00d63bfa7f3a5768a1dfe84a37d967ca6d80fa641391626b54c3de6ef2fb8380577bfc959edd37bd6a5fdbf3ca17cce51d30529c561bf0c0c44ba9502108d3bbf6393707670c1b10f2a8da61f687ec63f0a699ebac77c216d189594d4393c01359e667ec6bf8d543d2a78ef8825dafe3e7e9b6fff247aaad5d578104ac77b26e35278cb34f43fbda668285b93478adf267a86c2cfb7b9e065ae9f7c4ddec8c7bdb9c8ede2a9e3c3fbdc220cc970e6bd8450d1f94ae0988c08703779ad927988970b00c35596a81ea3a060ce523f28fb119d2bad5fb3d563c174bde09476011b7cf246e939c6a921ac08dde5aaa02ac6874bd51d3656b8222d4c4b43b430bb6c1b1b038288c30bee32ba292952b5c09f275a7c8d752b632a7badc719d85871d3baa960d5759721c65b104af4f736680411286c0fbc6ebbe9517202cfb39e07a47249c0ac403951d5ec9fdd91e202244050d4cdd3363755d1c8376a627d14aef2b882d634e9bd5974e8a38808a964d4aedaa2db6d3110237e40bde00f8d6f825e6b9a8e941c7f862dfabc14446ebadf58c83ef194a7c40e8915d3d610a7fa404887fd35238c5e4396bdcab2666c26be0ae5aaa2bf42f460f90157d1be819beed18fa2898005ee5c95f5989bb59ee5a2f96e7cb70f7c31dc305bf03162439650d4e404be8ec4010be2b6a43019323b19591e3a78b5d004fbd709038ad3a07bbd8116d9f76b3b61996ea92a3e5c109087c9fd10c2a15b9df3065681dabf3f5070164fe68ca97a5190499d9e06905e61db5a06cc1eee95435021743a069eb4b98f6fa89f5c404703c1e8321bdea5910207af46667ef2725676c3d41e6a6ded3a4f60afcf265db3339623caa80290fe1b0e5c29cc3022ec8055ca01c286d128fd3cdfeba5b8767b4a24f2d8a0357b754aa53cac8fef6eb53589ec8d9e9897a06f669e8996f8277d5347fda2e8aabe8316dec1d16d67c867d87fae8a988ce6186287262fe85f39319e925ca4470e437ed489bf73656ada44f769ac087dab4b6aaae82a28ccf862156cb949ec9a3a66501f9d3090161ba94993b316f32ae02925e8e416a4bda420530e182dbe5ef28f6d6f8f18ad956f9b23ceda70ba0c72d9b651be24866041598a5795b511ad642445b2a28dee0928d6ad08d13165b7b67565f1a2b4cc9de5d9ec252392081fcd005b38eae22298f5156165c794b567a994cad1a882d8e3c24d692fb89d9417507738d00d6bcfda1ace24d98a26488e58a0de8498eecb713e891143058542499235f3eb8f311df94ecae8bd1cbdacba37780769a8260b7ba6cd08ef641e8818d3bd05c93116582d7c3aa0523f70de9872549f5d61e3c3413df424561dd8e7c2e8cd8ac4efdb806c97679d008a88c0e7e6ab555fadd1ad759b04c6ed9554275b4bcec986bf757435ace224d1789160f9a437a2c51c9788ba2e3e94467cf3563b7e49b6545bf65290c8df403d9d5f80ba6d3f76359ace0b1c43f5634e1eaae20c5de519b35df5cb7f08ef295afa017d31df779b0f18b591d3a562f7e8cf89d6e22886e66968689dce1d2e8b0fa28f7288e49d7f5d43f00b3179dbebd039eba0d35954f6c300026ac00670461d8db3fbd42c8098514ecadeac90a430dc42c6760b00fe1e6aac7c4b7bdabbed9d692a3d6efe401362c32a6e73641307c41e9f73317c84afd2cb7df4d1716333dba43ae13bfd77937b1c955a7bdf589ac923d43594fdeb7f19679fbc380eeb9ffbbb35ae808c61f4221ded377e00f39d680dbe29d9901e85d0d11848c348d7543f103bde52c4452dec72350304f42f83dba99b7a60bcd546532d912639779fce26fb9d55275d832e9cb89e3a32b9061c346466188d1da80366a991133968dee348e47233bf8587f07d020299cbbebfe7396a0bc75c6a8ed49ec1a164fb23112263fc23b90ce74f9e9535e2393abe5a562b7975936bc8d0dff76387ed8acc1baaeef25d9af8df40eff2437dff23eaca473550b577f9c6d251d126874b1d1c399ebb1b37421928ab1487f00a359601b27bafb2562f81594c6589c5c0008e08cc2dcb0a291792ec984990e1eeda1531985fd2096cbf47ae18d487d58a7aed5ba6eaf96a4517086d68a5efffd4f66a04657a0fe7b438ad014e1fc6347b7e62d2ac476b76f2bb220366f491e08f85994b355dca7dcbae4692df9d5f1e8dd1f39fe66966a83296e9f37be3fe46f17ada5691e14c89ac2ffcb73a43f33af758146920929ee3dfee665ecd10477c44f68a29d892311be723ac3bc8b1f950df08009aeef5b3d5ce1c98b441399b70d758442e6f441bafeb0cacaa46ae1ed2c114c03d4acc4ee6f50535714d33aa1317b79d7185193cc737249f4d7a15594c4c32b8d63fc12b2ac92f8ff1c233af31aecdda056fc4f4395fa503e18fc0250946570dbc9851f9230ce103b95eb93e06ecbbccd7f11eb37bdc9b19beafc2ccfc2526250aac9565e4a99290baacae5ba49b188c728dd0572062fef611ef618d1d50c238b9de589ac0548d6d51bdb96e3d0a66762f28edbecd2ee70605bd105aa98ef62dba29624afae0ebd93df5cef776be6b15592ef60830bfc96dd62c5e4e941d7d84e486e6420f515ec9525507a4e3c3bb9459759dfc0dd0391a33435e5926c3718897d3683a98bc0e14a699857eb47899bbb389e84c76bed3970b9e7d74c4b1567417c76a588ef41e7c5dab9f92d9aa24c08b0373f983e479005d459357efb85ddbfe3acb93d8d3b2e1469b1c3c25f3cd41e32f2712d5e459a23167707e95c8e4b461ba0d7260a773002ba41a276a169d35a0846f9807f1c5665427dd51fc7e7e17d4cc1a1b362ba142c36daf7cc5b9c8a54857a6db0f0a008b898e556509a05085bbaedfc77185adf826461b612ec7720da0ad38a79f28a0cbce69fe687b931b55a44461c075f6db2b73dcbb80959b5c359a0abe19ba140df64e7ef598ba3d69e04ec0e2d773cc93ae023e8a5f916a9e53e243ae7eb95b3253b3b18a3c4af9fd7274a0b0e6087cc3c6bc726fa0cac54353e0fbab01a687d8775c4b752a645f6e9d5ecfdc8d7bdec57601c26b09263e3ea45ad104a56982ee0184b63d1bbaf51deabe842a7197128fbb26d83751ab726426940a06fba77af2c1f929eeab30a41ddca4d25be40a46e11af6421fec0551417612c79af77db67217748faa104b1bba0afb21e348e66bf2d07e41e2c53b00916d0da22f6f7be54d41be4a4c3e8ed66469bc7ffdd1bbfeb083ed4f03921847a4bf9ad91ceb5ad9fbc8e53663f82c5ebdf29b6187fc583440a06c58678a889b120ded6a62a73cb499815eb10cdae8a339ab7261eb7cabdd06c0bf31751e2455ad764abb8a5e655739cf3aa54d40c1891c31997e1fcd4ba8749c1119dc5c151d2feb6389fd8e71b217eb420483eb878c46a367db1bcfbe52fe9f3ff291f7eb0e04b2dc9ae9988d0088d73c8adf59e89acc95cd4805ca4a1736ca9d9ff3acc5bb1e5be109817112ac68aad850e4358a2729414b09131009220fad49ffcd460de658ea79ac29ef9a90ee983333ec15ae2c8f105854a4fb0fcdb910ee3aa5cd0c8dfb4c304e1e1b35ab75976fe9e99426d5e71bcadc8cf8799ce4273cf493cb57a64e2daf34a44f3422b4b60fe97b68dacdb1a6800d517a21871e1eef50e4485896098a129b582019ca8d241c9ca2a6054a8bc3e205b6a79621e72eb3f2e5abc22a742e5577300582595910248cab1ce19e660533effc1fa7f35f66cfe2fc84c05260e90c0e2c7c7efe967308138818d3409e1ce3b50bef7f91745a2fdde85c97455b5c0706c1a02cee59168618bcec1bcf1e7e3a6a866adcb835a8be1eb9dffff316f2d4cbe74b4a1ea9ce71598b44d260a402f2239887c96357e7c1badd5f30d75369da5bf1e52fe07ced8114d5ff4a0c17292be213d74c4ab9b5014895dbb213e5699958a71d33bd332c99d07a0393565b278fe8981a769c29a77ea8b0ca76267e9d0a7a1fd47c6a456e61edea655127d1bd2d490f0bdb9a66cf1677dc0d47c282d943cf31d7b99c5faba98ce617774897404789bba90f176f2f786d1294780067fd4afc263cac73d1d8eb17bdd700a0c176f05d3c51970ad3720a3a94c03335add53563b47f1b41b6549a421bff9a4f913e460542b32423675404c5b97c5cc62c80885b75951260dacf004e3e26886743915c4e5fb43eb545bef536bc505b9df8b241273603d301f390ef277b73183f042573d62f61602ae8f6948a93c401a210fd03f6b27f90dc843731d9440e23b3915464d5436cfbf9deb09efd245b2b933691bb12ecdf35c81a88232ede25fe36983a5428b0a6c6bf300fee5965ab985520b3977afe33957570db4eead9fb4263f4239c9ae5d5252429d4da5fcccb0667366280d15498a9b9df8de9619cc9b0ea2fb3e242162bda54eb0d4d11866fe3df3487a89f80fcb64ddcf43218995e87cb7d10ad8e9dd83835bdf32366c0174d369658a65d32240b0517751e5da3812e77de04d5936b902c28da959037c3951c61d07a8dc1868570796b7d8df55cbe3b9d5d2c399e9f1594daa52558b01ae934c39ceef1cce27fc52323d17025e5cbafa21fae2b5eebc6d30b815ae0e1e1d74c2565c5dec729a6dd68ce5582f43c9206d69fa867abe71309b6430068c56c50c86c1d3ed5e09e9d81b7173c1420bb29afd25f60f931b088bcab4bd7eacb03131248fb2a15068730a82cd6bbb4fd186216a9eb3b128e62b0b30ff7af907eadea29f74e97f68c535aac3df1e30a9ad62b8c40d9b91249a6087860ac7ef0ba24b1288beb8f312f3eefa3b908d828c730d0efa6f9898ef651224cc2f0876a77d0ba6bf9f8e43e27c82e35e5db5266791e2fe2c38af2b229492389db4a7ab09cdc9a7a58dbb314011f0f2b6ff8581b55ae2a6b70a596ef53e5bfa2aec3097f612667368510bdd75c31fe32325f2dde2babc8b0bf6cb2a3d5c7cad7ef7d6bceaddcc76ae210a307f66e6b67e677431921052649a4d022057d055c2b4d289ee864bdc08bd14de2a0345a55eacf727f79dbb4a36367f803c2f64e1387d749c145676b84a3c21798cd525789979f679d6603833da2de9881131f9add01d736a2c9ef1d06408826be16656cc2a18e928c2534e476ab0cd6d0d974c55e86b39363d82325db89dd7549881500ea9ee8297e0851866a8e895024fb91de3cc75c4b8087692b102279b0d924583d2b8859174822b67de7352c2fb731c9df59b43610f2cdf583bdfb309b48f43527db8a89724254f6190466f23fa8fc2779bb389365d7b3442bdbc2dcacdb20cb4673573df66c6665b8874c408629e6c39046c754361b53df9a8dbfd54774e8ce7dc414126c6ea3610f3acc031aab0d2106aaa3c1ae6d89623ef90a70ff37647788fcc3354c343ab03b251ee7560594eec2630183759a5aa2a697432b2e0256f858c3c1a3f2f32c0af8b78fde5f2efde5de96b5d6f92c7c16caca02ec222d8a3a9bdf3ca227668e1aaca9ed51b35fa4fed217f67adf843d36c39eff759ee8d2e1eb0a0059a1a8771eaf448c4ac92c81ca990e3810764d0c828a074f4306c7034070360067784bbc60bab3f33adbd92a332494858d00ed7ea700ceab26e1b848e0ff9c437ace097cdd95b0405fdd09791de15ea1e14e13508f7e9224346dc2bd8d89e66c87231015361be936180ea442167c727b721fade4cbd60aab5b7e1083ca04a9cad4c6dec06becdbedc2572dba6f8853261ee65f999033a5ff9d328f0f1e8ac9b69da5fd472dbf9d2bb31b01884294cc2a88ae2345335d60410a349783832bbbccf77db99bfb4943666c7836273ea4725d52ed9fffceb42af12ec536193ad386eda6bd88e1962abb4c60c6bb4a55f7c799d6c2c69e81cb4ed7cc0ae0b52c9c7d79f7026e9d6af223f6955145a38fbf75ba0c0643e1d21646baadbb69c93a69089b1bb0fe7936ca6e5318fe1fda7a7d7c777e56ccb05b53b23de16ee3612f561cd901d4dfcf1b51f25fba05dbee5999bd8d989dcc73321e75cfe81f129c39f3ac55e8c428adb01cff23f9e24687d528dc29ba50247ac034d1151eb0ee8a33eb9a65334ede074656949721d34f9c42012709f7314f40f29edcd61d178cc357ddbbfe6b660dc62c62e9ec28fdd3dbf382d6fe19e27581e335726ea0094b2b46a00ce184daae82208a5e9d1e1b9a1b370c30821dee312736c30aa57a6f05398f5c746ec154891d7c300f84cd6c1f211372fbeed40e02b1d2ce5464ddf7db804e3439a36a72cc10266be46d1759ae614113c36fbe3bc4fff45f163ab4e63cd090c55d8d0a01c9e5efa43728310075611d43fb7affe4436add521b51f979e80b12eef26f4bad8fe1a911e348fe8db0e6de31fb7209e6a5d05bde04673f09739649e0520dc16d8d24c9c6f8222931f9f22fdfd1fb3def8d20c048e046fc4d53095f5bf5fb8836671b0c45413576fb6b245e2c92368e08e35fa2bd75142f35c144a2230fe3fb78fe6924e55cbca88b5d86c9ccc6cdf4a6f8650eaf41cdfc061a1a3fe0dd3f609f78c59cd944bf8ae5eb765bb6d5bc4371a473f29a8a18a7ce46809ed3396caa40425a7a4754d3bac1d5a83d640597c7dc1990453a2812b40edd3a125b36a0d6265c2170bb99edbd3dc52dd406c81235555f00d973a08a3ebfe1f5dbc0b5b3a37b0471917c02bb3b8895b1eaa274e500a419a797bc89abde2a65f2a0304c63c8e94deace7611768ffe16e5db9912bfe2082cadfaee5040730915acf504e8f945966b9ab24591082472fb474649945db6ecaf33caec7b7c6466e45cf64234fa1edef2ebfa4b09a5715d2d08c0f1a799228446c38b00596de207ef905ffe77119ad1b59cfa08ea00cd7e820a33d51c6b4b511ed8fb44ca06af768453eb5b540173d1c674594ac5f20a78c959bf924392cfafecafa085ec9089096d09e59e22906a9594ce75efec326ebc26b7d87550698385cac897f4905e4e95da2887707a21a45cc0e9c524b9851078c713c638adb09bc0802c1647cec8d9b65064f69e2f6310ecea9da1ed745ab06717572e14a11874cf71becf91a8c954985601996468c9a910131c2363ee162b2f466a5cd2be1f04a4c5128ca6525aaa8171167961720614cb9a53e2a593dc78daf9a4f466bc345fa0c320fc9bb7eddce121ac56c834448d3682be505d3037ba086c38c02f92d2d4b6250311093af3d962198d66022bf67a12fc2981aefbbb272d2fd3ffa66564ba3e05e418f9ecda4eec92b86e42fb1896fd5dab5e1b7c25957a7dc0854ac4a53553344fb3470a9ec6713c265ca0f7c5f49abb22266e6453ba7d56f694264a3410038ef8d6503731e1510961f82f43338e8e8633b965f928ea92f05561981032d454f669017b1329f41da28a659af67b173b932ab1a0f49cd2c61751dc41784e57ebee6a39eca82bc8288b85467306013e3e37fb17696666e3b97a26f07b6ff73dd0ecc173a0047fb65280fce3836196f0c8f18afc2045c7edcc7df2c2b58a74a4901204d590", "isRememberEnabled": true, "rememberDurationInDays": 0, "staticryptSaltUniqueVariableName": "5c2d89fb90a7fb820a316620401c1216" };

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html> 