<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95adc501be34168f467bb7f40c558c62c738e601891d276c2075017e5b0f74aeb249862a26a17565595c5cde62ff9fc9557272d221d2f2ddf8cc3c3d2640131ba32db27de4994a41ff20e788fd10ea9106bd9fe8941a7db9a30aa68a9597b6bce98f62cfa0e79d263bf7b81e3578b5e553f14ae8675468363dd498ea903835d05a4366f5aaa4d91c86aea86eaa37456bff9d53b2e616c98c7160f5b73eab02918342b3e51a35aa0fbdbcd67c0b38e01e1f91a39f2699b085634ef7e00d306d99fc23b6225ae90067c17224289f260c993d223116fbb4b07dc6c8d8f4289e2f2ee92d0289af0606677adaaf04c6d54ea8126ee6581a1a60517ce8d26ca2b5f9266fbd5d5b24a2ecf87cc3fd70604a321b8fc3a9c8d4b8b344b62ea4f2910353a9bce2f3de42481a3832f730c205166c14a94ffae6f5d1081223d6682a718e9434562c418283243577515dfc61f82cd777cb7acb22c5a5e23e0be3c439ccbed618b91b0e9cf39a0a805371085b6873e9b65655a6673c8a2d4052bf697d94613a12700e0e9e1d4162483f93a9f8b2495dcc036187b418b4e7030a86d2356e2e69142e43e534f9592a92e95c77945a8a51eef3e76c24e0ac92be24b6767f0349ca8ca2a82a956eb9e535c99bbdfed714076417c4e6e935b170578f1927ccfce469dc5d6fa47a6f8dc807a902ad7cd9460a59b01f2d9c84efcc8e5be1e30491566c06f7f36950c09007154440e8838e5a70faa327ccf0f3e77d8e48391cac1a9fadc459d2a266532f7bfabd96ba5c664496f1ad4d9401f74a04efde57b8fda369bf7b4286b6abef20d62687408f12b54607b388e68bc0c743d90ca426e270a8dfae8546898a85814ce4607e897da55c25f090de4ba5a0503db999902641d1f228a65dcf4503743329a9c9790d28ed0c01edb665903aac1343600f5b8cddd72eac12b646d3749d00bd6459edb114f3c05eaa2e1f85d5b76a5eb7e827178cbc4b302c32b0091ebfc204573e53479863760280efe3301ad0d74d87057b680f64d8c1383efbacf0373def06bde28c112eee919476c887fade85d14e0116844df7f53722ad385f70136d29a2d3cfee87497df67cfac61ea43b681d690f284e4260915283de38d14cf107f1a3ac53471b2ff0d753b1f6b8dce8cd2d08b8601a3f53a11817d34e33abc897af94f3e2b96a7e40410e96ebd873bafb258aa3de3cd5c4a702bb7e6a9628386288ec66720e4c4385ef1e9ac8bb3b38d787d5434da4f0a8cf587dbe0eff3a4bc4a3f17f660fa4b3512522fd372ab2537269707fb9a7d767977030592cdc416c9aa9eae7f317fee7a957115707dd0510dc2a24db12b7983eb48a2b554500d78f3a3cfee288ca6e268e76fcc85d6b1f47f766ac85cb6f94e6d9d229def2291ad10585e0b31aa3b29d073ba04f64558d6c5631da8e9433d7d15bcdaa29a367ea6d6eddcd50a43e5daff6e594617a7a952023518fa4a348157d3fb3354e435881ff5a257be7aa04652299c9cb2afb5bb159e10dafbd1bb5946f65550695c939059e886d49b25f7fa4fa8af550c7de9e2c948845be9134484c14b1933585b30bfcb703ca98c08c0706fbaba9a8e13d9d4121337c289324e2202c31fc7d3f4efd8504365f05be420825e0754607c5a31ff9c5f9cc6e8b14a58a9638f8d6237c6bdebbe85cf03d3a7abd223969772710f07502ddd6c576f98ce0708c0572ab49a1a830cb3e6702363f7080214fc878cc912094fc4438073e7e593925260aebea29cecc5154df65688cd44d3986fda82d9a2fe1cfcfe7c32eb458d83e841ab46cc0002e1453a9f99edabc4426c6671bdf84910e53ef70f2b77f1ac4518f633a53693d4407cb838124a3da5c442792ada44bdd2695e2738a5260bc7455f3ca766d31914a4e93c0b1ef68c6a8a9149f7eeac455cfe49c8f609ab92c7cbc400754c754aeb26f05277f1a33bd4cde810806954d2ac5922891dbf0b9f6d6de85302b5a7594a461b8619da17797ef61197d62a1e9a2b5526770411e794b1f615f167d96e947483e972c18289a20808c1bf394045fcca4953eecfea6fb8cb03ad5317abd950a1357ddac70aa9372867d357a39c3cfea5aaee68ba2dbb88c60e5632fcd5b2d4c346f643acb78d8fd8ac50d283579b5557a342e72e4090c89bb09ef1995ad7159d21b98919ef3316a0b9e8f561641402600c6a863ae5b495de3dd03ec90e823e31438f67dcf96e4eed0baa44e92f9013cac4647a688bcf92b2f4053f8c2e9340014c2fa6a03781d0b3e9048a1e3fca07ac9eb84c3e7850c5189f1ff09a189755e1f41ab79125f422d0c3166b0079b579545570449da2cfffef8695a197f6bef2fc382a6bc2435c33f91f18a4657488dd9690a9ef3935b5c484d8cfd1af9e0f904f9d2e6cdc1282c8c58ef0099a3a6f7b35e5c02ca267ba78c4624d420fe535353b5f1641ff6292e36959ca4ba7b84c118a51204d4cbb2d695707d074e93ce0080fe1d6c2001677a142d8cb38927c0dbf882864a107b965edce77e746749993fdc9a27430a785cd58ca225f2cfe2bc7938561b735467cb6fd67e7a625bdfa032d5cf632a3218c07b7de4788eabab16e7e6c532468343784cd923def4b9fe3cd9e6c1343ce34fd49b59c1054e347209585f9bda5f651407c3e06167aa25d89b02577ab604a3b4e6461ddb41922c580766397ad6b723987fb24fa71925185a1eedf65b9a650aab2d4589891d17c415b94187f14ef77d2a3d70066601f9b67f2338c3cf412b9cdef923f45dc656522bb5d266bf46412e7cbf58d9b4d2b2417582f1346ac41e2c2c1bf9dfa9af7f38dd386e3255218c5d824af4f2a591cb3176d657ea647a57584273c654f07eadbb066d91f03e108c05c08b89ae2fba3e2b55920cc51c988edf4752101be4633962e984e0ec20ee6f0404064485d14fc08215b9362808cf054c15c05163e97649cf822a306d4b9a2e3acd7780a314ac27343b5bf3dd5dcc5aef14d81ddc718eb3119fb68c35549817d2d0ae45fccc62f1efc9e1d40b1ef85ab1f306454edfe554fdad297247391cfa490457fb4e06f835a376b2b00523909e6c7bbf7968d7a313b94712c6143d7c1b13afc5d07269505afde740446f7b6373e4889700aa301569cf3879810ef3a33c1d2438483f63418e8b014afcf4ecf65e964f5a8eb9fccb9f2acaff89bcb7e804b7df1d4a711fb401a870d3c35b9860cb016e88c29eec15e53a0b0d524ce9c124417f02f99070a2bbb1a09ecb539c9118193775865e11164f0c53ad412b99c468206b68e19d88e0f4a96ef9e4daaebd441127fbff117225d87ede950b9e060e6016c5943c4daf9306d6f7334c2cbad8bdebd42e6fad68dbbbc8dbeead5c660c3e777ada46081bb945e6e8c11156dc5af07d7267de90dd159188004e581a5a606071b9dd29bed2837bc19ad413a5a61417cb91250ed9978f372124f0ad255a847ac9251cc4050c51b562a817aed5fa53321bcf2ff8bc9fbe0acd45e5ec3dcaec6c1433b3dc9529c219fcdba130278172c24fb17b020dad3a933483f1a8a3e68b070c096f38e9cb0e696732805a4a2b52f425f1420215d0e945d9e494ecca1f4e48646db1ad2809a1c5c84c0a7edabd14f49e29354546921d8f7be845ccff23028b23bee8141ef66c11b69a231d0b97600f923014843cf5fb11d035c81089c5fc28f8046372bf2031dab39d3145811eaeab8a5cea17ddca11505d7eacfac2b006d43dfb1569cc24c6796608f69dbeb2f94cae88d485ba6f31ec843141cbdf0fadfce9ba7cce612b2aa1cd8564c42195f9d907088de7e0b67f03ef54932ec53d1a3b03ab3d86ecf50fa61ce7e8430e687ca0450d0cc4b754abe4ae47a2eea0040456ce3610b287a65bf2fbb2f1aeed48867b5a33a5a8c7d7f5de2285f8e35b763222873b0a2fcf345f3d90cbb5f13cf6b34f6bb93a0949c8a61146cd712ff00a6a554fe2c7fa61602ec494917661190c366b47213a52c930b7c71d73e8ffdac4833ea5674d17f838b50b08b8bfd17916429f4dc17e499aa46b3685aa5b404506c707b8475b334110e7aacaa1a8a1aec175991d1de73a7a378680946b52c429cefb1d25c22e84902fcddc4213b811e6c80a38dd824ae6c5c2483f98c64eda36d1fce99b4208c31ec4741a12f72d2c7b4fea94e8be0e4c66315b7ebf5e2f7bf458313ba71cfa10531048c7cfea6f77b6bdc4e53c368fa2d1cdf4f25107963e7a0fa8623158c3f560899c7b7ee032a247d168eeaeaea14e111fe483a5c6e059569c6395163ba3c1b4d8aa22c7a9ae7bb3d86fe69f2ae3f1d675e66ef6283e13cb4abeb8f7ca106cd89e43b8fb957a03b2a44e98da2c47df8d3cc3982dce4be8b90a00156f6c0d8c0d3e1a06afa4decbffad23d437123684da261893e5405422a61b290a4609607d643685e78aeef19e4d6b7abdde13265ea076aaf541245c670674dc88912f7a6fd3ec24fddc333cec19ff6204f8ad59b95edfb7a32d00b4d9076f4a16bb946b43d610efea751e99c3af4693270cfb4bc90fa0fe7e1e75899810204f127373cf06c0afc69a9e04d332a500b06a334e2d4b97bcbe0cf3cdce5ebdb9147719e9810836cc35958730e1ab2e79851d0d2489b612982ab543935b5f6fc0db976c1e4842e347b93380f33cb3e9e39534b278424c7bc5335ff23b223e19c228b93a4c25f74ad461441107c794bcf75319fb8af6fefd5236b8f2d5974653d73c457ac21f8bac5a26559b3f9f6128fdac4e5143a4268ec0d96c0904d25d608cd34a494b085a1798333fb1c4778060f84311c919f21e9de2951091ec50ae89f1fee79b162bc97ed4522c2f6f0771e28851eb247e928761269e13241cb087b12a19c3a3c2f4b102771c4e1a71443432e8c1c258f3fabf852c04468d85f9bc3d4170e1a95950f84328a4304c4ca8dd39b3139589c3054e37d54ef8079d377bc0ba6a49115e104f96834ab81dcffcc651d521ab97f586ebf21864f2141971576ebcc600b109867c3490552df5ff4f7d1dcb1a6c93a38667cf22ea748eab9b7b83c98c4533370c4bf76656e723d5b248832290f3952c4a915d9d85e4ccb0cdd53db199afd6b3ca888257d359fbd45f23b20fe4ce4f2715e0372c0f97a79ebf539731c7547b12af5c823ca021dbd07fb9ded381b7dd8daeaa8f739547a45f7a8f9fd740a86006bfedd6c35dd35f0d1dbafe834403e3db311e1abf7c31f6348e6f7cd23c08e5ff55c3627eeb08f2ff9e9e17308ba275202602d0661f995fb8f2b306b19b05fb8880b740fba22461192ae1736c7c85f61b0e522775d584a291e6688b9fb7f0c0fa3266dcdf1286ca33defe0f1de3be78eeca241897db74d5d48e96db77a8802a161c4d2a5590def611eb26066d2499be109d528ca8732e114a6aa5b057ec38588dcff73256f679ffc24d4a3262091ef3880c8cad1d1036f7214f1a50c9361357bf01c94d5be4a6b6cc274fb3e4de17f9f712cb96df5b3fc7bb41f7eda13ee40ce1710b25da9aff53d0d9abb463bebadb15c9f7ac43b4c092feb880f21abd12eed32f81a5533af29bac74d9cfbb6dc229c7e22f4706f719e28c6c7218098263e355e3b9ff5805af06351b38f2f2cbbb0bc88c7f96253eb0950ba54e0cf2ded0e53b730fa63e8f05dbf69de7e0e3e90210414659723e79dee7c6c42c37db0909b28a0eadcb527e413df0595d6b4147937042d85405a08ace15e7314e0c1387a63106eb13fcbad1ce16cfd8910f72f341bf39066379a19111646f50a487c9234c7a7fa10a88c6c6ef9fdf8b644a118491898a4763577f89b00ae82c2c9c4300946aa3ea30ea555aba86aae26da71441334ba8882878a1d1deb0197b1831f8ec3bc1779241ef5b228c919a84996f2fd1e253f7861ae2767e6cd68e586d1441b21433fb475a6b3364ba11777f93e2756abe687df62e7eea18c98909f66c1e2478e1920d2b74bce365d38ae827a53714db4010eb90dc82713a5a0ac9f76f1de214e5934b790380b1ff95bacc8b7c895293b9fb053790ea46257469497e773c59b3acef158201bec9ab94e20318cb1a1918ad4c1f019c12e069af0e5e47e547e668b650f93f0663089e99a1a60c268621c96eaeaf46da03e820e0d27cf936f393a27be966020c05cb49a50d950c1a7539371c32f42d3daf37d6411beaad303a74905c78955947d2bcd087d35d4e68ddbc16fc34f2830e11f5d2496753af9a3804f65bbe4555820a0451e560fce181e012819d80993e373e5e2c9acc7fd5f750d06bbde908ac9c166b6ccc2262aa3d9bd58cc4e4c9a25adc29feeb3c42a83631cabdf6faeccfbac3358d681efa7c1f575cf1525e33d3dc8dd6e03ce851667f5e4aa61a4415235a22fca5d9c388cfd808e7090760130d2e19cef4d5249f60dbfcb2831be49c3731f43176a8681fa5a294a9aeb574e62aab09516bbc05237df475d359037090e2ac9d737a2288ec9a0c64e8e2592d8534d97045f55952f1fb539930978f63e4f430e79077ca2b032879c6a6f272d50110745fae01f3792074be0b3bf2b5239114a594ef8cd0266816d1ff3c6c300d18085f30bacddb9f6087ac647e74303b2346b4ccfd97f53ba3ecda84eaf3bd837bd3716f9eb366692c7e3ebdb3aeec7337fa49cc0c0a14dc9d7566323d72a12986c91769cab6edce0078e017ce71ac940d9c8c344c4ed88dcdef65a178714050a42b710862000445cf1ee2a82d3857a6f3eb590ae7241664c7e805d54f66e734d07efc7bb2c42e23e3eaa2302ca801cff8a3875d751a6f782f5c7e3ef98484844014b529c1a6d678a21dc8ec55b5dc65c4937d6c026442c752376b46b48510250c7dd50f2aa4337ed5f2b848866a62f0c40dd2023866ad5ee8ce025076d72fe3fc474081cfea223073bc05dd04e0f99020b1c199f88100a2194f2970fbbbe8410e38a4ba23333eb7adead7a1a53df0f11368e0b374e4a5e96e06a16edc5db4f7ce82a3f0ee6bf71026bcd93ad0b04affb39f31fe330031f80463dadd91f22dc1858e1fac02a52715ea703211eda7eb9c8ee5333deb7be584a5264adf4c8f31486a2a413df719750f18188d26bf1bf6f99738eb9c77a3b7fe1b003f99bf25178c254cdf43c385a031c280cc8a272db2d7c8764a1b33563fb1f264356b5dbf36af8e662483e5b183afccfd48a1547c4b7ade8d1b98dc0c0e690d090ae19ef58b28db234c3897a6a94d7b71dc07c16d10a1334b41c91a3c557fa74785fdc44b8a669c86922450be04f406f0b8be0108314c739feb3295cdd4e08d2031d9e0825181d2c6faebd7ea9244655fba99e76df64ac45d59a92cdba19fe8f71437fa529f9a296a22e94b550e449ec1f55faa5d444110036605526b7c268704056e40a72ac4731fef8823bdeb0c727cc7f191411d490808cc7ac378002dc704d5350e33130487f0e9a3721cb51599e6d1ad44c7192331a182a1ae2e2310ab1678413f165d98abb479b7da27eb8e55ba957d9adb53f5820787804e8d1730f23673a3a26119dc7a08b709bd350beb57543453c0058095c067933b310e9e63be519c73334b30b05ce19b1a69501df3ef0cf4ef1c41a13e4f492fb85d60f51d850d0da433d097e13517b544a53af45b589757509d65e68bb5573156e96ed056208719ebc9ff6e522ac663353f90705fdfd726c0ce84ad8173fedaac537f38d2504345dd185b299028dde50542196806611d9a0fd1c33e966f42e8ce0c48fc67f5e38610aa5a116e30c5e647e09978f72730473bc6236a4e78fc6f7bc67c6fa2f8260a0e257903e8a4d6064837c20f0a1efe891973fd4e78eccac053b19985281e58267c31f60870af80af4776bf1426dd481ebbe53f8ac8fa29c17385b1fabc4d8de3239f8819c9b44f9299fcd8a008b70e9edd49d3bb69a1d7243dd0bed3da16791880205f2aa26ae53e2a5986b86a0c3bee63076c7b2fcd1a2a965f956ea17aee0d9f95ddf29a2e60598a403496404f956700b69ee94dffe285009e7f89fd0dbd0c518dc9a1fa81b9a609a77547d7458c154ff5a838db0bde63aa9e8a9b152963751c2dce0142ea49504d6a316f94859163ff3b9aa0d171a0badf69696b6598556c6c7ace6fd28efcfa0684413951fb86f45d07117a51dda53540e858c179d69fbf64d05ae92ed575dbc3b173a4353c9aa3ce07f6321b3c31c9280b581674e664997dc276088ae4612b1f98b1399387421e63341d0faaf81defff74b624001bdb2d1aae70ac2c9d7bab3f6d9e17fa71f11a86ff90c01320112ac146f0824c6203bd742c2a2574454f44b07a0b74de656b2eef46db5b1e679ae6aedcedc2720c07bd51223b3765fd29b493e39e127ddf98f5cde49fb5b93394a80fc72a389a673f9486df1f0af3d181f4ef26fd5ef9287b637c0690dbd8510ae3e1c811768299a3bac3e3f41ebb875f08c36d739d45389462d4c92effdc841d331cf2f0e01d9f2252cd5fa43a6be335a28b4486a7c414802919406225f12666c98a679447b8a3075bf4777cf5b47cf36bc6ae5763a1f77466c169a12fd28017c59651f3ba5c8c3fd4a2d7a6a4803f10387a1ad1e9098d8589e661d260a9b7a5eb1b63cf9bc04c47732c8bc20f76e727a340a901faeac879bbf28397e16de4617ea801099b57f5275fa0c51a474c3ea25b60eb665f5265eba03d68c89e47b8b1b30eb14d9dd3d1a94fadfe1af431995caaeafde0754f708ff32064a63408f7358678e5986a964f0db865f18b4f683cd58017e1ac4621c513c9af0df39d4d3263607e7c67341aa8784d5fda4590e5efa55fbfa3e59a739286fff7c093b4bfde78bc5d1c2e98249a0294eb07b8f4083e76b1ad786b5a6047fe74063446c932cafac87b572ddce196f46e000697865613ab1de8fd3380c6928a961b0b8c17aa8fc519ffe2167ab6fbe3cb71d60b4a4149ef0cb17d4a388e798b31ad73140c053b6b46d3e3e714994d8c47980fbbcd44dcd5d716489cf58ea07e767fcd4b2b05961670ee84a4d7dbf239ab511a77ddf97c6cb34e8966ddcac772fc614d495fc08b9e4731493a41998d7f2688bf05376dcc69a5d04b726c3f852caf1c7c93252c1496eef740b1b84b1199b12e23ec7916373edb1bc0e62210d3e37e045b09f34b809bf55aaebab84b05ae61b63283367aa127049aebf858874f3c50f58cad09fda3fed119b71a84843c735b5b41b657fe666f6c9cbb86d3924a78ce209ebbe423d40190e9760a6984db461b3d8ad6f15a29c151c653c1c8a7f69964b97a4c0046bc75bd1ad7eb152f585ac31fec1d382f3711a5268fa1afdcb663601759286c7df6921645e7df0914171f327088f8e328dadd7d2518dd64cb3312919be33172bada1b7bca1e1b6a1de1a91e7edd55a493439ed2a711da1c4e9c82117ad7f228d40062c60b92324402ceacaf4b47bba5816cb1a325af35fc160b74d74daea7c8b9106a294c73b238767a2848ba7f0bde41a406cb322eff1cdbc65a9dcfde08477df6a9becbdd1c42cfd1fb578aadc85c3a19344c613511b484963ef90963e35595670567bd00d965b4861a289356a648bc0e9244a8097a09886943a624a61a494932379b985fbf1a98eebeb5fbf788211936b91c2d0ef874c57ee1112755c01f3e99851e1e5847fff2089a4133f3bcb8959a4cd0f2bf5532e5455e0671294a7cb0f1ad7cd9fbd744813b73f5812c0c6037a8cfb2c3149552aacb48e38e715c13767310128acc5dab9d1e6a7b361d97544a7381f985f7b6b8619934aeb4f1cc387195b0e8af451450e0fb4631ec09439e6911b8632e491b1f7290822a6fc4d9aa6e82a272079e20ca7a64f8b764d86d25071f7f9d072bbf28b578602ecab4c4363b3b78af072765cbd8012acd976b336b0da57873f6b72ed2070f685a4ff7503edeeb1325583e5ecab4d431c50883cf66ecaba80270932462cf6f2e3f7671dc96f74f6bf9b23a30c68cf96137bc92f615187e3a400b6003458afbef8f0264de76962fd22402ae2e810e5bb9cc5a24273815cb508797034728097e34589a447f617717a3916a46cbfc8baebc830a65e9ad38b9f65cf4d2b9c9696f1ce1e6fcea44b86e581bc79ccde5e3ff7437c41bda941cf4c585fb1eb1cf3c8668ef91186e2e5a89b1447c27cb4dedff7e5f2d8e21a428bc358dd3cca2d9bc122740198b80065ff3250e0684836d4cd0bef22fdd6b8fe89ff86a76556a1948daff95fe4a4beb677be846eaf8db8af4ce810b8cf1e181814d2cdd3f6eb5d41f62feb4521785180666fad0c87d0e5bc7b67489c2925656b061bd5a10da2c73ba21205b17663d62f7355aee4e20e80d75808a51cef43bcaff79b370b9c1f215903ee98f6b96f6dae89e17eda6636cf8258e97cf9e81317dfb85baf7f24c5b3c9206a60b467ac4b88f43c8f09e75ccc0b577360b7992cfedb61017a11af274b3285666f66fc8a8456c1597487f920706b039da407e06dd2efe9c90dd7fceb6032af6a1613521888ca8612e93bb5322e4fc080b688f4c01e954a2c4eb016ec14887607ba4f009d9b824d3480796b64a4bbd68d7ad46b017ae2d47fbca01f966e565b7d968b6634020b2f602f4c439f19a0ef9a609bbfbfd7c00e22aabb2e9d3409254cf11ff9b3933ecd2d96a8b6301932d59433d55bedfe5c35f3faac48c46875cf57ae1b98e43ba0f847ca93c07cfeb016934bf26915083a3caff9f61ee896a15c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5434006c743becdea8a3f5ac98a5e7ce"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
